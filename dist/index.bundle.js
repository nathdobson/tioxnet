(self.webpackChunktioxnet=self.webpackChunktioxnet||[]).push([[826],{424:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(537);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, "* {\\n    margin: 0;\\n    padding: 0;\\n}\\n\\nbody, html {\\n    height: 100%;\\n}\\n\\n.toggle-button {\\n\\n}\\n\\n.toggle-button-on {\\n    width: 60px;\\n    height: 60px;\\n}\\n\\n.toggle-button-off {\\n    width: 60px;\\n    height: 60px;\\n    display: none;\\n}", "",{"version":3,"sources":["webpack://./src/index.css"],"names":[],"mappings":"AAAA;IACI,SAAS;IACT,UAAU;AACd;;AAEA;IACI,YAAY;AAChB;;AAEA;;AAEA;;AAEA;IACI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,WAAW;IACX,YAAY;IACZ,aAAa;AACjB","sourcesContent":["* {\\n    margin: 0;\\n    padding: 0;\\n}\\n\\nbody, html {\\n    height: 100%;\\n}\\n\\n.toggle-button {\\n\\n}\\n\\n.toggle-button-on {\\n    width: 60px;\\n    height: 60px;\\n}\\n\\n.toggle-button-off {\\n    width: 60px;\\n    height: 60px;\\n    display: none;\\n}"],"sourceRoot":""}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUMwRztBQUNqQjtBQUN6Riw4QkFBOEIsbUZBQTJCLENBQUMsNEZBQXFDO0FBQy9GO0FBQ0EsNkNBQTZDLGdCQUFnQixpQkFBaUIsR0FBRyxnQkFBZ0IsbUJBQW1CLEdBQUcsb0JBQW9CLEtBQUssdUJBQXVCLGtCQUFrQixtQkFBbUIsR0FBRyx3QkFBd0Isa0JBQWtCLG1CQUFtQixvQkFBb0IsR0FBRyxPQUFPLGdGQUFnRixVQUFVLFVBQVUsTUFBTSxLQUFLLFVBQVUsT0FBTyxNQUFNLE1BQU0sS0FBSyxVQUFVLFVBQVUsT0FBTyxLQUFLLFVBQVUsVUFBVSxVQUFVLDZCQUE2QixnQkFBZ0IsaUJBQWlCLEdBQUcsZ0JBQWdCLG1CQUFtQixHQUFHLG9CQUFvQixLQUFLLHVCQUF1QixrQkFBa0IsbUJBQW1CLEdBQUcsd0JBQXdCLGtCQUFrQixtQkFBbUIsb0JBQW9CLEdBQUcsbUJBQW1CO0FBQy94QjtBQUNBLGlFQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlveG5ldC8uL3NyYy9pbmRleC5jc3M/ZmFhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIioge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxufVxcblxcbmJvZHksIGh0bWwge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi50b2dnbGUtYnV0dG9uIHtcXG5cXG59XFxuXFxuLnRvZ2dsZS1idXR0b24tb24ge1xcbiAgICB3aWR0aDogNjBweDtcXG4gICAgaGVpZ2h0OiA2MHB4O1xcbn1cXG5cXG4udG9nZ2xlLWJ1dHRvbi1vZmYge1xcbiAgICB3aWR0aDogNjBweDtcXG4gICAgaGVpZ2h0OiA2MHB4O1xcbiAgICBkaXNwbGF5OiBub25lO1xcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvaW5kZXguY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksU0FBUztJQUNULFVBQVU7QUFDZDs7QUFFQTtJQUNJLFlBQVk7QUFDaEI7O0FBRUE7O0FBRUE7O0FBRUE7SUFDSSxXQUFXO0lBQ1gsWUFBWTtBQUNoQjs7QUFFQTtJQUNJLFdBQVc7SUFDWCxZQUFZO0lBQ1osYUFBYTtBQUNqQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5ib2R5LCBodG1sIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG4udG9nZ2xlLWJ1dHRvbiB7XFxuXFxufVxcblxcbi50b2dnbGUtYnV0dG9uLW9uIHtcXG4gICAgd2lkdGg6IDYwcHg7XFxuICAgIGhlaWdodDogNjBweDtcXG59XFxuXFxuLnRvZ2dsZS1idXR0b24tb2ZmIHtcXG4gICAgd2lkdGg6IDYwcHg7XFxuICAgIGhlaWdodDogNjBweDtcXG4gICAgZGlzcGxheTogbm9uZTtcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///424\n')},645:module=>{"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = "";\n      var needLayer = typeof item[5] !== "undefined";\n      if (item[4]) {\n        content += "@supports (".concat(item[4], ") {");\n      }\n      if (item[2]) {\n        content += "@media ".concat(item[2], " {");\n      }\n      if (needLayer) {\n        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += "}";\n      }\n      if (item[2]) {\n        content += "}";\n      }\n      if (item[4]) {\n        content += "}";\n      }\n      return content;\n    }).join("");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === "string") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== "undefined") {\n        if (typeof item[5] === "undefined") {\n          item[5] = layer;\n        } else {\n          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = "".concat(supports);\n        } else {\n          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzRkFBc0YscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW94bmV0Ly4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8yNGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///645\n')},537:module=>{"use strict";eval('\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === "function") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n    var sourceMapping = "/*# ".concat(data, " */");\n    return [content].concat([sourceMapping]).join("\\n");\n  }\n  return [content].join("\\n");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM3LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlveG5ldC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzP2FmMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///537\n')},607:(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Enumify {\n    static closeEnum() {\n        const enumKeys = [];\n        const enumValues = [];\n        // Traverse the enum entries\n        for (const [key, value] of Object.entries(this)) {\n            enumKeys.push(key);\n            value.enumKey = key;\n            value.enumOrdinal = enumValues.length;\n            enumValues.push(value);\n        }\n        // Important: only add more static properties *after* processing the enum entries\n        this.enumKeys = enumKeys;\n        this.enumValues = enumValues;\n        // TODO: prevent instantiation now. Freeze `this`?\n    }\n    /** Use case: parsing enum values */\n    static enumValueOf(str) {\n        const index = this.enumKeys.indexOf(str);\n        if (index >= 0) {\n            return this.enumValues[index];\n        }\n        return undefined;\n    }\n    static [Symbol.iterator]() {\n        return this.enumValues[Symbol.iterator]();\n    }\n    toString() {\n        return this.constructor.name + '.' + this.enumKey;\n    }\n}\nexports.Enumify = Enumify;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA3LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlveG5ldC8uL25vZGVfbW9kdWxlcy9lbnVtaWZ5L2Rpc3Qvc3JjL2luZGV4LmpzP2U1ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBFbnVtaWZ5IHtcbiAgICBzdGF0aWMgY2xvc2VFbnVtKCkge1xuICAgICAgICBjb25zdCBlbnVtS2V5cyA9IFtdO1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0gW107XG4gICAgICAgIC8vIFRyYXZlcnNlIHRoZSBlbnVtIGVudHJpZXNcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcykpIHtcbiAgICAgICAgICAgIGVudW1LZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHZhbHVlLmVudW1LZXkgPSBrZXk7XG4gICAgICAgICAgICB2YWx1ZS5lbnVtT3JkaW5hbCA9IGVudW1WYWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgZW51bVZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbXBvcnRhbnQ6IG9ubHkgYWRkIG1vcmUgc3RhdGljIHByb3BlcnRpZXMgKmFmdGVyKiBwcm9jZXNzaW5nIHRoZSBlbnVtIGVudHJpZXNcbiAgICAgICAgdGhpcy5lbnVtS2V5cyA9IGVudW1LZXlzO1xuICAgICAgICB0aGlzLmVudW1WYWx1ZXMgPSBlbnVtVmFsdWVzO1xuICAgICAgICAvLyBUT0RPOiBwcmV2ZW50IGluc3RhbnRpYXRpb24gbm93LiBGcmVlemUgYHRoaXNgP1xuICAgIH1cbiAgICAvKiogVXNlIGNhc2U6IHBhcnNpbmcgZW51bSB2YWx1ZXMgKi9cbiAgICBzdGF0aWMgZW51bVZhbHVlT2Yoc3RyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5lbnVtS2V5cy5pbmRleE9mKHN0cik7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnVtVmFsdWVzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzdGF0aWMgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudW1WYWx1ZXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcuJyArIHRoaXMuZW51bUtleTtcbiAgICB9XG59XG5leHBvcnRzLkVudW1pZnkgPSBFbnVtaWZ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///607\n")},162:function(module){eval("(function (window, factory) {\n    if (true) {\n        module.exports = factory();\n    } else {}\n})(this, function () {\nvar jStat = (function(Math, undefined) {\n\n// For quick reference.\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n// Calculate correction for IEEE error\n// TODO: This calculation can be improved.\nfunction calcRdx(n, m) {\n  var val = n > m ? n : m;\n  return Math.pow(10,\n                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));\n}\n\n\nvar isArray = Array.isArray || function isArray(arg) {\n  return toString.call(arg) === '[object Array]';\n};\n\n\nfunction isFunction(arg) {\n  return toString.call(arg) === '[object Function]';\n}\n\n\nfunction isNumber(num) {\n  return (typeof num === 'number') ? num - num === 0 : false;\n}\n\n\n// Converts the jStat matrix to vector.\nfunction toVector(arr) {\n  return concat.apply([], arr);\n}\n\n\n// The one and only jStat constructor.\nfunction jStat() {\n  return new jStat._init(arguments);\n}\n\n\n// TODO: Remove after all references in src files have been removed.\njStat.fn = jStat.prototype;\n\n\n// By separating the initializer from the constructor it's easier to handle\n// always returning a new instance whether \"new\" was used or not.\njStat._init = function _init(args) {\n  // If first argument is an array, must be vector or matrix.\n  if (isArray(args[0])) {\n    // Check if matrix.\n    if (isArray(args[0][0])) {\n      // See if a mapping function was also passed.\n      if (isFunction(args[1]))\n        args[0] = jStat.map(args[0], args[1]);\n      // Iterate over each is faster than this.push.apply(this, args[0].\n      for (var i = 0; i < args[0].length; i++)\n        this[i] = args[0][i];\n      this.length = args[0].length;\n\n    // Otherwise must be a vector.\n    } else {\n      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];\n      this.length = 1;\n    }\n\n  // If first argument is number, assume creation of sequence.\n  } else if (isNumber(args[0])) {\n    this[0] = jStat.seq.apply(null, args);\n    this.length = 1;\n\n  // Handle case when jStat object is passed to jStat.\n  } else if (args[0] instanceof jStat) {\n    // Duplicate the object and pass it back.\n    return jStat(args[0].toArray());\n\n  // Unexpected argument value, return empty jStat object.\n  // TODO: This is strange behavior. Shouldn't this throw or some such to let\n  // the user know they had bad arguments?\n  } else {\n    this[0] = [];\n    this.length = 1;\n  }\n\n  return this;\n};\njStat._init.prototype = jStat.prototype;\njStat._init.constructor = jStat;\n\n\n// Utility functions.\n// TODO: for internal use only?\njStat.utils = {\n  calcRdx: calcRdx,\n  isArray: isArray,\n  isFunction: isFunction,\n  isNumber: isNumber,\n  toVector: toVector\n};\n\n\njStat._random_fn = Math.random;\njStat.setRandom = function setRandom(fn) {\n  if (typeof fn !== 'function')\n    throw new TypeError('fn is not a function');\n  jStat._random_fn = fn;\n};\n\n\n// Easily extend the jStat object.\n// TODO: is this seriously necessary?\njStat.extend = function extend(obj) {\n  var i, j;\n\n  if (arguments.length === 1) {\n    for (j in obj)\n      jStat[j] = obj[j];\n    return this;\n  }\n\n  for (i = 1; i < arguments.length; i++) {\n    for (j in arguments[i])\n      obj[j] = arguments[i][j];\n  }\n\n  return obj;\n};\n\n\n// Returns the number of rows in the matrix.\njStat.rows = function rows(arr) {\n  return arr.length || 1;\n};\n\n\n// Returns the number of columns in the matrix.\njStat.cols = function cols(arr) {\n  return arr[0].length || 1;\n};\n\n\n// Returns the dimensions of the object { rows: i, cols: j }\njStat.dimensions = function dimensions(arr) {\n  return {\n    rows: jStat.rows(arr),\n    cols: jStat.cols(arr)\n  };\n};\n\n\n// Returns a specified row as a vector or return a sub matrix by pick some rows\njStat.row = function row(arr, index) {\n  if (isArray(index)) {\n    return index.map(function(i) {\n      return jStat.row(arr, i);\n    })\n  }\n  return arr[index];\n};\n\n\n// return row as array\n// rowa([[1,2],[3,4]],0) -> [1,2]\njStat.rowa = function rowa(arr, i) {\n  return jStat.row(arr, i);\n};\n\n\n// Returns the specified column as a vector or return a sub matrix by pick some\n// columns\njStat.col = function col(arr, index) {\n  if (isArray(index)) {\n    var submat = jStat.arange(arr.length).map(function() {\n      return new Array(index.length);\n    });\n    index.forEach(function(ind, i){\n      jStat.arange(arr.length).forEach(function(j) {\n        submat[j][i] = arr[j][ind];\n      });\n    });\n    return submat;\n  }\n  var column = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++)\n    column[i] = [arr[i][index]];\n  return column;\n};\n\n\n// return column as array\n// cola([[1,2],[3,4]],0) -> [1,3]\njStat.cola = function cola(arr, i) {\n  return jStat.col(arr, i).map(function(a){ return a[0] });\n};\n\n\n// Returns the diagonal of the matrix\njStat.diag = function diag(arr) {\n  var nrow = jStat.rows(arr);\n  var res = new Array(nrow);\n  for (var row = 0; row < nrow; row++)\n    res[row] = [arr[row][row]];\n  return res;\n};\n\n\n// Returns the anti-diagonal of the matrix\njStat.antidiag = function antidiag(arr) {\n  var nrow = jStat.rows(arr) - 1;\n  var res = new Array(nrow);\n  for (var i = 0; nrow >= 0; nrow--, i++)\n    res[i] = [arr[i][nrow]];\n  return res;\n};\n\n// Transpose a matrix or array.\njStat.transpose = function transpose(arr) {\n  var obj = [];\n  var objArr, rows, cols, j, i;\n\n  // Make sure arr is in matrix format.\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  rows = arr.length;\n  cols = arr[0].length;\n\n  for (i = 0; i < cols; i++) {\n    objArr = new Array(rows);\n    for (j = 0; j < rows; j++)\n      objArr[j] = arr[j][i];\n    obj.push(objArr);\n  }\n\n  // If obj is vector, return only single array.\n  return obj.length === 1 ? obj[0] : obj;\n};\n\n\n// Map a function to an array or array of arrays.\n// \"toAlter\" is an internal variable.\njStat.map = function map(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    for (col = 0; col < ncol; col++)\n      res[row][col] = func(arr[row][col], row, col);\n  }\n\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Cumulatively combine the elements of an array or array of arrays using a function.\njStat.cumreduce = function cumreduce(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    if (ncol > 0)\n      res[row][0] = arr[row][0];\n    for (col = 1; col < ncol; col++)\n      res[row][col] = func(res[row][col-1], arr[row][col]);\n  }\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Destructively alter an array.\njStat.alter = function alter(arr, func) {\n  return jStat.map(arr, func, true);\n};\n\n\n// Generate a rows x cols matrix according to the supplied function.\njStat.create = function  create(rows, cols, func) {\n  var res = new Array(rows);\n  var i, j;\n\n  if (isFunction(cols)) {\n    func = cols;\n    cols = rows;\n  }\n\n  for (i = 0; i < rows; i++) {\n    res[i] = new Array(cols);\n    for (j = 0; j < cols; j++)\n      res[i][j] = func(i, j);\n  }\n\n  return res;\n};\n\n\nfunction retZero() { return 0; }\n\n\n// Generate a rows x cols matrix of zeros.\njStat.zeros = function zeros(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retZero);\n};\n\n\nfunction retOne() { return 1; }\n\n\n// Generate a rows x cols matrix of ones.\njStat.ones = function ones(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retOne);\n};\n\n\n// Generate a rows x cols matrix of uniformly random numbers.\njStat.rand = function rand(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, jStat._random_fn);\n};\n\n\nfunction retIdent(i, j) { return i === j ? 1 : 0; }\n\n\n// Generate an identity matrix of size row x cols.\njStat.identity = function identity(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retIdent);\n};\n\n\n// Tests whether a matrix is symmetric\njStat.symmetric = function symmetric(arr) {\n  var size = arr.length;\n  var row, col;\n\n  if (arr.length !== arr[0].length)\n    return false;\n\n  for (row = 0; row < size; row++) {\n    for (col = 0; col < size; col++)\n      if (arr[col][row] !== arr[row][col])\n        return false;\n  }\n\n  return true;\n};\n\n\n// Set all values to zero.\njStat.clear = function clear(arr) {\n  return jStat.alter(arr, retZero);\n};\n\n\n// Generate sequence.\njStat.seq = function seq(min, max, length, func) {\n  if (!isFunction(func))\n    func = false;\n\n  var arr = [];\n  var hival = calcRdx(min, max);\n  var step = (max * hival - min * hival) / ((length - 1) * hival);\n  var current = min;\n  var cnt;\n\n  // Current is assigned using a technique to compensate for IEEE error.\n  // TODO: Needs better implementation.\n  for (cnt = 0;\n       current <= max && cnt < length;\n       cnt++, current = (min * hival + step * hival * cnt) / hival) {\n    arr.push((func ? func(current, cnt) : current));\n  }\n\n  return arr;\n};\n\n\n// arange(5) -> [0,1,2,3,4]\n// arange(1,5) -> [1,2,3,4]\n// arange(5,1,-1) -> [5,4,3,2]\njStat.arange = function arange(start, end, step) {\n  var rl = [];\n  var i;\n  step = step || 1;\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  if (start === end || step === 0) {\n    return [];\n  }\n  if (start < end && step < 0) {\n    return [];\n  }\n  if (start > end && step > 0) {\n    return [];\n  }\n  if (step > 0) {\n    for (i = start; i < end; i += step) {\n      rl.push(i);\n    }\n  } else {\n    for (i = start; i > end; i += step) {\n      rl.push(i);\n    }\n  }\n  return rl;\n};\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// slice(A,{row:{end:2},col:{start:1}}) -> [[2,3],[5,6]]\n// slice(A,1,{start:1}) -> [5,6]\n// as numpy code A[:2,1:]\njStat.slice = (function(){\n  function _slice(list, start, end, step) {\n    // note it's not equal to range.map mode it's a bug\n    var i;\n    var rl = [];\n    var length = list.length;\n    if (start === undefined && end === undefined && step === undefined) {\n      return jStat.copy(list);\n    }\n\n    start = start || 0;\n    end = end || list.length;\n    start = start >= 0 ? start : length + start;\n    end = end >= 0 ? end : length + end;\n    step = step || 1;\n    if (start === end || step === 0) {\n      return [];\n    }\n    if (start < end && step < 0) {\n      return [];\n    }\n    if (start > end && step > 0) {\n      return [];\n    }\n    if (step > 0) {\n      for (i = start; i < end; i += step) {\n        rl.push(list[i]);\n      }\n    } else {\n      for (i = start; i > end;i += step) {\n        rl.push(list[i]);\n      }\n    }\n    return rl;\n  }\n\n  function slice(list, rcSlice) {\n    var colSlice, rowSlice;\n    rcSlice = rcSlice || {};\n    if (isNumber(rcSlice.row)) {\n      if (isNumber(rcSlice.col))\n        return list[rcSlice.row][rcSlice.col];\n      var row = jStat.rowa(list, rcSlice.row);\n      colSlice = rcSlice.col || {};\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    }\n\n    if (isNumber(rcSlice.col)) {\n      var col = jStat.cola(list, rcSlice.col);\n      rowSlice = rcSlice.row || {};\n      return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);\n    }\n\n    rowSlice = rcSlice.row || {};\n    colSlice = rcSlice.col || {};\n    var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);\n    return rows.map(function(row) {\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    });\n  }\n\n  return slice;\n}());\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// sliceAssign(A,{row:{start:1},col:{start:1}},[[0,0],[0,0]])\n// A=[[1,2,3],[4,0,0],[7,0,0]]\njStat.sliceAssign = function sliceAssign(A, rcSlice, B) {\n  var nl, ml;\n  if (isNumber(rcSlice.row)) {\n    if (isNumber(rcSlice.col))\n      return A[rcSlice.row][rcSlice.col] = B;\n    rcSlice.col = rcSlice.col || {};\n    rcSlice.col.start = rcSlice.col.start || 0;\n    rcSlice.col.end = rcSlice.col.end || A[0].length;\n    rcSlice.col.step = rcSlice.col.step || 1;\n    nl = jStat.arange(rcSlice.col.start,\n                          Math.min(A.length, rcSlice.col.end),\n                          rcSlice.col.step);\n    var m = rcSlice.row;\n    nl.forEach(function(n, i) {\n      A[m][n] = B[i];\n    });\n    return A;\n  }\n\n  if (isNumber(rcSlice.col)) {\n    rcSlice.row = rcSlice.row || {};\n    rcSlice.row.start = rcSlice.row.start || 0;\n    rcSlice.row.end = rcSlice.row.end || A.length;\n    rcSlice.row.step = rcSlice.row.step || 1;\n    ml = jStat.arange(rcSlice.row.start,\n                          Math.min(A[0].length, rcSlice.row.end),\n                          rcSlice.row.step);\n    var n = rcSlice.col;\n    ml.forEach(function(m, j) {\n      A[m][n] = B[j];\n    });\n    return A;\n  }\n\n  if (B[0].length === undefined) {\n    B = [B];\n  }\n  rcSlice.row.start = rcSlice.row.start || 0;\n  rcSlice.row.end = rcSlice.row.end || A.length;\n  rcSlice.row.step = rcSlice.row.step || 1;\n  rcSlice.col.start = rcSlice.col.start || 0;\n  rcSlice.col.end = rcSlice.col.end || A[0].length;\n  rcSlice.col.step = rcSlice.col.step || 1;\n  ml = jStat.arange(rcSlice.row.start,\n                        Math.min(A.length, rcSlice.row.end),\n                        rcSlice.row.step);\n  nl = jStat.arange(rcSlice.col.start,\n                        Math.min(A[0].length, rcSlice.col.end),\n                        rcSlice.col.step);\n  ml.forEach(function(m, i) {\n    nl.forEach(function(n, j) {\n      A[m][n] = B[i][j];\n    });\n  });\n  return A;\n};\n\n\n// [1,2,3] ->\n// [[1,0,0],[0,2,0],[0,0,3]]\njStat.diagonal = function diagonal(diagArray) {\n  var mat = jStat.zeros(diagArray.length, diagArray.length);\n  diagArray.forEach(function(t, i) {\n    mat[i][i] = t;\n  });\n  return mat;\n};\n\n\n// return copy of A\njStat.copy = function copy(A) {\n  return A.map(function(row) {\n    if (isNumber(row))\n      return row;\n    return row.map(function(t) {\n      return t;\n    });\n  });\n};\n\n\n// TODO: Go over this entire implementation. Seems a tragic waste of resources\n// doing all this work. Instead, and while ugly, use new Function() to generate\n// a custom function for each static method.\n\n// Quick reference.\nvar jProto = jStat.prototype;\n\n// Default length.\njProto.length = 0;\n\n// For internal use only.\n// TODO: Check if they're actually used, and if they are then rename them\n// to _*\njProto.push = Array.prototype.push;\njProto.sort = Array.prototype.sort;\njProto.splice = Array.prototype.splice;\njProto.slice = Array.prototype.slice;\n\n\n// Return a clean array.\njProto.toArray = function toArray() {\n  return this.length > 1 ? slice.call(this) : slice.call(this)[0];\n};\n\n\n// Map a function to a matrix or vector.\njProto.map = function map(func, toAlter) {\n  return jStat(jStat.map(this, func, toAlter));\n};\n\n\n// Cumulatively combine the elements of a matrix or vector using a function.\njProto.cumreduce = function cumreduce(func, toAlter) {\n  return jStat(jStat.cumreduce(this, func, toAlter));\n};\n\n\n// Destructively alter an array.\njProto.alter = function alter(func) {\n  jStat.alter(this, func);\n  return this;\n};\n\n\n// Extend prototype with methods that have no argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(func) {\n      var self = this,\n      results;\n      // Check for callback.\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self));\n        });\n        return this;\n      }\n      results = jStat[passfunc](this);\n      return isArray(results) ? jStat(results) : results;\n    };\n  })(funcs[i]);\n})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));\n\n\n// Extend prototype with methods that have one argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(index, func) {\n      var self = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self, index));\n        });\n        return this;\n      }\n      return jStat(jStat[passfunc](this, index));\n    };\n  })(funcs[i]);\n})('row col'.split(' '));\n\n\n// Extend prototype with simple shortcut methods.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function() {\n      return jStat(jStat[passfunc].apply(null, arguments));\n    };\n  })(funcs[i]);\n})('create zeros ones rand identity'.split(' '));\n\n\n// Exposing jStat.\nreturn jStat;\n\n}(Math));\n(function(jStat, Math) {\n\nvar isFunction = jStat.utils.isFunction;\n\n// Ascending functions for sort\nfunction ascNum(a, b) { return a - b; }\n\nfunction clip(arg, min, max) {\n  return Math.max(min, Math.min(arg, max));\n}\n\n\n// sum of an array\njStat.sum = function sum(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n\n// sum squared\njStat.sumsqrd = function sumsqrd(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i] * arr[i];\n  return sum;\n};\n\n\n// sum of squared errors of prediction (SSE)\njStat.sumsqerr = function sumsqerr(arr) {\n  var mean = jStat.mean(arr);\n  var sum = 0;\n  var i = arr.length;\n  var tmp;\n  while (--i >= 0) {\n    tmp = arr[i] - mean;\n    sum += tmp * tmp;\n  }\n  return sum;\n};\n\n// sum of an array in each row\njStat.sumrow = function sumrow(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n// product of an array\njStat.product = function product(arr) {\n  var prod = 1;\n  var i = arr.length;\n  while (--i >= 0)\n    prod *= arr[i];\n  return prod;\n};\n\n\n// minimum value of an array\njStat.min = function min(arr) {\n  var low = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] < low)\n      low = arr[i];\n  return low;\n};\n\n\n// maximum value of an array\njStat.max = function max(arr) {\n  var high = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] > high)\n      high = arr[i];\n  return high;\n};\n\n\n// unique values of an array\njStat.unique = function unique(arr) {\n  var hash = {}, _arr = [];\n  for(var i = 0; i < arr.length; i++) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      _arr.push(arr[i]);\n    }\n  }\n  return _arr;\n};\n\n\n// mean value of an array\njStat.mean = function mean(arr) {\n  return jStat.sum(arr) / arr.length;\n};\n\n\n// mean squared error (MSE)\njStat.meansqerr = function meansqerr(arr) {\n  return jStat.sumsqerr(arr) / arr.length;\n};\n\n\n// geometric mean of an array\njStat.geomean = function geomean(arr) {\n  var logs = arr.map(Math.log)\n  var meanOfLogs = jStat.mean(logs)\n  return Math.exp(meanOfLogs)\n};\n\n\n// median of an array\njStat.median = function median(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  // check if array is even or odd, then return the appropriate\n  return !(arrlen & 1)\n    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2\n    : _arr[(arrlen / 2) | 0 ];\n};\n\n\n// cumulative sum of an array\njStat.cumsum = function cumsum(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a + b; });\n};\n\n\n// cumulative product of an array\njStat.cumprod = function cumprod(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a * b; });\n};\n\n\n// successive differences of a sequence\njStat.diff = function diff(arr) {\n  var diffs = [];\n  var arrLen = arr.length;\n  var i;\n  for (i = 1; i < arrLen; i++)\n    diffs.push(arr[i] - arr[i - 1]);\n  return diffs;\n};\n\n\n// ranks of an array\njStat.rank = function (arr) {\n  var i;\n  var distinctNumbers = [];\n  var numberCounts = {};\n  for (i = 0; i < arr.length; i++) {\n    var number = arr[i];\n    if (numberCounts[number]) {\n      numberCounts[number]++;\n    } else {\n      numberCounts[number] = 1;\n      distinctNumbers.push(number);\n    }\n  }\n\n  var sortedDistinctNumbers = distinctNumbers.sort(ascNum);\n  var numberRanks = {};\n  var currentRank = 1;\n  for (i = 0; i < sortedDistinctNumbers.length; i++) {\n    var number = sortedDistinctNumbers[i];\n    var count = numberCounts[number];\n    var first = currentRank;\n    var last = currentRank + count - 1;\n    var rank = (first + last) / 2;\n    numberRanks[number] = rank;\n    currentRank += count;\n  }\n\n  return arr.map(function (number) {\n    return numberRanks[number];\n  });\n};\n\n\n// mode of an array\n// if there are multiple modes of an array, return all of them\n// is this the appropriate way of handling it?\njStat.mode = function mode(arr) {\n  var arrLen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  var count = 1;\n  var maxCount = 0;\n  var numMaxCount = 0;\n  var mode_arr = [];\n  var i;\n\n  for (i = 0; i < arrLen; i++) {\n    if (_arr[i] === _arr[i + 1]) {\n      count++;\n    } else {\n      if (count > maxCount) {\n        mode_arr = [_arr[i]];\n        maxCount = count;\n        numMaxCount = 0;\n      }\n      // are there multiple max counts\n      else if (count === maxCount) {\n        mode_arr.push(_arr[i]);\n        numMaxCount++;\n      }\n      // resetting count for new value in array\n      count = 1;\n    }\n  }\n\n  return numMaxCount === 0 ? mode_arr[0] : mode_arr;\n};\n\n\n// range of an array\njStat.range = function range(arr) {\n  return jStat.max(arr) - jStat.min(arr);\n};\n\n// variance of an array\n// flag = true indicates sample instead of population\njStat.variance = function variance(arr, flag) {\n  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));\n};\n\n// pooled variance of an array of arrays\njStat.pooledvariance = function pooledvariance(arr) {\n  var sumsqerr = arr.reduce(function (a, samples) {return a + jStat.sumsqerr(samples);}, 0);\n  var count = arr.reduce(function (a, samples) {return a + samples.length;}, 0);\n  return sumsqerr / (count - arr.length);\n};\n\n// deviation of an array\njStat.deviation = function (arr) {\n  var mean = jStat.mean(arr);\n  var arrlen = arr.length;\n  var dev = new Array(arrlen);\n  for (var i = 0; i < arrlen; i++) {\n    dev[i] = arr[i] - mean;\n  }\n  return dev;\n};\n\n// standard deviation of an array\n// flag = true indicates sample instead of population\njStat.stdev = function stdev(arr, flag) {\n  return Math.sqrt(jStat.variance(arr, flag));\n};\n\n// pooled standard deviation of an array of arrays\njStat.pooledstdev = function pooledstdev(arr) {\n  return Math.sqrt(jStat.pooledvariance(arr));\n};\n\n// mean deviation (mean absolute deviation) of an array\njStat.meandev = function meandev(arr) {\n  var mean = jStat.mean(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - mean));\n  }\n  return jStat.mean(a);\n};\n\n\n// median deviation (median absolute deviation) of an array\njStat.meddev = function meddev(arr) {\n  var median = jStat.median(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - median));\n  }\n  return jStat.median(a);\n};\n\n\n// coefficient of variation\njStat.coeffvar = function coeffvar(arr) {\n  return jStat.stdev(arr) / jStat.mean(arr);\n};\n\n\n// quartiles of an array\njStat.quartiles = function quartiles(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  return [\n    _arr[ Math.round((arrlen) / 4) - 1 ],\n    _arr[ Math.round((arrlen) / 2) - 1 ],\n    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]\n  ];\n};\n\n\n// Arbitary quantiles of an array. Direct port of the scipy.stats\n// implementation by Pierre GF Gerard-Marchant.\njStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {\n  var sortedArray = arr.slice().sort(ascNum);\n  var quantileVals = [quantilesArray.length];\n  var n = arr.length;\n  var i, p, m, aleph, k, gamma;\n\n  if (typeof alphap === 'undefined')\n    alphap = 3 / 8;\n  if (typeof betap === 'undefined')\n    betap = 3 / 8;\n\n  for (i = 0; i < quantilesArray.length; i++) {\n    p = quantilesArray[i];\n    m = alphap + p * (1 - alphap - betap);\n    aleph = n * p + m;\n    k = Math.floor(clip(aleph, 1, n - 1));\n    gamma = clip(aleph - k, 0, 1);\n    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];\n  }\n\n  return quantileVals;\n};\n\n// Return the k-th percentile of values in a range, where k is in the range 0..1, inclusive.\n// Passing true for the exclusive parameter excludes both endpoints of the range.\njStat.percentile = function percentile(arr, k, exclusive) {\n  var _arr = arr.slice().sort(ascNum);\n  var realIndex = k * (_arr.length + (exclusive ? 1 : -1)) + (exclusive ? 0 : 1);\n  var index = parseInt(realIndex);\n  var frac = realIndex - index;\n  if (index + 1 < _arr.length) {\n    return _arr[index - 1] + frac * (_arr[index] - _arr[index - 1]);\n  } else {\n    return _arr[index - 1];\n  }\n}\n\n// The percentile rank of score in a given array. Returns the percentage\n// of all values in the input array that are less than (kind='strict') or\n// less or equal than (kind='weak') score. Default is weak.\njStat.percentileOfScore = function percentileOfScore(arr, score, kind) {\n  var counter = 0;\n  var len = arr.length;\n  var strict = false;\n  var value, i;\n\n  if (kind === 'strict')\n    strict = true;\n\n  for (i = 0; i < len; i++) {\n    value = arr[i];\n    if ((strict && value < score) ||\n        (!strict && value <= score)) {\n      counter++;\n    }\n  }\n\n  return counter / len;\n};\n\n\n// Histogram (bin count) data\njStat.histogram = function histogram(arr, binCnt) {\n  binCnt = binCnt || 4;\n  var first = jStat.min(arr);\n  var binWidth = (jStat.max(arr) - first) / binCnt;\n  var len = arr.length;\n  var bins = [];\n  var i;\n\n  for (i = 0; i < binCnt; i++)\n    bins[i] = 0;\n  for (i = 0; i < len; i++)\n    bins[Math.min(Math.floor(((arr[i] - first) / binWidth)), binCnt - 1)] += 1;\n\n  return bins;\n};\n\n\n// covariance of two arrays\njStat.covariance = function covariance(arr1, arr2) {\n  var u = jStat.mean(arr1);\n  var v = jStat.mean(arr2);\n  var arr1Len = arr1.length;\n  var sq_dev = new Array(arr1Len);\n  var i;\n\n  for (i = 0; i < arr1Len; i++)\n    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);\n\n  return jStat.sum(sq_dev) / (arr1Len - 1);\n};\n\n\n// (pearson's) population correlation coefficient, rho\njStat.corrcoeff = function corrcoeff(arr1, arr2) {\n  return jStat.covariance(arr1, arr2) /\n      jStat.stdev(arr1, 1) /\n      jStat.stdev(arr2, 1);\n};\n\n  // (spearman's) rank correlation coefficient, sp\njStat.spearmancoeff =  function (arr1, arr2) {\n  arr1 = jStat.rank(arr1);\n  arr2 = jStat.rank(arr2);\n  //return pearson's correlation of the ranks:\n  return jStat.corrcoeff(arr1, arr2);\n}\n\n\n// statistical standardized moments (general form of skew/kurt)\njStat.stanMoment = function stanMoment(arr, n) {\n  var mu = jStat.mean(arr);\n  var sigma = jStat.stdev(arr);\n  var len = arr.length;\n  var skewSum = 0;\n\n  for (var i = 0; i < len; i++)\n    skewSum += Math.pow((arr[i] - mu) / sigma, n);\n\n  return skewSum / arr.length;\n};\n\n// (pearson's) moment coefficient of skewness\njStat.skewness = function skewness(arr) {\n  return jStat.stanMoment(arr, 3);\n};\n\n// (pearson's) (excess) kurtosis\njStat.kurtosis = function kurtosis(arr) {\n  return jStat.stanMoment(arr, 4) - 3;\n};\n\n\nvar jProto = jStat.prototype;\n\n\n// Extend jProto with method for calculating cumulative sums and products.\n// This differs from the similar extension below as cumsum and cumprod should\n// not be run again in the case fullbool === true.\n// If a matrix is passed, automatically assume operation should be done on the\n// columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('cumsum cumprod').split(' '));\n\n\n// Extend jProto with methods which don't require arguments and work on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        if (passfunc !== 'sumrow')\n          tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return fullbool === true\n            ? jStat[passfunc](jStat.utils.toVector(arr))\n            : arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr ' +\n    'geomean median diff rank mode range variance deviation stdev meandev ' +\n    'meddev coeffvar quartiles histogram skewness kurtosis').split(' '));\n\n\n// Extend jProto with functions that take arguments. Operations on matrices are\n// done on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function() {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      var args = Array.prototype.slice.call(arguments);\n      var callbackFunction;\n\n      // If the last argument is a function, we assume it's a callback; we\n      // strip the callback out and call the function again.\n      if (isFunction(args[args.length - 1])) {\n        callbackFunction = args[args.length - 1];\n        var argsToPass = args.slice(0, args.length - 1);\n\n        setTimeout(function() {\n          callbackFunction.call(tmpthis,\n                                jProto[passfunc].apply(tmpthis, argsToPass));\n        });\n        return this;\n\n      // Otherwise we curry the function args and call normally.\n      } else {\n        callbackFunction = undefined;\n        var curriedFunction = function curriedFunction(vector) {\n          return jStat[passfunc].apply(tmpthis, [vector].concat(args));\n        }\n      }\n\n      // If this is a matrix, run column-by-column.\n      if (this.length > 1) {\n        tmpthis = tmpthis.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = curriedFunction(tmpthis[i]);\n        return arr;\n      }\n\n      // Otherwise run on the vector.\n      return curriedFunction(this[0]);\n    };\n  })(funcs[i]);\n})('quantiles percentileOfScore'.split(' '));\n\n}(jStat, Math));\n// Special functions //\n(function(jStat, Math) {\n\n// Log-gamma function\njStat.gammaln = function gammaln(x) {\n  var j = 0;\n  var cof = [\n    76.18009172947146, -86.50532032941677, 24.01409824083091,\n    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5\n  ];\n  var ser = 1.000000000190015;\n  var xx, y, tmp;\n  tmp = (y = xx = x) + 5.5;\n  tmp -= (xx + 0.5) * Math.log(tmp);\n  for (; j < 6; j++)\n    ser += cof[j] / ++y;\n  return Math.log(2.5066282746310005 * ser / xx) - tmp;\n};\n\n/*\n * log-gamma function to support poisson distribution sampling. The\n * algorithm comes from SPECFUN by Shanjie Zhang and Jianming Jin and their\n * book \"Computation of Special Functions\", 1996, John Wiley & Sons, Inc.\n */\njStat.loggam = function loggam(x) {\n  var x0, x2, xp, gl, gl0;\n  var k, n;\n\n  var a = [8.333333333333333e-02, -2.777777777777778e-03,\n          7.936507936507937e-04, -5.952380952380952e-04,\n          8.417508417508418e-04, -1.917526917526918e-03,\n          6.410256410256410e-03, -2.955065359477124e-02,\n          1.796443723688307e-01, -1.39243221690590e+00];\n  x0 = x;\n  n = 0;\n  if ((x == 1.0) || (x == 2.0)) {\n      return 0.0;\n  }\n  if (x <= 7.0) {\n      n = Math.floor(7 - x);\n      x0 = x + n;\n  }\n  x2 = 1.0 / (x0 * x0);\n  xp = 2 * Math.PI;\n  gl0 = a[9];\n  for (k = 8; k >= 0; k--) {\n      gl0 *= x2;\n      gl0 += a[k];\n  }\n  gl = gl0 / x0 + 0.5 * Math.log(xp) + (x0 - 0.5) * Math.log(x0) - x0;\n  if (x <= 7.0) {\n      for (k = 1; k <= n; k++) {\n          gl -= Math.log(x0 - 1.0);\n          x0 -= 1.0;\n      }\n  }\n  return gl;\n}\n\n// gamma of x\njStat.gammafn = function gammafn(x) {\n  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,\n           629.3311553128184, 866.9662027904133, -31451.272968848367,\n           -36144.413418691176, 66456.14382024054\n  ];\n  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,\n           -3107.771671572311, 22538.118420980151, 4755.8462775278811,\n           -134659.9598649693, -115132.2596755535];\n  var fact = false;\n  var n = 0;\n  var xden = 0;\n  var xnum = 0;\n  var y = x;\n  var i, z, yi, res;\n  if (x > 171.6243769536076) {\n    return Infinity;\n  }\n  if (y <= 0) {\n    res = y % 1 + 3.6e-16;\n    if (res) {\n      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);\n      y = 1 - y;\n    } else {\n      return Infinity;\n    }\n  }\n  yi = y;\n  if (y < 1) {\n    z = y++;\n  } else {\n    z = (y -= n = (y | 0) - 1) - 1;\n  }\n  for (i = 0; i < 8; ++i) {\n    xnum = (xnum + p[i]) * z;\n    xden = xden * z + q[i];\n  }\n  res = xnum / xden + 1;\n  if (yi < y) {\n    res /= yi;\n  } else if (yi > y) {\n    for (i = 0; i < n; ++i) {\n      res *= y;\n      y++;\n    }\n  }\n  if (fact) {\n    res = fact / res;\n  }\n  return res;\n};\n\n\n// lower incomplete gamma function, which is usually typeset with a\n// lower-case greek gamma as the function symbol\njStat.gammap = function gammap(a, x) {\n  return jStat.lowRegGamma(a, x) * jStat.gammafn(a);\n};\n\n\n// The lower regularized incomplete gamma function, usually written P(a,x)\njStat.lowRegGamma = function lowRegGamma(a, x) {\n  var aln = jStat.gammaln(a);\n  var ap = a;\n  var sum = 1 / a;\n  var del = sum;\n  var b = x + 1 - a;\n  var c = 1 / 1.0e-30;\n  var d = 1 / b;\n  var h = d;\n  var i = 1;\n  // calculate maximum number of itterations required for a\n  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);\n  var an;\n\n  if (x < 0 || a <= 0) {\n    return NaN;\n  } else if (x < a + 1) {\n    for (; i <= ITMAX; i++) {\n      sum += del *= x / ++ap;\n    }\n    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));\n  }\n\n  for (; i <= ITMAX; i++) {\n    an = -i * (i - a);\n    b += 2;\n    d = an * d + b;\n    c = b + an / c;\n    d = 1 / d;\n    h *= d * c;\n  }\n\n  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));\n};\n\n// natural log factorial of n\njStat.factorialln = function factorialln(n) {\n  return n < 0 ? NaN : jStat.gammaln(n + 1);\n};\n\n// factorial of n\njStat.factorial = function factorial(n) {\n  return n < 0 ? NaN : jStat.gammafn(n + 1);\n};\n\n// combinations of n, m\njStat.combination = function combination(n, m) {\n  // make sure n or m don't exceed the upper limit of usable values\n  return (n > 170 || m > 170)\n      ? Math.exp(jStat.combinationln(n, m))\n      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);\n};\n\n\njStat.combinationln = function combinationln(n, m){\n  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);\n};\n\n\n// permutations of n, m\njStat.permutation = function permutation(n, m) {\n  return jStat.factorial(n) / jStat.factorial(n - m);\n};\n\n\n// beta function\njStat.betafn = function betafn(x, y) {\n  // ensure arguments are positive\n  if (x <= 0 || y <= 0)\n    return undefined;\n  // make sure x + y doesn't exceed the upper limit of usable values\n  return (x + y > 170)\n      ? Math.exp(jStat.betaln(x, y))\n      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);\n};\n\n\n// natural logarithm of beta function\njStat.betaln = function betaln(x, y) {\n  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);\n};\n\n\n// Evaluates the continued fraction for incomplete beta function by modified\n// Lentz's method.\njStat.betacf = function betacf(x, a, b) {\n  var fpmin = 1e-30;\n  var m = 1;\n  var qab = a + b;\n  var qap = a + 1;\n  var qam = a - 1;\n  var c = 1;\n  var d = 1 - qab * x / qap;\n  var m2, aa, del, h;\n\n  // These q's will be used in factors that occur in the coefficients\n  if (Math.abs(d) < fpmin)\n    d = fpmin;\n  d = 1 / d;\n  h = d;\n\n  for (; m <= 100; m++) {\n    m2 = 2 * m;\n    aa = m * (b - m) * x / ((qam + m2) * (a + m2));\n    // One step (the even one) of the recurrence\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    h *= d * c;\n    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\n    // Next step of the recurrence (the odd one)\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    del = d * c;\n    h *= del;\n    if (Math.abs(del - 1.0) < 3e-7)\n      break;\n  }\n\n  return h;\n};\n\n\n// Returns the inverse of the lower regularized inomplete gamma function\njStat.gammapinv = function gammapinv(p, a) {\n  var j = 0;\n  var a1 = a - 1;\n  var EPS = 1e-8;\n  var gln = jStat.gammaln(a);\n  var x, err, t, u, pp, lna1, afac;\n\n  if (p >= 1)\n    return Math.max(100, a + 100 * Math.sqrt(a));\n  if (p <= 0)\n    return 0;\n  if (a > 1) {\n    lna1 = Math.log(a1);\n    afac = Math.exp(a1 * (lna1 - 1) - gln);\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    x = Math.max(1e-3,\n                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));\n  } else {\n    t = 1 - a * (0.253 + a * 0.12);\n    if (p < t)\n      x = Math.pow(p / t, 1 / a);\n    else\n      x = 1 - Math.log(1 - (p - t) / (1 - t));\n  }\n\n  for(; j < 12; j++) {\n    if (x <= 0)\n      return 0;\n    err = jStat.lowRegGamma(a, x) - p;\n    if (a > 1)\n      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));\n    else\n      t = Math.exp(-x + a1 * Math.log(x) - gln);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (Math.abs(t) < EPS * x)\n      break;\n  }\n\n  return x;\n};\n\n\n// Returns the error function erf(x)\njStat.erf = function erf(x) {\n  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,\n             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,\n             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,\n             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,\n             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,\n             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,\n             -6.886027e-12, 8.94487e-13, 3.13092e-13,\n             -1.12708e-13, 3.81e-16, 7.106e-15,\n             -1.523e-15, -9.4e-17, 1.21e-16,\n             -2.8e-17];\n  var j = cof.length - 1;\n  var isneg = false;\n  var d = 0;\n  var dd = 0;\n  var t, ty, tmp, res;\n\n  if (x < 0) {\n    x = -x;\n    isneg = true;\n  }\n\n  t = 2 / (2 + x);\n  ty = 4 * t - 2;\n\n  for(; j > 0; j--) {\n    tmp = d;\n    d = ty * d - dd + cof[j];\n    dd = tmp;\n  }\n\n  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);\n  return isneg ? res - 1 : 1 - res;\n};\n\n\n// Returns the complmentary error function erfc(x)\njStat.erfc = function erfc(x) {\n  return 1 - jStat.erf(x);\n};\n\n\n// Returns the inverse of the complementary error function\njStat.erfcinv = function erfcinv(p) {\n  var j = 0;\n  var x, err, t, pp;\n  if (p >= 2)\n    return -100;\n  if (p <= 0)\n    return 100;\n  pp = (p < 1) ? p : 2 - p;\n  t = Math.sqrt(-2 * Math.log(pp / 2));\n  x = -0.70711 * ((2.30753 + t * 0.27061) /\n                  (1 + t * (0.99229 + t * 0.04481)) - t);\n  for (; j < 2; j++) {\n    err = jStat.erfc(x) - pp;\n    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);\n  }\n  return (p < 1) ? x : -x;\n};\n\n\n// Returns the inverse of the incomplete beta function\njStat.ibetainv = function ibetainv(p, a, b) {\n  var EPS = 1e-8;\n  var a1 = a - 1;\n  var b1 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u, err, x, al, h, w, afac;\n  if (p <= 0)\n    return 0;\n  if (p >= 1)\n    return 1;\n  if (a >= 1 && b >= 1) {\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    al = (x * x - 3) / 6;\n    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));\n    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *\n        (al + 5 / 6 - 2 / (3 * h));\n    x = a / (a + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a / (a + b));\n    lnb = Math.log(b / (a + b));\n    t = Math.exp(a * lna) / a;\n    u = Math.exp(b * lnb) / b;\n    w = t + u;\n    if (p < t / w)\n      x = Math.pow(a * w * p, 1 / a);\n    else\n      x = 1 - Math.pow(b * w * (1 - p), 1 / b);\n  }\n  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);\n  for(; j < 10; j++) {\n    if (x === 0 || x === 1)\n      return x;\n    err = jStat.ibeta(x, a, b) - p;\n    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (x >= 1)\n      x = 0.5 * (x + t + 1);\n    if (Math.abs(t) < EPS * x && j > 0)\n      break;\n  }\n  return x;\n};\n\n\n// Returns the incomplete beta function I_x(a,b)\njStat.ibeta = function ibeta(x, a, b) {\n  // Factors in front of the continued fraction.\n  var bt = (x === 0 || x === 1) ?  0 :\n    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -\n             jStat.gammaln(b) + a * Math.log(x) + b *\n             Math.log(1 - x));\n  if (x < 0 || x > 1)\n    return false;\n  if (x < (a + 1) / (a + b + 2))\n    // Use continued fraction directly.\n    return bt * jStat.betacf(x, a, b) / a;\n  // else use continued fraction after making the symmetry transformation.\n  return 1 - bt * jStat.betacf(1 - x, b, a) / b;\n};\n\n\n// Returns a normal deviate (mu=0, sigma=1).\n// If n and m are specified it returns a object of normal deviates.\njStat.randn = function randn(n, m) {\n  var u, v, x, y, q;\n  if (!m)\n    m = n;\n  if (n)\n    return jStat.create(n, m, function() { return jStat.randn(); });\n  do {\n    u = jStat._random_fn();\n    v = 1.7156 * (jStat._random_fn() - 0.5);\n    x = u - 0.449871;\n    y = Math.abs(v) + 0.386595;\n    q = x * x + y * (0.19600 * y - 0.25472 * x);\n  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));\n  return v / u;\n};\n\n\n// Returns a gamma deviate by the method of Marsaglia and Tsang.\njStat.randg = function randg(shape, n, m) {\n  var oalph = shape;\n  var a1, a2, u, v, x, mat;\n  if (!m)\n    m = n;\n  if (!shape)\n    shape = 1;\n  if (n) {\n    mat = jStat.zeros(n,m);\n    mat.alter(function() { return jStat.randg(shape); });\n    return mat;\n  }\n  if (shape < 1)\n    shape += 1;\n  a1 = shape - 1 / 3;\n  a2 = 1 / Math.sqrt(9 * a1);\n  do {\n    do {\n      x = jStat.randn();\n      v = 1 + a2 * x;\n    } while(v <= 0);\n    v = v * v * v;\n    u = jStat._random_fn();\n  } while(u > 1 - 0.331 * Math.pow(x, 4) &&\n          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));\n  // alpha > 1\n  if (shape == oalph)\n    return a1 * v;\n  // alpha < 1\n  do {\n    u = jStat._random_fn();\n  } while(u === 0);\n  return Math.pow(u, 1 / oalph) * a1 * v;\n};\n\n\n// making use of static methods on the instance\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(\n          jStat.map(this, function(value) { return jStat[passfunc](value); }));\n    }\n  })(funcs[i]);\n})('gammaln gammafn factorial factorialln'.split(' '));\n\n\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(jStat[passfunc].apply(null, arguments));\n    };\n  })(funcs[i]);\n})('randn'.split(' '));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\n// generate all distribution instance methods\n(function(list) {\n  for (var i = 0; i < list.length; i++) (function(func) {\n    // distribution instance method\n    jStat[func] = function f(a, b, c) {\n      if (!(this instanceof f))\n        return new f(a, b, c);\n      this._a = a;\n      this._b = b;\n      this._c = c;\n      return this;\n    };\n    // distribution method to be used on a jStat instance\n    jStat.fn[func] = function(a, b, c) {\n      var newthis = jStat[func](a, b, c);\n      newthis.data = this;\n      return newthis;\n    };\n    // sample instance method\n    jStat[func].prototype.sample = function(arr) {\n      var a = this._a;\n      var b = this._b;\n      var c = this._c;\n      if (arr)\n        return jStat.alter(arr, function() {\n          return jStat[func].sample(a, b, c);\n        });\n      else\n        return jStat[func].sample(a, b, c);\n    };\n    // generate the pdf, cdf and inv instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function(x) {\n          var a = this._a;\n          var b = this._b;\n          var c = this._c;\n          if (!x && x !== 0)\n            x = this.data;\n          if (typeof x !== 'number') {\n            return jStat.fn.map.call(x, function(x) {\n              return jStat[func][fnfunc](x, a, b, c);\n            });\n          }\n          return jStat[func][fnfunc](x, a, b, c);\n        };\n      })(vals[i]);\n    })('pdf cdf inv'.split(' '));\n    // generate the mean, median, mode and variance instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function() {\n          return jStat[func][fnfunc](this._a, this._b, this._c);\n        };\n      })(vals[i]);\n    })('mean median mode variance'.split(' '));\n  })(list[i]);\n})((\n  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +\n  'laplace lognormal noncentralt normal pareto studentt weibull uniform ' +\n  'binomial negbin hypgeom poisson triangular tukey arcsine'\n).split(' '));\n\n\n\n// extend beta function with static methods\njStat.extend(jStat.beta, {\n  pdf: function pdf(x, alpha, beta) {\n    // PDF is zero outside the support\n    if (x > 1 || x < 0)\n      return 0;\n    // PDF is one for the uniform case\n    if (alpha == 1 && beta == 1)\n      return 1;\n\n    if (alpha < 512 && beta < 512) {\n      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /\n          jStat.betafn(alpha, beta);\n    } else {\n      return Math.exp((alpha - 1) * Math.log(x) +\n                      (beta - 1) * Math.log(1 - x) -\n                      jStat.betaln(alpha, beta));\n    }\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);\n  },\n\n  inv: function inv(x, alpha, beta) {\n    return jStat.ibetainv(x, alpha, beta);\n  },\n\n  mean: function mean(alpha, beta) {\n    return alpha / (alpha + beta);\n  },\n\n  median: function median(alpha, beta) {\n    return jStat.ibetainv(0.5, alpha, beta);\n  },\n\n  mode: function mode(alpha, beta) {\n    return (alpha - 1 ) / ( alpha + beta - 2);\n  },\n\n  // return a random sample\n  sample: function sample(alpha, beta) {\n    var u = jStat.randg(alpha);\n    return u / (u + jStat.randg(beta));\n  },\n\n  variance: function variance(alpha, beta) {\n    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));\n  }\n});\n\n// extend F function with static methods\njStat.extend(jStat.centralF, {\n  // This implementation of the pdf function avoids float overflow\n  // See the way that R calculates this value:\n  // https://svn.r-project.org/R/trunk/src/nmath/df.c\n  pdf: function pdf(x, df1, df2) {\n    var p, q, f;\n\n    if (x < 0)\n      return 0;\n\n    if (df1 <= 2) {\n      if (x === 0 && df1 < 2) {\n        return Infinity;\n      }\n      if (x === 0 && df1 === 2) {\n        return 1;\n      }\n      return (1 / jStat.betafn(df1 / 2, df2 / 2)) *\n              Math.pow(df1 / df2, df1 / 2) *\n              Math.pow(x, (df1/2) - 1) *\n              Math.pow((1 + (df1 / df2) * x), -(df1 + df2) / 2);\n    }\n\n    p = (df1 * x) / (df2 + x * df1);\n    q = df2 / (df2 + x * df1);\n    f = df1 * q / 2.0;\n    return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);\n  },\n\n  cdf: function cdf(x, df1, df2) {\n    if (x < 0)\n      return 0;\n    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);\n  },\n\n  inv: function inv(x, df1, df2) {\n    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));\n  },\n\n  mean: function mean(df1, df2) {\n    return (df2 > 2) ? df2 / (df2 - 2) : undefined;\n  },\n\n  mode: function mode(df1, df2) {\n    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;\n  },\n\n  // return a random sample\n  sample: function sample(df1, df2) {\n    var x1 = jStat.randg(df1 / 2) * 2;\n    var x2 = jStat.randg(df2 / 2) * 2;\n    return (x1 / df1) / (x2 / df2);\n  },\n\n  variance: function variance(df1, df2) {\n    if (df2 <= 4)\n      return undefined;\n    return 2 * df2 * df2 * (df1 + df2 - 2) /\n        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));\n  }\n});\n\n\n// extend cauchy function with static methods\njStat.extend(jStat.cauchy, {\n  pdf: function pdf(x, local, scale) {\n    if (scale < 0) { return 0; }\n\n    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;\n  },\n\n  cdf: function cdf(x, local, scale) {\n    return Math.atan((x - local) / scale) / Math.PI + 0.5;\n  },\n\n  inv: function(p, local, scale) {\n    return local + scale * Math.tan(Math.PI * (p - 0.5));\n  },\n\n  median: function median(local/*, scale*/) {\n    return local;\n  },\n\n  mode: function mode(local/*, scale*/) {\n    return local;\n  },\n\n  sample: function sample(local, scale) {\n    return jStat.randn() *\n        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;\n  }\n});\n\n\n\n// extend chisquare function with static methods\njStat.extend(jStat.chisquare, {\n  pdf: function pdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && dof === 2) ? 0.5 :\n        Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *\n                 Math.log(2) - jStat.gammaln(dof / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(dof / 2, x / 2);\n  },\n\n  inv: function(p, dof) {\n    return 2 * jStat.gammapinv(p, 0.5 * dof);\n  },\n\n  mean : function(dof) {\n    return dof;\n  },\n\n  // TODO: this is an approximation (is there a better way?)\n  median: function median(dof) {\n    return dof * Math.pow(1 - (2 / (9 * dof)), 3);\n  },\n\n  mode: function mode(dof) {\n    return (dof - 2 > 0) ? dof - 2 : 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randg(dof / 2) * 2;\n  },\n\n  variance: function variance(dof) {\n    return 2 * dof;\n  }\n});\n\n\n\n// extend exponential function with static methods\njStat.extend(jStat.exponential, {\n  pdf: function pdf(x, rate) {\n    return x < 0 ? 0 : rate * Math.exp(-rate * x);\n  },\n\n  cdf: function cdf(x, rate) {\n    return x < 0 ? 0 : 1 - Math.exp(-rate * x);\n  },\n\n  inv: function(p, rate) {\n    return -Math.log(1 - p) / rate;\n  },\n\n  mean : function(rate) {\n    return 1 / rate;\n  },\n\n  median: function (rate) {\n    return (1 / rate) * Math.log(2);\n  },\n\n  mode: function mode(/*rate*/) {\n    return 0;\n  },\n\n  sample: function sample(rate) {\n    return -1 / rate * Math.log(jStat._random_fn());\n  },\n\n  variance : function(rate) {\n    return Math.pow(rate, -2);\n  }\n});\n\n\n\n// extend gamma function with static methods\njStat.extend(jStat.gamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && shape === 1) ? 1 / scale :\n            Math.exp((shape - 1) * Math.log(x) - x / scale -\n                    jStat.gammaln(shape) - shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(shape, x / scale);\n  },\n\n  inv: function(p, shape, scale) {\n    return jStat.gammapinv(p, shape) * scale;\n  },\n\n  mean : function(shape, scale) {\n    return shape * scale;\n  },\n\n  mode: function mode(shape, scale) {\n    if(shape > 1) return (shape - 1) * scale;\n    return undefined;\n  },\n\n  sample: function sample(shape, scale) {\n    return jStat.randg(shape) * scale;\n  },\n\n  variance: function variance(shape, scale) {\n    return shape * scale * scale;\n  }\n});\n\n// extend inverse gamma function with static methods\njStat.extend(jStat.invgamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -\n                    jStat.gammaln(shape) + shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return 1 - jStat.lowRegGamma(shape, scale / x);\n  },\n\n  inv: function(p, shape, scale) {\n    return scale / jStat.gammapinv(1 - p, shape);\n  },\n\n  mean : function(shape, scale) {\n    return (shape > 1) ? scale / (shape - 1) : undefined;\n  },\n\n  mode: function mode(shape, scale) {\n    return scale / (shape + 1);\n  },\n\n  sample: function sample(shape, scale) {\n    return scale / jStat.randg(shape);\n  },\n\n  variance: function variance(shape, scale) {\n    if (shape <= 2)\n      return undefined;\n    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));\n  }\n});\n\n\n// extend kumaraswamy function with static methods\njStat.extend(jStat.kumaraswamy, {\n  pdf: function pdf(x, alpha, beta) {\n    if (x === 0 && alpha === 1)\n      return beta;\n    else if (x === 1 && beta === 1)\n      return alpha;\n    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *\n                    Math.log(x) + (beta - 1) *\n                    Math.log(1 - Math.pow(x, alpha)));\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    if (x < 0)\n      return 0;\n    else if (x > 1)\n      return 1;\n    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));\n  },\n\n  inv: function inv(p, alpha, beta) {\n    return Math.pow(1 - Math.pow(1 - p, 1 / beta), 1 / alpha);\n  },\n\n  mean : function(alpha, beta) {\n    return (beta * jStat.gammafn(1 + 1 / alpha) *\n            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));\n  },\n\n  median: function median(alpha, beta) {\n    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);\n  },\n\n  mode: function mode(alpha, beta) {\n    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))\n      return undefined;\n    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);\n  },\n\n  variance: function variance(/*alpha, beta*/) {\n    throw new Error('variance not yet implemented');\n    // TODO: complete this\n  }\n});\n\n\n\n// extend lognormal function with static methods\njStat.extend(jStat.lognormal, {\n  pdf: function pdf(x, mu, sigma) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -\n                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /\n                    (2 * sigma * sigma));\n  },\n\n  cdf: function cdf(x, mu, sigma) {\n    if (x < 0)\n      return 0;\n    return 0.5 +\n        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));\n  },\n\n  inv: function(p, mu, sigma) {\n    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);\n  },\n\n  mean: function mean(mu, sigma) {\n    return Math.exp(mu + sigma * sigma / 2);\n  },\n\n  median: function median(mu/*, sigma*/) {\n    return Math.exp(mu);\n  },\n\n  mode: function mode(mu, sigma) {\n    return Math.exp(mu - sigma * sigma);\n  },\n\n  sample: function sample(mu, sigma) {\n    return Math.exp(jStat.randn() * sigma + mu);\n  },\n\n  variance: function variance(mu, sigma) {\n    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);\n  }\n});\n\n\n\n// extend noncentralt function with static methods\njStat.extend(jStat.noncentralt, {\n  pdf: function pdf(x, dof, ncp) {\n    var tol = 1e-14;\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.pdf(x, dof)\n\n    if (Math.abs(x) < tol) {  // different formula for x == 0\n      return Math.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 -\n                      0.5 * Math.log(Math.PI * dof) - jStat.gammaln(dof / 2));\n    }\n\n    // formula for x != 0\n    return dof / x *\n        (jStat.noncentralt.cdf(x * Math.sqrt(1 + 2 / dof), dof+2, ncp) -\n         jStat.noncentralt.cdf(x, dof, ncp));\n  },\n\n  cdf: function cdf(x, dof, ncp) {\n    var tol = 1e-14;\n    var min_iterations = 200;\n\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.cdf(x, dof);\n\n    // turn negative x into positive and flip result afterwards\n    var flip = false;\n    if (x < 0) {\n      flip = true;\n      ncp = -ncp;\n    }\n\n    var prob = jStat.normal.cdf(-ncp, 0, 1);\n    var value = tol + 1;\n    // use value at last two steps to determine convergence\n    var lastvalue = value;\n    var y = x * x / (x * x + dof);\n    var j = 0;\n    var p = Math.exp(-ncp * ncp / 2);\n    var q = Math.exp(-ncp * ncp / 2 - 0.5 * Math.log(2) -\n                     jStat.gammaln(3 / 2)) * ncp;\n    while (j < min_iterations || lastvalue > tol || value > tol) {\n      lastvalue = value;\n      if (j > 0) {\n        p *= (ncp * ncp) / (2 * j);\n        q *= (ncp * ncp) / (2 * (j + 1 / 2));\n      }\n      value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) +\n          q * jStat.beta.cdf(y, j+1, dof/2);\n      prob += 0.5 * value;\n      j++;\n    }\n\n    return flip ? (1 - prob) : prob;\n  }\n});\n\n\n// extend normal function with static methods\njStat.extend(jStat.normal, {\n  pdf: function pdf(x, mean, std) {\n    return Math.exp(-0.5 * Math.log(2 * Math.PI) -\n                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));\n  },\n\n  cdf: function cdf(x, mean, std) {\n    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));\n  },\n\n  inv: function(p, mean, std) {\n    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;\n  },\n\n  mean : function(mean/*, std*/) {\n    return mean;\n  },\n\n  median: function median(mean/*, std*/) {\n    return mean;\n  },\n\n  mode: function (mean/*, std*/) {\n    return mean;\n  },\n\n  sample: function sample(mean, std) {\n    return jStat.randn() * std + mean;\n  },\n\n  variance : function(mean, std) {\n    return std * std;\n  }\n});\n\n\n\n// extend pareto function with static methods\njStat.extend(jStat.pareto, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return 1 - Math.pow(scale / x, shape);\n  },\n\n  inv: function inv(p, scale, shape) {\n    return scale / Math.pow(1 - p, 1 / shape);\n  },\n\n  mean: function mean(scale, shape) {\n    if (shape <= 1)\n      return undefined;\n    return (shape * Math.pow(scale, shape)) / (shape - 1);\n  },\n\n  median: function median(scale, shape) {\n    return scale * (shape * Math.SQRT2);\n  },\n\n  mode: function mode(scale/*, shape*/) {\n    return scale;\n  },\n\n  variance : function(scale, shape) {\n    if (shape <= 2)\n      return undefined;\n    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));\n  }\n});\n\n\n\n// extend studentt function with static methods\njStat.extend(jStat.studentt, {\n  pdf: function pdf(x, dof) {\n    dof = dof > 1e100 ? 1e100 : dof;\n    return (1/(Math.sqrt(dof) * jStat.betafn(0.5, dof/2))) *\n        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    var dof2 = dof / 2;\n    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /\n                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);\n  },\n\n  inv: function(p, dof) {\n    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n    x = Math.sqrt(dof * (1 - x) / x);\n    return (p > 0.5) ? x : -x;\n  },\n\n  mean: function mean(dof) {\n    return (dof > 1) ? 0 : undefined;\n  },\n\n  median: function median(/*dof*/) {\n    return 0;\n  },\n\n  mode: function mode(/*dof*/) {\n    return 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));\n  },\n\n  variance: function variance(dof) {\n    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;\n  }\n});\n\n\n\n// extend weibull function with static methods\njStat.extend(jStat.weibull, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < 0 || scale < 0 || shape < 0)\n      return 0;\n    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *\n        Math.exp(-(Math.pow((x / scale), shape)));\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));\n  },\n\n  inv: function(p, scale, shape) {\n    return scale * Math.pow(-Math.log(1 - p), 1 / shape);\n  },\n\n  mean : function(scale, shape) {\n    return scale * jStat.gammafn(1 + 1 / shape);\n  },\n\n  median: function median(scale, shape) {\n    return scale * Math.pow(Math.log(2), 1 / shape);\n  },\n\n  mode: function mode(scale, shape) {\n    if (shape <= 1)\n      return 0;\n    return scale * Math.pow((shape - 1) / shape, 1 / shape);\n  },\n\n  sample: function sample(scale, shape) {\n    return scale * Math.pow(-Math.log(jStat._random_fn()), 1 / shape);\n  },\n\n  variance: function variance(scale, shape) {\n    return scale * scale * jStat.gammafn(1 + 2 / shape) -\n        Math.pow(jStat.weibull.mean(scale, shape), 2);\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.uniform, {\n  pdf: function pdf(x, a, b) {\n    return (x < a || x > b) ? 0 : 1 / (b - a);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (x - a) / (b - a);\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (p * (b - a));\n  },\n\n  mean: function mean(a, b) {\n    return 0.5 * (a + b);\n  },\n\n  median: function median(a, b) {\n    return jStat.mean(a, b);\n  },\n\n  mode: function mode(/*a, b*/) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * jStat._random_fn() - 1);\n  },\n\n  variance: function variance(a, b) {\n    return Math.pow(b - a, 2) / 12;\n  }\n});\n\n\n// Got this from http://www.math.ucla.edu/~tom/distributions/binomial.html\nfunction betinc(x, a, b, eps) {\n  var a0 = 0;\n  var b0 = 1;\n  var a1 = 1;\n  var b1 = 1;\n  var m9 = 0;\n  var a2 = 0;\n  var c9;\n\n  while (Math.abs((a1 - a2) / a1) > eps) {\n    a2 = a1;\n    c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);\n    a0 = a1 + c9 * a0;\n    b0 = b1 + c9 * b0;\n    m9 = m9 + 1;\n    c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);\n    a1 = a0 + c9 * a1;\n    b1 = b0 + c9 * b1;\n    a0 = a0 / b1;\n    b0 = b0 / b1;\n    a1 = a1 / b1;\n    b1 = 1;\n  }\n\n  return a1 / a;\n}\n\n\n// extend uniform function with static methods\njStat.extend(jStat.binomial, {\n  pdf: function pdf(k, n, p) {\n    return (p === 0 || p === 1) ?\n      ((n * p) === k ? 1 : 0) :\n      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);\n  },\n\n  cdf: function cdf(x, n, p) {\n    var betacdf;\n    var eps = 1e-10;\n\n    if (x < 0)\n      return 0;\n    if (x >= n)\n      return 1;\n    if (p < 0 || p > 1 || n <= 0)\n      return NaN;\n\n    x = Math.floor(x);\n    var z = p;\n    var a = x + 1;\n    var b = n - x;\n    var s = a + b;\n    var bt = Math.exp(jStat.gammaln(s) - jStat.gammaln(b) -\n                      jStat.gammaln(a) + a * Math.log(z) + b * Math.log(1 - z));\n\n    if (z < (a + 1) / (s + 2))\n      betacdf = bt * betinc(z, a, b, eps);\n    else\n      betacdf = 1 - bt * betinc(1 - z, b, a, eps);\n\n    return Math.round((1 - betacdf) * (1 / eps)) / (1 / eps);\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.negbin, {\n  pdf: function pdf(k, r, p) {\n    if (k !== k >>> 0)\n      return false;\n    if (k < 0)\n      return 0;\n    return jStat.combination(k + r - 1, r - 1) *\n        Math.pow(1 - p, k) * Math.pow(p, r);\n  },\n\n  cdf: function cdf(x, r, p) {\n    var sum = 0,\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sum += jStat.negbin.pdf(k, r, p);\n    }\n    return sum;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.hypgeom, {\n  pdf: function pdf(k, N, m, n) {\n    // Hypergeometric PDF.\n\n    // A simplification of the CDF algorithm below.\n\n    // k = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(k !== k | 0) {\n      return false;\n    } else if(k < 0 || k < m - (N - n)) {\n      // It's impossible to have this few successes drawn.\n      return 0;\n    } else if(k > n || k > m) {\n      // It's impossible to have this many successes drawn.\n      return 0;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return jStat.hypgeom.pdf(n - k, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return jStat.hypgeom.pdf(m - k, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.pdf(k, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate product to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < k; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledPDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          scaledPDF *= 1 - (m / (N - samplesDone));\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledPDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledPDF));\n    }\n  },\n\n  cdf: function cdf(x, N, m, n) {\n    // Hypergeometric CDF.\n\n    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,\n    // and comes from his hypergeometric test calculator at\n    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.\n\n    // x = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(x < 0 || x < m - (N - n)) {\n      // It's impossible to have this few successes drawn or fewer.\n      return 0;\n    } else if(x >= n || x >= m) {\n      // We will always have this many successes or fewer.\n      return 1;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.cdf(x, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate sum to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // Holds the intermediate, scaled total CDF.\n      var scaledCDF = 1;\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < x; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledCDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          var factor = 1 - (m / (N - samplesDone));\n\n          scaledPDF *= factor;\n          scaledCDF *= factor;\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n\n        // Add to the CDF answer.\n        scaledCDF += scaledPDF;\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledCDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledCDF));\n    }\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.poisson, {\n  pdf: function pdf(k, l) {\n    if (l < 0 || (k % 1) !== 0 || k < 0) {\n      return 0;\n    }\n\n    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);\n  },\n\n  cdf: function cdf(x, l) {\n    var sumarr = [],\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sumarr.push(jStat.poisson.pdf(k, l));\n    }\n    return jStat.sum(sumarr);\n  },\n\n  mean : function(l) {\n    return l;\n  },\n\n  variance : function(l) {\n    return l;\n  },\n\n  sampleSmall: function sampleSmall(l) {\n    var p = 1, k = 0, L = Math.exp(-l);\n    do {\n      k++;\n      p *= jStat._random_fn();\n    } while (p > L);\n    return k - 1;\n  },\n\n  sampleLarge: function sampleLarge(l) {\n    var lam = l;\n    var k;\n    var U, V, slam, loglam, a, b, invalpha, vr, us;\n\n    slam = Math.sqrt(lam);\n    loglam = Math.log(lam);\n    b = 0.931 + 2.53 * slam;\n    a = -0.059 + 0.02483 * b;\n    invalpha = 1.1239 + 1.1328 / (b - 3.4);\n    vr = 0.9277 - 3.6224 / (b - 2);\n\n    while (1) {\n      U = Math.random() - 0.5;\n      V = Math.random();\n      us = 0.5 - Math.abs(U);\n      k = Math.floor((2 * a / us + b) * U + lam + 0.43);\n      if ((us >= 0.07) && (V <= vr)) {\n          return k;\n      }\n      if ((k < 0) || ((us < 0.013) && (V > us))) {\n          continue;\n      }\n      /* log(V) == log(0.0) ok here */\n      /* if U==0.0 so that us==0.0, log is ok since always returns */\n      if ((Math.log(V) + Math.log(invalpha) - Math.log(a / (us * us) + b)) <= (-lam + k * loglam - jStat.loggam(k + 1))) {\n          return k;\n      }\n    }\n  },\n\n  sample: function sample(l) {\n    if (l < 10)\n      return this.sampleSmall(l);\n    else\n      return this.sampleLarge(l);\n  }\n});\n\n// extend triangular function with static methods\njStat.extend(jStat.triangular, {\n  pdf: function pdf(x, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (x < a || x > b) {\n        return 0;\n      } else if (x < c) {\n          return (2 * (x - a)) / ((b - a) * (c - a));\n      } else if (x === c) {\n          return (2 / (b - a));\n      } else { // x > c\n          return (2 * (b - x)) / ((b - a) * (b - c));\n      }\n    }\n  },\n\n  cdf: function cdf(x, a, b, c) {\n    if (b <= a || c < a || c > b)\n      return NaN;\n    if (x <= a)\n      return 0;\n    else if (x >= b)\n      return 1;\n    if (x <= c)\n      return Math.pow(x - a, 2) / ((b - a) * (c - a));\n    else // x > c\n      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));\n  },\n\n  inv: function inv(p, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (p <= ((c - a) / (b - a))) {\n        return a + (b - a) * Math.sqrt(p * ((c - a) / (b - a)));\n      } else { // p > ((c - a) / (b - a))\n        return a + (b - a) * (1 - Math.sqrt((1 - p) * (1 - ((c - a) / (b - a)))));\n      }\n    }\n  },\n\n  mean: function mean(a, b, c) {\n    return (a + b + c) / 3;\n  },\n\n  median: function median(a, b, c) {\n    if (c <= (a + b) / 2) {\n      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);\n    } else if (c > (a + b) / 2) {\n      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);\n    }\n  },\n\n  mode: function mode(a, b, c) {\n    return c;\n  },\n\n  sample: function sample(a, b, c) {\n    var u = jStat._random_fn();\n    if (u < ((c - a) / (b - a)))\n      return a + Math.sqrt(u * (b - a) * (c - a))\n    return b - Math.sqrt((1 - u) * (b - a) * (b - c));\n  },\n\n  variance: function variance(a, b, c) {\n    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;\n  }\n});\n\n\n// extend arcsine function with static methods\njStat.extend(jStat.arcsine, {\n  pdf: function pdf(x, a, b) {\n    if (b <= a) return NaN;\n\n    return (x <= a || x >= b) ? 0 :\n      (2 / Math.PI) *\n        Math.pow(Math.pow(b - a, 2) -\n                  Math.pow(2 * x - a - b, 2), -0.5);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (2 / Math.PI) * Math.asin(Math.sqrt((x - a)/(b - a)));\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (0.5 - 0.5 * Math.cos(Math.PI * p)) * (b - a);\n  },\n\n  mean: function mean(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  median: function median(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  mode: function mode(/*a, b*/) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return ((a + b) / 2) + ((b - a) / 2) *\n      Math.sin(2 * Math.PI * jStat.uniform.sample(0, 1));\n  },\n\n  variance: function variance(a, b) {\n    if (b <= a) return NaN;\n    return Math.pow(b - a, 2) / 8;\n  }\n});\n\n\nfunction laplaceSign(x) { return x / Math.abs(x); }\n\njStat.extend(jStat.laplace, {\n  pdf: function pdf(x, mu, b) {\n    return (b <= 0) ? 0 : (Math.exp(-Math.abs(x - mu) / b)) / (2 * b);\n  },\n\n  cdf: function cdf(x, mu, b) {\n    if (b <= 0) { return 0; }\n\n    if(x < mu) {\n      return 0.5 * Math.exp((x - mu) / b);\n    } else {\n      return 1 - 0.5 * Math.exp(- (x - mu) / b);\n    }\n  },\n\n  mean: function(mu/*, b*/) {\n    return mu;\n  },\n\n  median: function(mu/*, b*/) {\n    return mu;\n  },\n\n  mode: function(mu/*, b*/) {\n    return mu;\n  },\n\n  variance: function(mu, b) {\n    return 2 * b * b;\n  },\n\n  sample: function sample(mu, b) {\n    var u = jStat._random_fn() - 0.5;\n\n    return mu - (b * laplaceSign(u) * Math.log(1 - (2 * Math.abs(u))));\n  }\n});\n\nfunction tukeyWprob(w, rr, cc) {\n  var nleg = 12;\n  var ihalf = 6;\n\n  var C1 = -30;\n  var C2 = -50;\n  var C3 = 60;\n  var bb   = 8;\n  var wlar = 3;\n  var wincr1 = 2;\n  var wincr2 = 3;\n  var xleg = [\n    0.981560634246719250690549090149,\n    0.904117256370474856678465866119,\n    0.769902674194304687036893833213,\n    0.587317954286617447296702418941,\n    0.367831498998180193752691536644,\n    0.125233408511468915472441369464\n  ];\n  var aleg = [\n    0.047175336386511827194615961485,\n    0.106939325995318430960254718194,\n    0.160078328543346226334652529543,\n    0.203167426723065921749064455810,\n    0.233492536538354808760849898925,\n    0.249147045813402785000562436043\n  ];\n\n  var qsqz = w * 0.5;\n\n  // if w >= 16 then the integral lower bound (occurs for c=20)\n  // is 0.99999999999995 so return a value of 1.\n\n  if (qsqz >= bb)\n    return 1.0;\n\n  // find (f(w/2) - 1) ^ cc\n  // (first term in integral of hartley's form).\n\n  var pr_w = 2 * jStat.normal.cdf(qsqz, 0, 1, 1, 0) - 1; // erf(qsqz / M_SQRT2)\n  // if pr_w ^ cc < 2e-22 then set pr_w = 0\n  if (pr_w >= Math.exp(C2 / cc))\n    pr_w = Math.pow(pr_w, cc);\n  else\n    pr_w = 0.0;\n\n  // if w is large then the second component of the\n  // integral is small, so fewer intervals are needed.\n\n  var wincr;\n  if (w > wlar)\n    wincr = wincr1;\n  else\n    wincr = wincr2;\n\n  // find the integral of second term of hartley's form\n  // for the integral of the range for equal-length\n  // intervals using legendre quadrature.  limits of\n  // integration are from (w/2, 8).  two or three\n  // equal-length intervals are used.\n\n  // blb and bub are lower and upper limits of integration.\n\n  var blb = qsqz;\n  var binc = (bb - qsqz) / wincr;\n  var bub = blb + binc;\n  var einsum = 0.0;\n\n  // integrate over each interval\n\n  var cc1 = cc - 1.0;\n  for (var wi = 1; wi <= wincr; wi++) {\n    var elsum = 0.0;\n    var a = 0.5 * (bub + blb);\n\n    // legendre quadrature with order = nleg\n\n    var b = 0.5 * (bub - blb);\n\n    for (var jj = 1; jj <= nleg; jj++) {\n      var j, xx;\n      if (ihalf < jj) {\n        j = (nleg - jj) + 1;\n        xx = xleg[j-1];\n      } else {\n        j = jj;\n        xx = -xleg[j-1];\n      }\n      var c = b * xx;\n      var ac = a + c;\n\n      // if exp(-qexpo/2) < 9e-14,\n      // then doesn't contribute to integral\n\n      var qexpo = ac * ac;\n      if (qexpo > C3)\n        break;\n\n      var pplus = 2 * jStat.normal.cdf(ac, 0, 1, 1, 0);\n      var pminus= 2 * jStat.normal.cdf(ac, w, 1, 1, 0);\n\n      // if rinsum ^ (cc-1) < 9e-14,\n      // then doesn't contribute to integral\n\n      var rinsum = (pplus * 0.5) - (pminus * 0.5);\n      if (rinsum >= Math.exp(C1 / cc1)) {\n        rinsum = (aleg[j-1] * Math.exp(-(0.5 * qexpo))) * Math.pow(rinsum, cc1);\n        elsum += rinsum;\n      }\n    }\n    elsum *= (((2.0 * b) * cc) / Math.sqrt(2 * Math.PI));\n    einsum += elsum;\n    blb = bub;\n    bub += binc;\n  }\n\n  // if pr_w ^ rr < 9e-14, then return 0\n  pr_w += einsum;\n  if (pr_w <= Math.exp(C1 / rr))\n    return 0;\n\n  pr_w = Math.pow(pr_w, rr);\n  if (pr_w >= 1) // 1 was iMax was eps\n    return 1;\n  return pr_w;\n}\n\nfunction tukeyQinv(p, c, v) {\n  var p0 = 0.322232421088;\n  var q0 = 0.993484626060e-01;\n  var p1 = -1.0;\n  var q1 = 0.588581570495;\n  var p2 = -0.342242088547;\n  var q2 = 0.531103462366;\n  var p3 = -0.204231210125;\n  var q3 = 0.103537752850;\n  var p4 = -0.453642210148e-04;\n  var q4 = 0.38560700634e-02;\n  var c1 = 0.8832;\n  var c2 = 0.2368;\n  var c3 = 1.214;\n  var c4 = 1.208;\n  var c5 = 1.4142;\n  var vmax = 120.0;\n\n  var ps = 0.5 - 0.5 * p;\n  var yi = Math.sqrt(Math.log(1.0 / (ps * ps)));\n  var t = yi + (((( yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0)\n     / (((( yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);\n  if (v < vmax) t += (t * t * t + t) / v / 4.0;\n  var q = c1 - c2 * t;\n  if (v < vmax) q += -c3 / v + c4 * t / v;\n  return t * (q * Math.log(c - 1.0) + c5);\n}\n\njStat.extend(jStat.tukey, {\n  cdf: function cdf(q, nmeans, df) {\n    // Identical implementation as the R ptukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var nlegq = 16;\n    var ihalfq = 8;\n\n    var eps1 = -30.0;\n    var eps2 = 1.0e-14;\n    var dhaf  = 100.0;\n    var dquar = 800.0;\n    var deigh = 5000.0;\n    var dlarg = 25000.0;\n    var ulen1 = 1.0;\n    var ulen2 = 0.5;\n    var ulen3 = 0.25;\n    var ulen4 = 0.125;\n    var xlegq = [\n      0.989400934991649932596154173450,\n      0.944575023073232576077988415535,\n      0.865631202387831743880467897712,\n      0.755404408355003033895101194847,\n      0.617876244402643748446671764049,\n      0.458016777657227386342419442984,\n      0.281603550779258913230460501460,\n      0.950125098376374401853193354250e-1\n    ];\n    var alegq = [\n      0.271524594117540948517805724560e-1,\n      0.622535239386478928628438369944e-1,\n      0.951585116824927848099251076022e-1,\n      0.124628971255533872052476282192,\n      0.149595988816576732081501730547,\n      0.169156519395002538189312079030,\n      0.182603415044923588866763667969,\n      0.189450610455068496285396723208\n    ];\n\n    if (q <= 0)\n      return 0;\n\n    // df must be > 1\n    // there must be at least two values\n\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (!Number.isFinite(q))\n      return 1;\n\n    if (df > dlarg)\n      return tukeyWprob(q, rr, cc);\n\n    // calculate leading constant\n\n    var f2 = df * 0.5;\n    var f2lf = ((f2 * Math.log(df)) - (df * Math.log(2))) - jStat.gammaln(f2);\n    var f21 = f2 - 1.0;\n\n    // integral is divided into unit, half-unit, quarter-unit, or\n    // eighth-unit length intervals depending on the value of the\n    // degrees of freedom.\n\n    var ff4 = df * 0.25;\n    var ulen;\n    if      (df <= dhaf)  ulen = ulen1;\n    else if (df <= dquar) ulen = ulen2;\n    else if (df <= deigh) ulen = ulen3;\n    else                  ulen = ulen4;\n\n    f2lf += Math.log(ulen);\n\n    // integrate over each subinterval\n\n    var ans = 0.0;\n\n    for (var i = 1; i <= 50; i++) {\n      var otsum = 0.0;\n\n      // legendre quadrature with order = nlegq\n      // nodes (stored in xlegq) are symmetric around zero.\n\n      var twa1 = (2 * i - 1) * ulen;\n\n      for (var jj = 1; jj <= nlegq; jj++) {\n        var j, t1;\n        if (ihalfq < jj) {\n          j = jj - ihalfq - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 + (xlegq[j] * ulen))))\n              - (((xlegq[j] * ulen) + twa1) * ff4);\n        } else {\n          j = jj - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 - (xlegq[j] * ulen))))\n              + (((xlegq[j] * ulen) - twa1) * ff4);\n        }\n\n        // if exp(t1) < 9e-14, then doesn't contribute to integral\n        var qsqz;\n        if (t1 >= eps1) {\n          if (ihalfq < jj) {\n            qsqz = q * Math.sqrt(((xlegq[j] * ulen) + twa1) * 0.5);\n          } else {\n            qsqz = q * Math.sqrt(((-(xlegq[j] * ulen)) + twa1) * 0.5);\n          }\n\n          // call wprob to find integral of range portion\n\n          var wprb = tukeyWprob(qsqz, rr, cc);\n          var rotsum = (wprb * alegq[j]) * Math.exp(t1);\n          otsum += rotsum;\n        }\n        // end legendre integral for interval i\n        // L200:\n      }\n\n      // if integral for interval i < 1e-14, then stop.\n      // However, in order to avoid small area under left tail,\n      // at least  1 / ulen  intervals are calculated.\n      if (i * ulen >= 1.0 && otsum <= eps2)\n        break;\n\n      // end of interval i\n      // L330:\n\n      ans += otsum;\n    }\n\n    if (otsum > eps2) { // not converged\n      throw new Error('tukey.cdf failed to converge');\n    }\n    if (ans > 1)\n      ans = 1;\n    return ans;\n  },\n\n  inv: function(p, nmeans, df) {\n    // Identical implementation as the R qtukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var eps = 0.0001;\n    var maxiter = 50;\n\n    // df must be > 1 ; there must be at least two values\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (p < 0 || p > 1) return NaN;\n    if (p === 0) return 0;\n    if (p === 1) return Infinity;\n\n    // Initial value\n\n    var x0 = tukeyQinv(p, cc, df);\n\n    // Find prob(value < x0)\n\n    var valx0 = jStat.tukey.cdf(x0, nmeans, df) - p;\n\n    // Find the second iterate and prob(value < x1).\n    // If the first iterate has probability value\n    // exceeding p then second iterate is 1 less than\n    // first iterate; otherwise it is 1 greater.\n\n    var x1;\n    if (valx0 > 0.0)\n      x1 = Math.max(0.0, x0 - 1.0);\n    else\n      x1 = x0 + 1.0;\n    var valx1 = jStat.tukey.cdf(x1, nmeans, df) - p;\n\n    // Find new iterate\n\n    var ans;\n    for(var iter = 1; iter < maxiter; iter++) {\n      ans = x1 - ((valx1 * (x1 - x0)) / (valx1 - valx0));\n      valx0 = valx1;\n\n      // New iterate must be >= 0\n\n      x0 = x1;\n      if (ans < 0.0) {\n        ans = 0.0;\n        valx1 = -p;\n      }\n      // Find prob(value < new iterate)\n\n      valx1 = jStat.tukey.cdf(ans, nmeans, df) - p;\n      x1 = ans;\n\n      // If the difference between two successive\n      // iterates is less than eps, stop\n\n      var xabs = Math.abs(x1 - x0);\n      if (xabs < eps)\n        return ans;\n    }\n\n    throw new Error('tukey.inv failed to converge');\n  }\n});\n\n}(jStat, Math));\n/* Provides functions for the solution of linear system of equations, integration, extrapolation,\n * interpolation, eigenvalue problems, differential equations and PCA analysis. */\n\n(function(jStat, Math) {\n\nvar push = Array.prototype.push;\nvar isArray = jStat.utils.isArray;\n\nfunction isUsable(arg) {\n  return isArray(arg) || arg instanceof jStat;\n}\n\njStat.extend({\n\n  // add a vector/matrix to a vector/matrix or scalar\n  add: function add(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value + arg[row][col];\n      });\n    }\n    return jStat.map(arr, function(value) { return value + arg; });\n  },\n\n  // subtract a vector or scalar from the vector\n  subtract: function subtract(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value - arg[row][col] || 0;\n      });\n    }\n    return jStat.map(arr, function(value) { return value - arg; });\n  },\n\n  // matrix division\n  divide: function divide(arr, arg) {\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.multiply(arr, jStat.inv(arg));\n    }\n    return jStat.map(arr, function(value) { return value / arg; });\n  },\n\n  // matrix multiplication\n  multiply: function multiply(arr, arg) {\n    var row, col, nrescols, sum, nrow, ncol, res, rescols;\n    // eg: arr = 2 arg = 3 -> 6 for res[0][0] statement closure\n    if (arr.length === undefined && arg.length === undefined) {\n      return arr * arg;\n    }\n    nrow = arr.length,\n    ncol = arr[0].length,\n    res = jStat.zeros(nrow, nrescols = (isUsable(arg)) ? arg[0].length : ncol),\n    rescols = 0;\n    if (isUsable(arg)) {\n      for (; rescols < nrescols; rescols++) {\n        for (row = 0; row < nrow; row++) {\n          sum = 0;\n          for (col = 0; col < ncol; col++)\n          sum += arr[row][col] * arg[col][rescols];\n          res[row][rescols] = sum;\n        }\n      }\n      return (nrow === 1 && rescols === 1) ? res[0][0] : res;\n    }\n    return jStat.map(arr, function(value) { return value * arg; });\n  },\n\n  // outer([1,2,3],[4,5,6])\n  // ===\n  // [[1],[2],[3]] times [[4,5,6]]\n  // ->\n  // [[4,5,6],[8,10,12],[12,15,18]]\n  outer:function outer(A, B) {\n    return jStat.multiply(A.map(function(t){ return [t] }), [B]);\n  },\n\n\n  // Returns the dot product of two matricies\n  dot: function dot(arr, arg) {\n    if (!isUsable(arr[0])) arr = [ arr ];\n    if (!isUsable(arg[0])) arg = [ arg ];\n    // convert column to row vector\n    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,\n    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,\n    res = [],\n    row = 0,\n    nrow = left.length,\n    ncol = left[0].length,\n    sum, col;\n    for (; row < nrow; row++) {\n      res[row] = [];\n      sum = 0;\n      for (col = 0; col < ncol; col++)\n      sum += left[row][col] * right[row][col];\n      res[row] = sum;\n    }\n    return (res.length === 1) ? res[0] : res;\n  },\n\n  // raise every element by a scalar\n  pow: function pow(arr, arg) {\n    return jStat.map(arr, function(value) { return Math.pow(value, arg); });\n  },\n\n  // exponentiate every element\n  exp: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.exp(value); });\n  },\n\n  // generate the natural log of every element\n  log: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.log(value); });\n  },\n\n  // generate the absolute values of the vector\n  abs: function abs(arr) {\n    return jStat.map(arr, function(value) { return Math.abs(value); });\n  },\n\n  // computes the p-norm of the vector\n  // In the case that a matrix is passed, uses the first row as the vector\n  norm: function norm(arr, p) {\n    var nnorm = 0,\n    i = 0;\n    // check the p-value of the norm, and set for most common case\n    if (isNaN(p)) p = 2;\n    // check if multi-dimensional array, and make vector correction\n    if (isUsable(arr[0])) arr = arr[0];\n    // vector norm\n    for (; i < arr.length; i++) {\n      nnorm += Math.pow(Math.abs(arr[i]), p);\n    }\n    return Math.pow(nnorm, 1 / p);\n  },\n\n  // computes the angle between two vectors in rads\n  // In case a matrix is passed, this uses the first row as the vector\n  angle: function angle(arr, arg) {\n    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));\n  },\n\n  // augment one matrix by another\n  // Note: this function returns a matrix, not a jStat object\n  aug: function aug(a, b) {\n    var newarr = [];\n    var i;\n    for (i = 0; i < a.length; i++) {\n      newarr.push(a[i].slice());\n    }\n    for (i = 0; i < newarr.length; i++) {\n      push.apply(newarr[i], b[i]);\n    }\n    return newarr;\n  },\n\n  // The inv() function calculates the inverse of a matrix\n  // Create the inverse by augmenting the matrix by the identity matrix of the\n  // appropriate size, and then use G-J elimination on the augmented matrix.\n  inv: function inv(a) {\n    var rows = a.length;\n    var cols = a[0].length;\n    var b = jStat.identity(rows, cols);\n    var c = jStat.gauss_jordan(a, b);\n    var result = [];\n    var i = 0;\n    var j;\n\n    //We need to copy the inverse portion to a new matrix to rid G-J artifacts\n    for (; i < rows; i++) {\n      result[i] = [];\n      for (j = cols; j < c[0].length; j++)\n        result[i][j - cols] = c[i][j];\n    }\n    return result;\n  },\n\n  // calculate the determinant of a matrix\n  det: function det(a) {\n    if (a.length === 2) {\n      return a[0][0] * a[1][1] - a[0][1] * a[1][0];\n    }\n\n    var determinant = 0;\n    for (var i = 0; i < a.length; i++) {\n      // build a sub matrix without column `i`\n      var submatrix = [];\n      for (var row = 1; row < a.length; row++) {\n        submatrix[row - 1] = [];\n        for (var col = 0; col < a.length; col++) {\n          if (col < i) {\n            submatrix[row - 1][col] = a[row][col];\n          } else if (col > i) {\n            submatrix[row - 1][col - 1] = a[row][col];\n          }\n        }\n      }\n\n      // alternate between + and - between determinants\n      var sign = i % 2 ? -1 : 1;\n      determinant += det(submatrix) * a[0][i] * sign;\n    }\n\n    return determinant\n  },\n\n  gauss_elimination: function gauss_elimination(a, b) {\n    var i = 0,\n    j = 0,\n    n = a.length,\n    m = a[0].length,\n    factor = 1,\n    sum = 0,\n    x = [],\n    maug, pivot, temp, k;\n    a = jStat.aug(a, b);\n    maug = a[0].length;\n    for(i = 0; i < n; i++) {\n      pivot = a[i][i];\n      j = i;\n      for (k = i + 1; k < m; k++) {\n        if (pivot < Math.abs(a[k][i])) {\n          pivot = a[k][i];\n          j = k;\n        }\n      }\n      if (j != i) {\n        for(k = 0; k < maug; k++) {\n          temp = a[i][k];\n          a[i][k] = a[j][k];\n          a[j][k] = temp;\n        }\n      }\n      for (j = i + 1; j < n; j++) {\n        factor = a[j][i] / a[i][i];\n        for(k = i; k < maug; k++) {\n          a[j][k] = a[j][k] - factor * a[i][k];\n        }\n      }\n    }\n    for (i = n - 1; i >= 0; i--) {\n      sum = 0;\n      for (j = i + 1; j<= n - 1; j++) {\n        sum = sum + x[j] * a[i][j];\n      }\n      x[i] =(a[i][maug - 1] - sum) / a[i][i];\n    }\n    return x;\n  },\n\n  gauss_jordan: function gauss_jordan(a, b) {\n    var m = jStat.aug(a, b);\n    var h = m.length;\n    var w = m[0].length;\n    var c = 0;\n    var x, y, y2;\n    // find max pivot\n    for (y = 0; y < h; y++) {\n      var maxrow = y;\n      for (y2 = y+1; y2 < h; y2++) {\n        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))\n          maxrow = y2;\n      }\n      var tmp = m[y];\n      m[y] = m[maxrow];\n      m[maxrow] = tmp\n      for (y2 = y+1; y2 < h; y2++) {\n        c = m[y2][y] / m[y][y];\n        for (x = y; x < w; x++) {\n          m[y2][x] -= m[y][x] * c;\n        }\n      }\n    }\n    // backsubstitute\n    for (y = h-1; y >= 0; y--) {\n      c = m[y][y];\n      for (y2 = 0; y2 < y; y2++) {\n        for (x = w-1; x > y-1; x--) {\n          m[y2][x] -= m[y][x] * m[y2][y] / c;\n        }\n      }\n      m[y][y] /= c;\n      for (x = h; x < w; x++) {\n        m[y][x] /= c;\n      }\n    }\n    return m;\n  },\n\n  // solve equation\n  // Ax=b\n  // A is upper triangular matrix\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[1,2,3]\n  // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]\n  // if you use matrix style\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[[1],[2],[3]]\n  // will return [[2.666],[0.1666],[1.666]]\n  triaUpSolve: function triaUpSolve(A, b) {\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n    var matrix_mode = false;\n\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size - 1, -1, -1).forEach(function(i) {\n      parts = jStat.arange(i + 1, size).map(function(j) {\n        return x[j] * A[i][j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    });\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n  triaLowSolve: function triaLowSolve(A, b) {\n    // like to triaUpSolve but A is lower triangular matrix\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n\n    var matrix_mode=false;\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(j) {\n        return A[i][j] * x[j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    })\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n\n  // A -> [L,U]\n  // A=LU\n  // L is lower triangular matrix\n  // U is upper triangular matrix\n  lu: function lu(A) {\n    var size = A.length;\n    //var L=jStat.diagonal(jStat.ones(1,size)[0]);\n    var L = jStat.identity(size);\n    var R = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(t) {\n      R[0][t] = A[0][t];\n    });\n    jStat.arange(1, size).forEach(function(l) {\n      jStat.arange(l).forEach(function(i) {\n        parts = jStat.arange(i).map(function(jj) {\n          return L[l][jj] * R[jj][i];\n        });\n        L[l][i] = (A[l][i] - jStat.sum(parts)) / R[i][i];\n      });\n      jStat.arange(l, size).forEach(function(j) {\n        parts = jStat.arange(l).map(function(jj) {\n          return L[l][jj] * R[jj][j];\n        });\n        R[l][j] = A[parts.length][j] - jStat.sum(parts);\n      });\n    });\n    return [L, R];\n  },\n\n  // A -> T\n  // A=TT'\n  // T is lower triangular matrix\n  cholesky: function cholesky(A) {\n    var size = A.length;\n    var T = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(t) {\n        return Math.pow(T[i][t],2);\n      });\n      T[i][i] = Math.sqrt(A[i][i] - jStat.sum(parts));\n      jStat.arange(i + 1, size).forEach(function(j) {\n        parts = jStat.arange(i).map(function(t) {\n          return T[i][t] * T[j][t];\n        });\n        T[j][i] = (A[i][j] - jStat.sum(parts)) / T[i][i];\n      });\n    });\n    return T;\n  },\n\n\n  gauss_jacobi: function gauss_jacobi(a, b, x, r) {\n    var i = 0;\n    var j = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);\n    c = jStat.multiply(jStat.inv(d), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  gauss_seidel: function gauss_seidel(a, b, x, r) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);\n    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i = i + 1;\n    }\n    return xk;\n  },\n\n  SOR: function SOR(a, b, x, r, w) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),\n                       jStat.subtract(jStat.multiply(d, 1 - w),\n                                      jStat.multiply(u, w)));\n    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,\n        jStat.multiply(l, w))), b), w);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  householder: function householder(a) {\n    var m = a.length;\n    var n = a[0].length;\n    var i = 0;\n    var w = [];\n    var p = [];\n    var alpha, r, k, j, factor;\n    for (; i < m - 1; i++) {\n      alpha = 0;\n      for (j = i + 1; j < n; j++)\n      alpha += (a[j][i] * a[j][i]);\n      factor = (a[i + 1][i] > 0) ? -1 : 1;\n      alpha = factor * Math.sqrt(alpha);\n      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));\n      w = jStat.zeros(m, 1);\n      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);\n      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);\n      p = jStat.subtract(jStat.identity(m, n),\n          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));\n      a = jStat.multiply(p, jStat.multiply(a, p));\n    }\n    return a;\n  },\n\n  // A -> [Q,R]\n  // Q is orthogonal matrix\n  // R is upper triangular\n  QR: (function() {\n    // x -> Q\n    // find a orthogonal matrix Q st.\n    // Qx=y\n    // y is [||x||,0,0,...]\n\n    // quick ref\n    var sum   = jStat.sum;\n    var range = jStat.arange;\n\n    function qr2(x) {\n      // quick impletation\n      // https://www.stat.wisc.edu/~larget/math496/qr.html\n\n      var n = x.length;\n      var p = x[0].length;\n\n      var r = jStat.zeros(p, p);\n      x = jStat.copy(x);\n\n      var i,j,k;\n      for(j = 0; j < p; j++){\n        r[j][j] = Math.sqrt(sum(range(n).map(function(i){\n          return x[i][j] * x[i][j];\n        })));\n        for(i = 0; i < n; i++){\n          x[i][j] = x[i][j] / r[j][j];\n        }\n        for(k = j+1; k < p; k++){\n          r[j][k] = sum(range(n).map(function(i){\n            return x[i][j] * x[i][k];\n          }));\n          for(i = 0; i < n; i++){\n            x[i][k] = x[i][k] - x[i][j]*r[j][k];\n          }\n        }\n      }\n      return [x, r];\n    }\n\n    return qr2;\n  }()),\n\n  lstsq: (function() {\n    // solve least squard problem for Ax=b as QR decomposition way if b is\n    // [[b1],[b2],[b3]] form will return [[x1],[x2],[x3]] array form solution\n    // else b is [b1,b2,b3] form will return [x1,x2,x3] array form solution\n    function R_I(A) {\n      A = jStat.copy(A);\n      var size = A.length;\n      var I = jStat.identity(size);\n      jStat.arange(size - 1, -1, -1).forEach(function(i) {\n        jStat.sliceAssign(\n            I, { row: i }, jStat.divide(jStat.slice(I, { row: i }), A[i][i]));\n        jStat.sliceAssign(\n            A, { row: i }, jStat.divide(jStat.slice(A, { row: i }), A[i][i]));\n        jStat.arange(i).forEach(function(j) {\n          var c = jStat.multiply(A[j][i], -1);\n          var Aj = jStat.slice(A, { row: j });\n          var cAi = jStat.multiply(jStat.slice(A, { row: i }), c);\n          jStat.sliceAssign(A, { row: j }, jStat.add(Aj, cAi));\n          var Ij = jStat.slice(I, { row: j });\n          var cIi = jStat.multiply(jStat.slice(I, { row: i }), c);\n          jStat.sliceAssign(I, { row: j }, jStat.add(Ij, cIi));\n        })\n      });\n      return I;\n    }\n\n    function qr_solve(A, b){\n      var array_mode = false;\n      if (b[0].length === undefined) {\n        // [c1,c2,c3] mode\n        b = b.map(function(x){ return [x] });\n        array_mode = true;\n      }\n      var QR = jStat.QR(A);\n      var Q = QR[0];\n      var R = QR[1];\n      var attrs = A[0].length;\n      var Q1 = jStat.slice(Q,{col:{end:attrs}});\n      var R1 = jStat.slice(R,{row:{end:attrs}});\n      var RI = R_I(R1);\n      var Q2 = jStat.transpose(Q1);\n\n      if(Q2[0].length === undefined){\n        Q2 = [Q2]; // The confusing jStat.multifly implementation threat nature process again.\n      }\n\n      var x = jStat.multiply(jStat.multiply(RI, Q2), b);\n\n      if(x.length === undefined){\n        x = [[x]]; // The confusing jStat.multifly implementation threat nature process again.\n      }\n\n\n      if (array_mode)\n        return x.map(function(i){ return i[0] });\n      return x;\n    }\n\n    return qr_solve;\n  }()),\n\n  jacobi: function jacobi(a) {\n    var condition = 1;\n    var n = a.length;\n    var e = jStat.identity(n, n);\n    var ev = [];\n    var b, i, j, p, q, maxim, theta, s;\n    // condition === 1 only if tolerance is not reached\n    while (condition === 1) {\n      maxim = a[0][1];\n      p = 0;\n      q = 1;\n      for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          if (i != j) {\n            if (maxim < Math.abs(a[i][j])) {\n              maxim = Math.abs(a[i][j]);\n              p = i;\n              q = j;\n            }\n          }\n        }\n      }\n      if (a[p][p] === a[q][q])\n        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;\n      else\n        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;\n      s = jStat.identity(n, n);\n      s[p][p] = Math.cos(theta);\n      s[p][q] = -Math.sin(theta);\n      s[q][p] = Math.sin(theta);\n      s[q][q] = Math.cos(theta);\n      // eigen vector matrix\n      e = jStat.multiply(e, s);\n      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);\n      a = b;\n      condition = 0;\n      for (i = 1; i < n; i++) {\n        for (j = 1; j < n; j++) {\n          if (i != j && Math.abs(a[i][j]) > 0.001) {\n            condition = 1;\n          }\n        }\n      }\n    }\n    for (i = 0; i < n; i++) ev.push(a[i][i]);\n    //returns both the eigenvalue and eigenmatrix\n    return [e, ev];\n  },\n\n  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {\n    var k1, k2, u_j1, k3, k4;\n    if (order === 2) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h, u_j + k1);\n        u_j1 = u_j + (k1 + k2) / 2;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    if (order === 4) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h / 2, u_j + k1 / 2);\n        k3 = h * f(t_j + h / 2, u_j + k2 / 2);\n        k4 = h * f(t_j +h, u_j + k3);\n        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    return u_j;\n  },\n\n  romberg: function romberg(f, a, b, order) {\n    var i = 0;\n    var h = (b - a) / 2;\n    var x = [];\n    var h1 = [];\n    var g = [];\n    var m, a1, j, k, I;\n    while (i < order / 2) {\n      I = f(a);\n      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;\n      m = x.length;\n      for (j = 1; j < m - 1; j++) {\n        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);\n      }\n      I = (h / 3) * (I + f(b));\n      g[i] = I;\n      h /= 2;\n      i++;\n    }\n    a1 = g.length;\n    m = 1;\n    while (a1 !== 1) {\n      for (j = 0; j < a1 - 1; j++)\n      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a1 = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  richardson: function richardson(X, f, x, h) {\n    function pos(X, x) {\n      var i = 0;\n      var n = X.length;\n      var p;\n      for (; i < n; i++)\n        if (X[i] === x) p = i;\n      return p;\n    }\n    var h_min = Math.abs(x - X[pos(X, x) + 1]);\n    var i = 0;\n    var g = [];\n    var h1 = [];\n    var y1, y2, m, a, j;\n    while (h >= h_min) {\n      y1 = pos(X, x + h);\n      y2 = pos(X, x);\n      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);\n      h /= 2;\n      i++;\n    }\n    a = g.length;\n    m = 1;\n    while (a != 1) {\n      for (j = 0; j < a - 1; j++)\n        h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  simpson: function simpson(f, a, b, n) {\n    var h = (b - a) / n;\n    var I = f(a);\n    var x = [];\n    var j = a;\n    var k = 0;\n    var i = 1;\n    var m;\n    for (; j <= b; j = j + h, k++)\n      x[k] = j;\n    m = x.length;\n    for (; i < m - 1; i++) {\n      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);\n    }\n    return (h / 3) * (I + f(b));\n  },\n\n  hermite: function hermite(X, F, dF, value) {\n    var n = X.length;\n    var p = 0;\n    var i = 0;\n    var l = [];\n    var dl = [];\n    var A = [];\n    var B = [];\n    var j;\n    for (; i < n; i++) {\n      l[i] = 1;\n      for (j = 0; j < n; j++) {\n        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);\n      }\n      dl[i] = 0;\n      for (j = 0; j < n; j++) {\n        if (i != j) dl[i] += 1 / (X [i] - X[j]);\n      }\n      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);\n      B[i] = (value - X[i]) * (l[i] * l[i]);\n      p += (A[i] * F[i] + B[i] * dF[i]);\n    }\n    return p;\n  },\n\n  lagrange: function lagrange(X, F, value) {\n    var p = 0;\n    var i = 0;\n    var j, l;\n    var n = X.length;\n    for (; i < n; i++) {\n      l = F[i];\n      for (j = 0; j < n; j++) {\n        // calculating the lagrange polynomial L_i\n        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);\n      }\n      // adding the lagrange polynomials found above\n      p += l;\n    }\n    return p;\n  },\n\n  cubic_spline: function cubic_spline(X, F, value) {\n    var n = X.length;\n    var i = 0, j;\n    var A = [];\n    var B = [];\n    var alpha = [];\n    var c = [];\n    var h = [];\n    var b = [];\n    var d = [];\n    for (; i < n - 1; i++)\n      h[i] = X[i + 1] - X[i];\n    alpha[0] = 0;\n    for (i = 1; i < n - 1; i++) {\n      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -\n          (3 / h[i-1]) * (F[i] - F[i-1]);\n    }\n    for (i = 1; i < n - 1; i++) {\n      A[i] = [];\n      B[i] = [];\n      A[i][i-1] = h[i-1];\n      A[i][i] = 2 * (h[i - 1] + h[i]);\n      A[i][i+1] = h[i];\n      B[i][0] = alpha[i];\n    }\n    c = jStat.multiply(jStat.inv(A), B);\n    for (j = 0; j < n - 1; j++) {\n      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;\n      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);\n    }\n    for (j = 0; j < n; j++) {\n      if (X[j] > value) break;\n    }\n    j -= 1;\n    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *\n        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];\n  },\n\n  gauss_quadrature: function gauss_quadrature() {\n    throw new Error('gauss_quadrature not yet implemented');\n  },\n\n  PCA: function PCA(X) {\n    var m = X.length;\n    var n = X[0].length;\n    var i = 0;\n    var j, temp1;\n    var u = [];\n    var D = [];\n    var result = [];\n    var temp2 = [];\n    var Y = [];\n    var Bt = [];\n    var B = [];\n    var C = [];\n    var V = [];\n    var Vt = [];\n    for (i = 0; i < m; i++) {\n      u[i] = jStat.sum(X[i]) / n;\n    }\n    for (i = 0; i < n; i++) {\n      B[i] = [];\n      for(j = 0; j < m; j++) {\n        B[i][j] = X[j][i] - u[j];\n      }\n    }\n    B = jStat.transpose(B);\n    for (i = 0; i < m; i++) {\n      C[i] = [];\n      for (j = 0; j < m; j++) {\n        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);\n      }\n    }\n    result = jStat.jacobi(C);\n    V = result[0];\n    D = result[1];\n    Vt = jStat.transpose(V);\n    for (i = 0; i < D.length; i++) {\n      for (j = i; j < D.length; j++) {\n        if(D[i] < D[j])  {\n          temp1 = D[i];\n          D[i] = D[j];\n          D[j] = temp1;\n          temp2 = Vt[i];\n          Vt[i] = Vt[j];\n          Vt[j] = temp2;\n        }\n      }\n    }\n    Bt = jStat.transpose(B);\n    for (i = 0; i < m; i++) {\n      Y[i] = [];\n      for (j = 0; j < Bt.length; j++) {\n        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);\n      }\n    }\n    return [X, D, Vt, Y];\n  }\n});\n\n// extend jStat.fn with methods that require one argument\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function(arg, func) {\n      var tmpthis = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));\n        }, 15);\n        return this;\n      }\n      if (typeof jStat[passfunc](this, arg) === 'number')\n        return jStat[passfunc](this, arg);\n      else\n        return jStat(jStat[passfunc](this, arg));\n    };\n  }(funcs[i]));\n}('add divide multiply subtract dot pow exp log abs norm angle'.split(' ')));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\nvar slice = [].slice;\nvar isNumber = jStat.utils.isNumber;\nvar isArray = jStat.utils.isArray;\n\n// flag==true denotes use of sample standard deviation\n// Z Statistics\njStat.extend({\n  // 2 different parameter lists:\n  // (value, mean, sd)\n  // (value, array, flag)\n  zscore: function zscore() {\n    var args = slice.call(arguments);\n    if (isNumber(args[1])) {\n      return (args[0] - args[1]) / args[2];\n    }\n    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, sides)\n  // (zscore, sides)\n  // (value, array, sides, flag)\n  ztest: function ztest() {\n    var args = slice.call(arguments);\n    var z;\n    if (isArray(args[1])) {\n      // (value, array, sides, flag)\n      z = jStat.zscore(args[0],args[1],args[3]);\n      return (args[2] === 1) ?\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)) :\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);\n    } else {\n      if (args.length > 2) {\n        // (value, mean, sd, sides)\n        z = jStat.zscore(args[0],args[1],args[2]);\n        return (args[3] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);\n      } else {\n        // (zscore, sides)\n        z = args[0];\n        return (args[1] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)*2);\n      }\n    }\n  }\n});\n\njStat.extend(jStat.fn, {\n  zscore: function zscore(value, flag) {\n    return (value - this.mean()) / this.stdev(flag);\n  },\n\n  ztest: function ztest(value, sides, flag) {\n    var zscore = Math.abs(this.zscore(value, flag));\n    return (sides === 1) ?\n      (jStat.normal.cdf(-zscore, 0, 1)) :\n      (jStat.normal.cdf(-zscore, 0, 1) * 2);\n  }\n});\n\n// T Statistics\njStat.extend({\n  // 2 parameter lists\n  // (value, mean, sd, n)\n  // (value, array)\n  tscore: function tscore() {\n    var args = slice.call(arguments);\n    return (args.length === 4) ?\n      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :\n      ((args[0] - jStat.mean(args[1])) /\n       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, n, sides)\n  // (tscore, n, sides)\n  // (value, array, sides)\n  ttest: function ttest() {\n    var args = slice.call(arguments);\n    var tscore;\n    if (args.length === 5) {\n      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));\n      return (args[4] === 1) ?\n        (jStat.studentt.cdf(-tscore, args[3]-1)) :\n        (jStat.studentt.cdf(-tscore, args[3]-1)*2);\n    }\n    if (isNumber(args[1])) {\n      tscore = Math.abs(args[0])\n      return (args[2] == 1) ?\n        (jStat.studentt.cdf(-tscore, args[1]-1)) :\n        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);\n    }\n    tscore = Math.abs(jStat.tscore(args[0], args[1]))\n    return (args[2] == 1) ?\n      (jStat.studentt.cdf(-tscore, args[1].length-1)) :\n      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  tscore: function tscore(value) {\n    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));\n  },\n\n  ttest: function ttest(value, sides) {\n    return (sides === 1) ?\n      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :\n      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);\n  }\n});\n\n// F Statistics\njStat.extend({\n  // Paramter list is as follows:\n  // (array1, array2, array3, ...)\n  // or it is an array of arrays\n  // array of arrays conversion\n  anovafscore: function anovafscore() {\n    var args = slice.call(arguments),\n    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;\n    if (args.length === 1) {\n      tmpargs = new Array(args[0].length);\n      for (i = 0; i < args[0].length; i++) {\n        tmpargs[i] = args[0][i];\n      }\n      args = tmpargs;\n    }\n    // Builds sample array\n    sample = new Array();\n    for (i = 0; i < args.length; i++) {\n      sample = sample.concat(args[i]);\n    }\n    sampMean = jStat.mean(sample);\n    // Computes the explained variance\n    expVar = 0;\n    for (i = 0; i < args.length; i++) {\n      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);\n    }\n    expVar /= (args.length - 1);\n    // Computes unexplained variance\n    unexpVar = 0;\n    for (i = 0; i < args.length; i++) {\n      sampSampMean = jStat.mean(args[i]);\n      for (j = 0; j < args[i].length; j++) {\n        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);\n      }\n    }\n    unexpVar /= (sample.length - args.length);\n    return expVar / unexpVar;\n  },\n\n  // 2 different paramter setups\n  // (array1, array2, array3, ...)\n  // (anovafscore, df1, df2)\n  anovaftest: function anovaftest() {\n    var args = slice.call(arguments),\n    df1, df2, n, i;\n    if (isNumber(args[0])) {\n      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);\n    }\n    var anovafscore = jStat.anovafscore(args);\n    df1 = args.length - 1;\n    n = 0;\n    for (i = 0; i < args.length; i++) {\n      n = n + args[i].length;\n    }\n    df2 = n - df1 - 1;\n    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);\n  },\n\n  ftest: function ftest(fscore, df1, df2) {\n    return 1 - jStat.centralF.cdf(fscore, df1, df2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  anovafscore: function anovafscore() {\n    return jStat.anovafscore(this.toArray());\n  },\n\n  anovaftes: function anovaftes() {\n    var n = 0;\n    var i;\n    for (i = 0; i < this.length; i++) {\n      n = n + this[i].length;\n    }\n    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);\n  }\n});\n\n// Tukey's range test\njStat.extend({\n  // 2 parameter lists\n  // (mean1, mean2, n1, n2, sd)\n  // (array1, array2, sd)\n  qscore: function qscore() {\n    var args = slice.call(arguments);\n    var mean1, mean2, n1, n2, sd;\n    if (isNumber(args[0])) {\n        mean1 = args[0];\n        mean2 = args[1];\n        n1 = args[2];\n        n2 = args[3];\n        sd = args[4];\n    } else {\n        mean1 = jStat.mean(args[0]);\n        mean2 = jStat.mean(args[1]);\n        n1 = args[0].length;\n        n2 = args[1].length;\n        sd = args[2];\n    }\n    return Math.abs(mean1 - mean2) / (sd * Math.sqrt((1 / n1 + 1 / n2) / 2));\n  },\n\n  // 3 different parameter lists:\n  // (qscore, n, k)\n  // (mean1, mean2, n1, n2, sd, n, k)\n  // (array1, array2, sd, n, k)\n  qtest: function qtest() {\n    var args = slice.call(arguments);\n\n    var qscore;\n    if (args.length === 3) {\n      qscore = args[0];\n      args = args.slice(1);\n    } else if (args.length === 7) {\n      qscore = jStat.qscore(args[0], args[1], args[2], args[3], args[4]);\n      args = args.slice(5);\n    } else {\n      qscore = jStat.qscore(args[0], args[1], args[2]);\n      args = args.slice(3);\n    }\n\n    var n = args[0];\n    var k = args[1];\n\n    return 1 - jStat.tukey.cdf(qscore, k, n - k);\n  },\n\n  tukeyhsd: function tukeyhsd(arrays) {\n    var sd = jStat.pooledstdev(arrays);\n    var means = arrays.map(function (arr) {return jStat.mean(arr);});\n    var n = arrays.reduce(function (n, arr) {return n + arr.length;}, 0);\n\n    var results = [];\n    for (var i = 0; i < arrays.length; ++i) {\n        for (var j = i + 1; j < arrays.length; ++j) {\n            var p = jStat.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);\n            results.push([[i, j], p]);\n        }\n    }\n\n    return results;\n  }\n});\n\n// Error Bounds\njStat.extend({\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  normalci: function normalci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  tci: function tci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *\n                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  significant: function significant(pvalue, alpha) {\n    return pvalue < alpha;\n  }\n});\n\njStat.extend(jStat.fn, {\n  normalci: function normalci(value, alpha) {\n    return jStat.normalci(value, alpha, this.toArray());\n  },\n\n  tci: function tci(value, alpha) {\n    return jStat.tci(value, alpha, this.toArray());\n  }\n});\n\n// internal method for calculating the z-score for a difference of proportions test\nfunction differenceOfProportions(p1, n1, p2, n2) {\n  if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {\n    throw new Error(\"Proportions should be greater than 0 and less than 1\")\n  }\n  var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);\n  var se = Math.sqrt(pooled * (1 - pooled) * ((1/n1) + (1/n2)));\n  return (p1 - p2) / se;\n}\n\n// Difference of Proportions\njStat.extend(jStat.fn, {\n  oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 1);\n  },\n\n  twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 2);\n  }\n});\n\n}(jStat, Math));\njStat.models = (function(){\n  function sub_regress(exog) {\n    var var_count = exog[0].length;\n    var modelList = jStat.arange(var_count).map(function(endog_index) {\n      var exog_index =\n          jStat.arange(var_count).filter(function(i){return i!==endog_index});\n      return ols(jStat.col(exog, endog_index).map(function(x){ return x[0] }),\n                 jStat.col(exog, exog_index))\n    });\n    return modelList;\n  }\n\n  // do OLS model regress\n  // exog have include const columns ,it will not generate it .In fact, exog is\n  // \"design matrix\" look at\n  //https://en.wikipedia.org/wiki/Design_matrix\n  function ols(endog, exog) {\n    var nobs = endog.length;\n    var df_model = exog[0].length - 1;\n    var df_resid = nobs-df_model - 1;\n    var coef = jStat.lstsq(exog, endog);\n    var predict =\n        jStat.multiply(exog, coef.map(function(x) { return [x] }))\n            .map(function(p) { return p[0] });\n    var resid = jStat.subtract(endog, predict);\n    var ybar = jStat.mean(endog);\n    // constant cause problem\n    // var SST = jStat.sum(endog.map(function(y) {\n    //   return Math.pow(y-ybar,2);\n    // }));\n    var SSE = jStat.sum(predict.map(function(f) {\n      return Math.pow(f - ybar, 2);\n    }));\n    var SSR = jStat.sum(endog.map(function(y, i) {\n      return Math.pow(y - predict[i], 2);\n    }));\n    var SST = SSE + SSR;\n    var R2 = (SSE / SST);\n    return {\n        exog:exog,\n        endog:endog,\n        nobs:nobs,\n        df_model:df_model,\n        df_resid:df_resid,\n        coef:coef,\n        predict:predict,\n        resid:resid,\n        ybar:ybar,\n        SST:SST,\n        SSE:SSE,\n        SSR:SSR,\n        R2:R2\n    };\n  }\n\n  // H0: b_I=0\n  // H1: b_I!=0\n  function t_test(model) {\n    var subModelList = sub_regress(model.exog);\n    //var sigmaHat=jStat.stdev(model.resid);\n    var sigmaHat = Math.sqrt(model.SSR / (model.df_resid));\n    var seBetaHat = subModelList.map(function(mod) {\n      var SST = mod.SST;\n      var R2 = mod.R2;\n      return sigmaHat / Math.sqrt(SST * (1 - R2));\n    });\n    var tStatistic = model.coef.map(function(coef, i) {\n      return (coef - 0) / seBetaHat[i];\n    });\n    var pValue = tStatistic.map(function(t) {\n      var leftppf = jStat.studentt.cdf(t, model.df_resid);\n      return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;\n    });\n    var c = jStat.studentt.inv(0.975, model.df_resid);\n    var interval95 = model.coef.map(function(coef, i) {\n      var d = c * seBetaHat[i];\n      return [coef - d, coef + d];\n    })\n    return {\n        se: seBetaHat,\n        t: tStatistic,\n        p: pValue,\n        sigmaHat: sigmaHat,\n        interval95: interval95\n    };\n  }\n\n  function F_test(model) {\n    var F_statistic =\n        (model.R2 / model.df_model) / ((1 - model.R2) / model.df_resid);\n    var fcdf = function(x, n1, n2) {\n      return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2)\n    }\n    var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);\n    return { F_statistic: F_statistic, pvalue: pvalue };\n  }\n\n  function ols_wrap(endog, exog) {\n    var model = ols(endog,exog);\n    var ttest = t_test(model);\n    var ftest = F_test(model);\n    // Provide the Wherry / Ezekiel / McNemar / Cohen Adjusted R^2\n    // Which matches the 'adjusted R^2' provided by R's lm package\n    var adjust_R2 =\n        1 - (1 - model.R2) * ((model.nobs - 1) / (model.df_resid));\n    model.t = ttest;\n    model.f = ftest;\n    model.adjust_R2 = adjust_R2;\n    return model;\n  }\n\n  return { ols: ols_wrap };\n})();\n//To regress, simply build X matrix\n//(append column of 1's) using\n//buildxmatrix and build the Y\n//matrix using buildymatrix\n//(simply the transpose)\n//and run regress.\n\n\n\n//Regressions\n\njStat.extend({\n  buildxmatrix: function buildxmatrix(){\n    //Parameters will be passed in as such\n    //(array1,array2,array3,...)\n    //as (x1,x2,x3,...)\n    //needs to be (1,x1,x2,x3,...)\n    var matrixRows = new Array(arguments.length);\n    for(var i=0;i<arguments.length;i++){\n      var array = [1];\n      matrixRows[i]= array.concat(arguments[i]);\n    }\n    return jStat(matrixRows);\n\n  },\n\n  builddxmatrix: function builddxmatrix() {\n    //Paramters will be passed in as such\n    //([array1,array2,...]\n    var matrixRows = new Array(arguments[0].length);\n    for(var i=0;i<arguments[0].length;i++){\n      var array = [1]\n      matrixRows[i]= array.concat(arguments[0][i]);\n    }\n    return jStat(matrixRows);\n\n  },\n\n  buildjxmatrix: function buildjxmatrix(jMat) {\n    //Builds from jStat Matrix\n    var pass = new Array(jMat.length)\n    for(var i=0;i<jMat.length;i++){\n      pass[i] = jMat[i];\n    }\n    return jStat.builddxmatrix(pass);\n\n  },\n\n  buildymatrix: function buildymatrix(array){\n    return jStat(array).transpose();\n  },\n\n  buildjymatrix: function buildjymatrix(jMat){\n    return jMat.transpose();\n  },\n\n  matrixmult: function matrixmult(A,B){\n    var i, j, k, result, sum;\n    if (A.cols() == B.rows()) {\n      if(B.rows()>1){\n        result = [];\n        for (i = 0; i < A.rows(); i++) {\n          result[i] = [];\n          for (j = 0; j < B.cols(); j++) {\n            sum = 0;\n            for (k = 0; k < A.cols(); k++) {\n              sum += A.toArray()[i][k] * B.toArray()[k][j];\n            }\n            result[i][j] = sum;\n          }\n        }\n        return jStat(result);\n      }\n      result = [];\n      for (i = 0; i < A.rows(); i++) {\n        result[i] = [];\n        for (j = 0; j < B.cols(); j++) {\n          sum = 0;\n          for (k = 0; k < A.cols(); k++) {\n            sum += A.toArray()[i][k] * B.toArray()[j];\n          }\n          result[i][j] = sum;\n        }\n      }\n      return jStat(result);\n    }\n  },\n\n  //regress and regresst to be fixed\n\n  regress: function regress(jMatX,jMatY){\n    //print(\"regressin!\");\n    //print(jMatX.toArray());\n    var innerinv = jStat.xtranspxinv(jMatX);\n    //print(innerinv);\n    var xtransp = jMatX.transpose();\n    var next = jStat.matrixmult(jStat(innerinv),xtransp);\n    return jStat.matrixmult(next,jMatY);\n\n  },\n\n  regresst: function regresst(jMatX,jMatY,sides){\n    var beta = jStat.regress(jMatX,jMatY);\n\n    var compile = {};\n    compile.anova = {};\n    var jMatYBar = jStat.jMatYBar(jMatX, beta);\n    compile.yBar = jMatYBar;\n    var yAverage = jMatY.mean();\n    compile.anova.residuals = jStat.residuals(jMatY, jMatYBar);\n\n    compile.anova.ssr = jStat.ssr(jMatYBar, yAverage);\n    compile.anova.msr = compile.anova.ssr / (jMatX[0].length - 1);\n\n    compile.anova.sse = jStat.sse(jMatY, jMatYBar);\n    compile.anova.mse =\n        compile.anova.sse / (jMatY.length - (jMatX[0].length - 1) - 1);\n\n    compile.anova.sst = jStat.sst(jMatY, yAverage);\n    compile.anova.mst = compile.anova.sst / (jMatY.length - 1);\n\n    compile.anova.r2 = 1 - (compile.anova.sse / compile.anova.sst);\n    if (compile.anova.r2 < 0) compile.anova.r2 = 0;\n\n    compile.anova.fratio = compile.anova.msr / compile.anova.mse;\n    compile.anova.pvalue =\n        jStat.anovaftest(compile.anova.fratio,\n                         jMatX[0].length - 1,\n                         jMatY.length - (jMatX[0].length - 1) - 1);\n\n    compile.anova.rmse = Math.sqrt(compile.anova.mse);\n\n    compile.anova.r2adj = 1 - (compile.anova.mse / compile.anova.mst);\n    if (compile.anova.r2adj < 0) compile.anova.r2adj = 0;\n\n    compile.stats = new Array(jMatX[0].length);\n    var covar = jStat.xtranspxinv(jMatX);\n    var sds, ts, ps;\n\n    for(var i=0; i<beta.length;i++){\n      sds=Math.sqrt(compile.anova.mse * Math.abs(covar[i][i]));\n      ts= Math.abs(beta[i] / sds);\n      ps= jStat.ttest(ts, jMatY.length - jMatX[0].length - 1, sides);\n\n      compile.stats[i]=[beta[i], sds, ts, ps];\n    }\n\n    compile.regress = beta;\n    return compile;\n  },\n\n  xtranspx: function xtranspx(jMatX){\n    return jStat.matrixmult(jMatX.transpose(),jMatX);\n  },\n\n\n  xtranspxinv: function xtranspxinv(jMatX){\n    var inner = jStat.matrixmult(jMatX.transpose(),jMatX);\n    var innerinv = jStat.inv(inner);\n    return innerinv;\n  },\n\n  jMatYBar: function jMatYBar(jMatX, beta) {\n    var yBar = jStat.matrixmult(jMatX, beta);\n    return new jStat(yBar);\n  },\n\n  residuals: function residuals(jMatY, jMatYBar) {\n    return jStat.matrixsubtract(jMatY, jMatYBar);\n  },\n\n  ssr: function ssr(jMatYBar, yAverage) {\n    var ssr = 0;\n    for(var i = 0; i < jMatYBar.length; i++) {\n      ssr += Math.pow(jMatYBar[i] - yAverage, 2);\n    }\n    return ssr;\n  },\n\n  sse: function sse(jMatY, jMatYBar) {\n    var sse = 0;\n    for(var i = 0; i < jMatY.length; i++) {\n      sse += Math.pow(jMatY[i] - jMatYBar[i], 2);\n    }\n    return sse;\n  },\n\n  sst: function sst(jMatY, yAverage) {\n    var sst = 0;\n    for(var i = 0; i < jMatY.length; i++) {\n      sst += Math.pow(jMatY[i] - yAverage, 2);\n    }\n    return sst;\n  },\n\n  matrixsubtract: function matrixsubtract(A,B){\n    var ans = new Array(A.length);\n    for(var i=0;i<A.length;i++){\n      ans[i] = new Array(A[i].length);\n      for(var j=0;j<A[i].length;j++){\n        ans[i][j]=A[i][j]-B[i][j];\n      }\n    }\n    return jStat(ans);\n  }\n});\n  // Make it compatible with previous version.\n  jStat.jStat = jStat;\n\n  return jStat;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7QUFHRDtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7OztBQUdEO0FBQ0E7O0FBRUEsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFVBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW94bmV0Ly4vbm9kZV9tb2R1bGVzL2pzdGF0L2Rpc3QvanN0YXQuanM/MzM5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKHdpbmRvdywgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5qU3RhdCA9IGZhY3RvcnkoKTtcbiAgICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG52YXIgalN0YXQgPSAoZnVuY3Rpb24oTWF0aCwgdW5kZWZpbmVkKSB7XG5cbi8vIEZvciBxdWljayByZWZlcmVuY2UuXG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8vIENhbGN1bGF0ZSBjb3JyZWN0aW9uIGZvciBJRUVFIGVycm9yXG4vLyBUT0RPOiBUaGlzIGNhbGN1bGF0aW9uIGNhbiBiZSBpbXByb3ZlZC5cbmZ1bmN0aW9uIGNhbGNSZHgobiwgbSkge1xuICB2YXIgdmFsID0gbiA+IG0gPyBuIDogbTtcbiAgcmV0dXJuIE1hdGgucG93KDEwLFxuICAgICAgICAgICAgICAgICAgMTcgLSB+fihNYXRoLmxvZygoKHZhbCA+IDApID8gdmFsIDogLXZhbCkpICogTWF0aC5MT0cxMEUpKTtcbn1cblxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuXG5mdW5jdGlvbiBpc051bWJlcihudW0pIHtcbiAgcmV0dXJuICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJykgPyBudW0gLSBudW0gPT09IDAgOiBmYWxzZTtcbn1cblxuXG4vLyBDb252ZXJ0cyB0aGUgalN0YXQgbWF0cml4IHRvIHZlY3Rvci5cbmZ1bmN0aW9uIHRvVmVjdG9yKGFycikge1xuICByZXR1cm4gY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xufVxuXG5cbi8vIFRoZSBvbmUgYW5kIG9ubHkgalN0YXQgY29uc3RydWN0b3IuXG5mdW5jdGlvbiBqU3RhdCgpIHtcbiAgcmV0dXJuIG5ldyBqU3RhdC5faW5pdChhcmd1bWVudHMpO1xufVxuXG5cbi8vIFRPRE86IFJlbW92ZSBhZnRlciBhbGwgcmVmZXJlbmNlcyBpbiBzcmMgZmlsZXMgaGF2ZSBiZWVuIHJlbW92ZWQuXG5qU3RhdC5mbiA9IGpTdGF0LnByb3RvdHlwZTtcblxuXG4vLyBCeSBzZXBhcmF0aW5nIHRoZSBpbml0aWFsaXplciBmcm9tIHRoZSBjb25zdHJ1Y3RvciBpdCdzIGVhc2llciB0byBoYW5kbGVcbi8vIGFsd2F5cyByZXR1cm5pbmcgYSBuZXcgaW5zdGFuY2Ugd2hldGhlciBcIm5ld1wiIHdhcyB1c2VkIG9yIG5vdC5cbmpTdGF0Ll9pbml0ID0gZnVuY3Rpb24gX2luaXQoYXJncykge1xuICAvLyBJZiBmaXJzdCBhcmd1bWVudCBpcyBhbiBhcnJheSwgbXVzdCBiZSB2ZWN0b3Igb3IgbWF0cml4LlxuICBpZiAoaXNBcnJheShhcmdzWzBdKSkge1xuICAgIC8vIENoZWNrIGlmIG1hdHJpeC5cbiAgICBpZiAoaXNBcnJheShhcmdzWzBdWzBdKSkge1xuICAgICAgLy8gU2VlIGlmIGEgbWFwcGluZyBmdW5jdGlvbiB3YXMgYWxzbyBwYXNzZWQuXG4gICAgICBpZiAoaXNGdW5jdGlvbihhcmdzWzFdKSlcbiAgICAgICAgYXJnc1swXSA9IGpTdGF0Lm1hcChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIGlzIGZhc3RlciB0aGFuIHRoaXMucHVzaC5hcHBseSh0aGlzLCBhcmdzWzBdLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzWzBdLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzW2ldID0gYXJnc1swXVtpXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gYXJnc1swXS5sZW5ndGg7XG5cbiAgICAvLyBPdGhlcndpc2UgbXVzdCBiZSBhIHZlY3Rvci5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1swXSA9IGlzRnVuY3Rpb24oYXJnc1sxXSkgPyBqU3RhdC5tYXAoYXJnc1swXSwgYXJnc1sxXSkgOiBhcmdzWzBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAvLyBJZiBmaXJzdCBhcmd1bWVudCBpcyBudW1iZXIsIGFzc3VtZSBjcmVhdGlvbiBvZiBzZXF1ZW5jZS5cbiAgfSBlbHNlIGlmIChpc051bWJlcihhcmdzWzBdKSkge1xuICAgIHRoaXNbMF0gPSBqU3RhdC5zZXEuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gIC8vIEhhbmRsZSBjYXNlIHdoZW4galN0YXQgb2JqZWN0IGlzIHBhc3NlZCB0byBqU3RhdC5cbiAgfSBlbHNlIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgalN0YXQpIHtcbiAgICAvLyBEdXBsaWNhdGUgdGhlIG9iamVjdCBhbmQgcGFzcyBpdCBiYWNrLlxuICAgIHJldHVybiBqU3RhdChhcmdzWzBdLnRvQXJyYXkoKSk7XG5cbiAgLy8gVW5leHBlY3RlZCBhcmd1bWVudCB2YWx1ZSwgcmV0dXJuIGVtcHR5IGpTdGF0IG9iamVjdC5cbiAgLy8gVE9ETzogVGhpcyBpcyBzdHJhbmdlIGJlaGF2aW9yLiBTaG91bGRuJ3QgdGhpcyB0aHJvdyBvciBzb21lIHN1Y2ggdG8gbGV0XG4gIC8vIHRoZSB1c2VyIGtub3cgdGhleSBoYWQgYmFkIGFyZ3VtZW50cz9cbiAgfSBlbHNlIHtcbiAgICB0aGlzWzBdID0gW107XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xualN0YXQuX2luaXQucHJvdG90eXBlID0galN0YXQucHJvdG90eXBlO1xualN0YXQuX2luaXQuY29uc3RydWN0b3IgPSBqU3RhdDtcblxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucy5cbi8vIFRPRE86IGZvciBpbnRlcm5hbCB1c2Ugb25seT9cbmpTdGF0LnV0aWxzID0ge1xuICBjYWxjUmR4OiBjYWxjUmR4LFxuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIHRvVmVjdG9yOiB0b1ZlY3RvclxufTtcblxuXG5qU3RhdC5fcmFuZG9tX2ZuID0gTWF0aC5yYW5kb207XG5qU3RhdC5zZXRSYW5kb20gPSBmdW5jdGlvbiBzZXRSYW5kb20oZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmbiBpcyBub3QgYSBmdW5jdGlvbicpO1xuICBqU3RhdC5fcmFuZG9tX2ZuID0gZm47XG59O1xuXG5cbi8vIEVhc2lseSBleHRlbmQgdGhlIGpTdGF0IG9iamVjdC5cbi8vIFRPRE86IGlzIHRoaXMgc2VyaW91c2x5IG5lY2Vzc2FyeT9cbmpTdGF0LmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgdmFyIGksIGo7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBmb3IgKGogaW4gb2JqKVxuICAgICAgalN0YXRbal0gPSBvYmpbal07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChqIGluIGFyZ3VtZW50c1tpXSlcbiAgICAgIG9ialtqXSA9IGFyZ3VtZW50c1tpXVtqXTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBtYXRyaXguXG5qU3RhdC5yb3dzID0gZnVuY3Rpb24gcm93cyhhcnIpIHtcbiAgcmV0dXJuIGFyci5sZW5ndGggfHwgMTtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hdHJpeC5cbmpTdGF0LmNvbHMgPSBmdW5jdGlvbiBjb2xzKGFycikge1xuICByZXR1cm4gYXJyWzBdLmxlbmd0aCB8fCAxO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvYmplY3QgeyByb3dzOiBpLCBjb2xzOiBqIH1cbmpTdGF0LmRpbWVuc2lvbnMgPSBmdW5jdGlvbiBkaW1lbnNpb25zKGFycikge1xuICByZXR1cm4ge1xuICAgIHJvd3M6IGpTdGF0LnJvd3MoYXJyKSxcbiAgICBjb2xzOiBqU3RhdC5jb2xzKGFycilcbiAgfTtcbn07XG5cblxuLy8gUmV0dXJucyBhIHNwZWNpZmllZCByb3cgYXMgYSB2ZWN0b3Igb3IgcmV0dXJuIGEgc3ViIG1hdHJpeCBieSBwaWNrIHNvbWUgcm93c1xualN0YXQucm93ID0gZnVuY3Rpb24gcm93KGFyciwgaW5kZXgpIHtcbiAgaWYgKGlzQXJyYXkoaW5kZXgpKSB7XG4gICAgcmV0dXJuIGluZGV4Lm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4galN0YXQucm93KGFyciwgaSk7XG4gICAgfSlcbiAgfVxuICByZXR1cm4gYXJyW2luZGV4XTtcbn07XG5cblxuLy8gcmV0dXJuIHJvdyBhcyBhcnJheVxuLy8gcm93YShbWzEsMl0sWzMsNF1dLDApIC0+IFsxLDJdXG5qU3RhdC5yb3dhID0gZnVuY3Rpb24gcm93YShhcnIsIGkpIHtcbiAgcmV0dXJuIGpTdGF0LnJvdyhhcnIsIGkpO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgY29sdW1uIGFzIGEgdmVjdG9yIG9yIHJldHVybiBhIHN1YiBtYXRyaXggYnkgcGljayBzb21lXG4vLyBjb2x1bW5zXG5qU3RhdC5jb2wgPSBmdW5jdGlvbiBjb2woYXJyLCBpbmRleCkge1xuICBpZiAoaXNBcnJheShpbmRleCkpIHtcbiAgICB2YXIgc3VibWF0ID0galN0YXQuYXJhbmdlKGFyci5sZW5ndGgpLm1hcChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgQXJyYXkoaW5kZXgubGVuZ3RoKTtcbiAgICB9KTtcbiAgICBpbmRleC5mb3JFYWNoKGZ1bmN0aW9uKGluZCwgaSl7XG4gICAgICBqU3RhdC5hcmFuZ2UoYXJyLmxlbmd0aCkuZm9yRWFjaChmdW5jdGlvbihqKSB7XG4gICAgICAgIHN1Ym1hdFtqXVtpXSA9IGFycltqXVtpbmRdO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1Ym1hdDtcbiAgfVxuICB2YXIgY29sdW1uID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICBjb2x1bW5baV0gPSBbYXJyW2ldW2luZGV4XV07XG4gIHJldHVybiBjb2x1bW47XG59O1xuXG5cbi8vIHJldHVybiBjb2x1bW4gYXMgYXJyYXlcbi8vIGNvbGEoW1sxLDJdLFszLDRdXSwwKSAtPiBbMSwzXVxualN0YXQuY29sYSA9IGZ1bmN0aW9uIGNvbGEoYXJyLCBpKSB7XG4gIHJldHVybiBqU3RhdC5jb2woYXJyLCBpKS5tYXAoZnVuY3Rpb24oYSl7IHJldHVybiBhWzBdIH0pO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBkaWFnb25hbCBvZiB0aGUgbWF0cml4XG5qU3RhdC5kaWFnID0gZnVuY3Rpb24gZGlhZyhhcnIpIHtcbiAgdmFyIG5yb3cgPSBqU3RhdC5yb3dzKGFycik7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobnJvdyk7XG4gIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG5yb3c7IHJvdysrKVxuICAgIHJlc1tyb3ddID0gW2Fycltyb3ddW3Jvd11dO1xuICByZXR1cm4gcmVzO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBhbnRpLWRpYWdvbmFsIG9mIHRoZSBtYXRyaXhcbmpTdGF0LmFudGlkaWFnID0gZnVuY3Rpb24gYW50aWRpYWcoYXJyKSB7XG4gIHZhciBucm93ID0galN0YXQucm93cyhhcnIpIC0gMTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShucm93KTtcbiAgZm9yICh2YXIgaSA9IDA7IG5yb3cgPj0gMDsgbnJvdy0tLCBpKyspXG4gICAgcmVzW2ldID0gW2FycltpXVtucm93XV07XG4gIHJldHVybiByZXM7XG59O1xuXG4vLyBUcmFuc3Bvc2UgYSBtYXRyaXggb3IgYXJyYXkuXG5qU3RhdC50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UoYXJyKSB7XG4gIHZhciBvYmogPSBbXTtcbiAgdmFyIG9iakFyciwgcm93cywgY29scywgaiwgaTtcblxuICAvLyBNYWtlIHN1cmUgYXJyIGlzIGluIG1hdHJpeCBmb3JtYXQuXG4gIGlmICghaXNBcnJheShhcnJbMF0pKVxuICAgIGFyciA9IFthcnJdO1xuXG4gIHJvd3MgPSBhcnIubGVuZ3RoO1xuICBjb2xzID0gYXJyWzBdLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgY29sczsgaSsrKSB7XG4gICAgb2JqQXJyID0gbmV3IEFycmF5KHJvd3MpO1xuICAgIGZvciAoaiA9IDA7IGogPCByb3dzOyBqKyspXG4gICAgICBvYmpBcnJbal0gPSBhcnJbal1baV07XG4gICAgb2JqLnB1c2gob2JqQXJyKTtcbiAgfVxuXG4gIC8vIElmIG9iaiBpcyB2ZWN0b3IsIHJldHVybiBvbmx5IHNpbmdsZSBhcnJheS5cbiAgcmV0dXJuIG9iai5sZW5ndGggPT09IDEgPyBvYmpbMF0gOiBvYmo7XG59O1xuXG5cbi8vIE1hcCBhIGZ1bmN0aW9uIHRvIGFuIGFycmF5IG9yIGFycmF5IG9mIGFycmF5cy5cbi8vIFwidG9BbHRlclwiIGlzIGFuIGludGVybmFsIHZhcmlhYmxlLlxualN0YXQubWFwID0gZnVuY3Rpb24gbWFwKGFyciwgZnVuYywgdG9BbHRlcikge1xuICB2YXIgcm93LCBucm93LCBuY29sLCByZXMsIGNvbDtcblxuICBpZiAoIWlzQXJyYXkoYXJyWzBdKSlcbiAgICBhcnIgPSBbYXJyXTtcblxuICBucm93ID0gYXJyLmxlbmd0aDtcbiAgbmNvbCA9IGFyclswXS5sZW5ndGg7XG4gIHJlcyA9IHRvQWx0ZXIgPyBhcnIgOiBuZXcgQXJyYXkobnJvdyk7XG5cbiAgZm9yIChyb3cgPSAwOyByb3cgPCBucm93OyByb3crKykge1xuICAgIC8vIGlmIHRoZSByb3cgZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0XG4gICAgaWYgKCFyZXNbcm93XSlcbiAgICAgIHJlc1tyb3ddID0gbmV3IEFycmF5KG5jb2wpO1xuICAgIGZvciAoY29sID0gMDsgY29sIDwgbmNvbDsgY29sKyspXG4gICAgICByZXNbcm93XVtjb2xdID0gZnVuYyhhcnJbcm93XVtjb2xdLCByb3csIGNvbCk7XG4gIH1cblxuICByZXR1cm4gcmVzLmxlbmd0aCA9PT0gMSA/IHJlc1swXSA6IHJlcztcbn07XG5cblxuLy8gQ3VtdWxhdGl2ZWx5IGNvbWJpbmUgdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IG9yIGFycmF5IG9mIGFycmF5cyB1c2luZyBhIGZ1bmN0aW9uLlxualN0YXQuY3VtcmVkdWNlID0gZnVuY3Rpb24gY3VtcmVkdWNlKGFyciwgZnVuYywgdG9BbHRlcikge1xuICB2YXIgcm93LCBucm93LCBuY29sLCByZXMsIGNvbDtcblxuICBpZiAoIWlzQXJyYXkoYXJyWzBdKSlcbiAgICBhcnIgPSBbYXJyXTtcblxuICBucm93ID0gYXJyLmxlbmd0aDtcbiAgbmNvbCA9IGFyclswXS5sZW5ndGg7XG4gIHJlcyA9IHRvQWx0ZXIgPyBhcnIgOiBuZXcgQXJyYXkobnJvdyk7XG5cbiAgZm9yIChyb3cgPSAwOyByb3cgPCBucm93OyByb3crKykge1xuICAgIC8vIGlmIHRoZSByb3cgZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0XG4gICAgaWYgKCFyZXNbcm93XSlcbiAgICAgIHJlc1tyb3ddID0gbmV3IEFycmF5KG5jb2wpO1xuICAgIGlmIChuY29sID4gMClcbiAgICAgIHJlc1tyb3ddWzBdID0gYXJyW3Jvd11bMF07XG4gICAgZm9yIChjb2wgPSAxOyBjb2wgPCBuY29sOyBjb2wrKylcbiAgICAgIHJlc1tyb3ddW2NvbF0gPSBmdW5jKHJlc1tyb3ddW2NvbC0xXSwgYXJyW3Jvd11bY29sXSk7XG4gIH1cbiAgcmV0dXJuIHJlcy5sZW5ndGggPT09IDEgPyByZXNbMF0gOiByZXM7XG59O1xuXG5cbi8vIERlc3RydWN0aXZlbHkgYWx0ZXIgYW4gYXJyYXkuXG5qU3RhdC5hbHRlciA9IGZ1bmN0aW9uIGFsdGVyKGFyciwgZnVuYykge1xuICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuYywgdHJ1ZSk7XG59O1xuXG5cbi8vIEdlbmVyYXRlIGEgcm93cyB4IGNvbHMgbWF0cml4IGFjY29yZGluZyB0byB0aGUgc3VwcGxpZWQgZnVuY3Rpb24uXG5qU3RhdC5jcmVhdGUgPSBmdW5jdGlvbiAgY3JlYXRlKHJvd3MsIGNvbHMsIGZ1bmMpIHtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShyb3dzKTtcbiAgdmFyIGksIGo7XG5cbiAgaWYgKGlzRnVuY3Rpb24oY29scykpIHtcbiAgICBmdW5jID0gY29scztcbiAgICBjb2xzID0gcm93cztcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICByZXNbaV0gPSBuZXcgQXJyYXkoY29scyk7XG4gICAgZm9yIChqID0gMDsgaiA8IGNvbHM7IGorKylcbiAgICAgIHJlc1tpXVtqXSA9IGZ1bmMoaSwgaik7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuXG5mdW5jdGlvbiByZXRaZXJvKCkgeyByZXR1cm4gMDsgfVxuXG5cbi8vIEdlbmVyYXRlIGEgcm93cyB4IGNvbHMgbWF0cml4IG9mIHplcm9zLlxualN0YXQuemVyb3MgPSBmdW5jdGlvbiB6ZXJvcyhyb3dzLCBjb2xzKSB7XG4gIGlmICghaXNOdW1iZXIoY29scykpXG4gICAgY29scyA9IHJvd3M7XG4gIHJldHVybiBqU3RhdC5jcmVhdGUocm93cywgY29scywgcmV0WmVybyk7XG59O1xuXG5cbmZ1bmN0aW9uIHJldE9uZSgpIHsgcmV0dXJuIDE7IH1cblxuXG4vLyBHZW5lcmF0ZSBhIHJvd3MgeCBjb2xzIG1hdHJpeCBvZiBvbmVzLlxualN0YXQub25lcyA9IGZ1bmN0aW9uIG9uZXMocm93cywgY29scykge1xuICBpZiAoIWlzTnVtYmVyKGNvbHMpKVxuICAgIGNvbHMgPSByb3dzO1xuICByZXR1cm4galN0YXQuY3JlYXRlKHJvd3MsIGNvbHMsIHJldE9uZSk7XG59O1xuXG5cbi8vIEdlbmVyYXRlIGEgcm93cyB4IGNvbHMgbWF0cml4IG9mIHVuaWZvcm1seSByYW5kb20gbnVtYmVycy5cbmpTdGF0LnJhbmQgPSBmdW5jdGlvbiByYW5kKHJvd3MsIGNvbHMpIHtcbiAgaWYgKCFpc051bWJlcihjb2xzKSlcbiAgICBjb2xzID0gcm93cztcbiAgcmV0dXJuIGpTdGF0LmNyZWF0ZShyb3dzLCBjb2xzLCBqU3RhdC5fcmFuZG9tX2ZuKTtcbn07XG5cblxuZnVuY3Rpb24gcmV0SWRlbnQoaSwgaikgeyByZXR1cm4gaSA9PT0gaiA/IDEgOiAwOyB9XG5cblxuLy8gR2VuZXJhdGUgYW4gaWRlbnRpdHkgbWF0cml4IG9mIHNpemUgcm93IHggY29scy5cbmpTdGF0LmlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkocm93cywgY29scykge1xuICBpZiAoIWlzTnVtYmVyKGNvbHMpKVxuICAgIGNvbHMgPSByb3dzO1xuICByZXR1cm4galN0YXQuY3JlYXRlKHJvd3MsIGNvbHMsIHJldElkZW50KTtcbn07XG5cblxuLy8gVGVzdHMgd2hldGhlciBhIG1hdHJpeCBpcyBzeW1tZXRyaWNcbmpTdGF0LnN5bW1ldHJpYyA9IGZ1bmN0aW9uIHN5bW1ldHJpYyhhcnIpIHtcbiAgdmFyIHNpemUgPSBhcnIubGVuZ3RoO1xuICB2YXIgcm93LCBjb2w7XG5cbiAgaWYgKGFyci5sZW5ndGggIT09IGFyclswXS5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAocm93ID0gMDsgcm93IDwgc2l6ZTsgcm93KyspIHtcbiAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHNpemU7IGNvbCsrKVxuICAgICAgaWYgKGFycltjb2xdW3Jvd10gIT09IGFycltyb3ddW2NvbF0pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vLyBTZXQgYWxsIHZhbHVlcyB0byB6ZXJvLlxualN0YXQuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihhcnIpIHtcbiAgcmV0dXJuIGpTdGF0LmFsdGVyKGFyciwgcmV0WmVybyk7XG59O1xuXG5cbi8vIEdlbmVyYXRlIHNlcXVlbmNlLlxualN0YXQuc2VxID0gZnVuY3Rpb24gc2VxKG1pbiwgbWF4LCBsZW5ndGgsIGZ1bmMpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKVxuICAgIGZ1bmMgPSBmYWxzZTtcblxuICB2YXIgYXJyID0gW107XG4gIHZhciBoaXZhbCA9IGNhbGNSZHgobWluLCBtYXgpO1xuICB2YXIgc3RlcCA9IChtYXggKiBoaXZhbCAtIG1pbiAqIGhpdmFsKSAvICgobGVuZ3RoIC0gMSkgKiBoaXZhbCk7XG4gIHZhciBjdXJyZW50ID0gbWluO1xuICB2YXIgY250O1xuXG4gIC8vIEN1cnJlbnQgaXMgYXNzaWduZWQgdXNpbmcgYSB0ZWNobmlxdWUgdG8gY29tcGVuc2F0ZSBmb3IgSUVFRSBlcnJvci5cbiAgLy8gVE9ETzogTmVlZHMgYmV0dGVyIGltcGxlbWVudGF0aW9uLlxuICBmb3IgKGNudCA9IDA7XG4gICAgICAgY3VycmVudCA8PSBtYXggJiYgY250IDwgbGVuZ3RoO1xuICAgICAgIGNudCsrLCBjdXJyZW50ID0gKG1pbiAqIGhpdmFsICsgc3RlcCAqIGhpdmFsICogY250KSAvIGhpdmFsKSB7XG4gICAgYXJyLnB1c2goKGZ1bmMgPyBmdW5jKGN1cnJlbnQsIGNudCkgOiBjdXJyZW50KSk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufTtcblxuXG4vLyBhcmFuZ2UoNSkgLT4gWzAsMSwyLDMsNF1cbi8vIGFyYW5nZSgxLDUpIC0+IFsxLDIsMyw0XVxuLy8gYXJhbmdlKDUsMSwtMSkgLT4gWzUsNCwzLDJdXG5qU3RhdC5hcmFuZ2UgPSBmdW5jdGlvbiBhcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICB2YXIgcmwgPSBbXTtcbiAgdmFyIGk7XG4gIHN0ZXAgPSBzdGVwIHx8IDE7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICBpZiAoc3RhcnQgPT09IGVuZCB8fCBzdGVwID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChzdGFydCA8IGVuZCAmJiBzdGVwIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQgJiYgc3RlcCA+IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gc3RlcCkge1xuICAgICAgcmwucHVzaChpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPiBlbmQ7IGkgKz0gc3RlcCkge1xuICAgICAgcmwucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJsO1xufTtcblxuXG4vLyBBPVtbMSwyLDNdLFs0LDUsNl0sWzcsOCw5XV1cbi8vIHNsaWNlKEEse3Jvdzp7ZW5kOjJ9LGNvbDp7c3RhcnQ6MX19KSAtPiBbWzIsM10sWzUsNl1dXG4vLyBzbGljZShBLDEse3N0YXJ0OjF9KSAtPiBbNSw2XVxuLy8gYXMgbnVtcHkgY29kZSBBWzoyLDE6XVxualN0YXQuc2xpY2UgPSAoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gX3NsaWNlKGxpc3QsIHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAvLyBub3RlIGl0J3Mgbm90IGVxdWFsIHRvIHJhbmdlLm1hcCBtb2RlIGl0J3MgYSBidWdcbiAgICB2YXIgaTtcbiAgICB2YXIgcmwgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQgJiYgc3RlcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4galN0YXQuY29weShsaXN0KTtcbiAgICB9XG5cbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgZW5kID0gZW5kIHx8IGxpc3QubGVuZ3RoO1xuICAgIHN0YXJ0ID0gc3RhcnQgPj0gMCA/IHN0YXJ0IDogbGVuZ3RoICsgc3RhcnQ7XG4gICAgZW5kID0gZW5kID49IDAgPyBlbmQgOiBsZW5ndGggKyBlbmQ7XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcbiAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCBzdGVwID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGVuZCAmJiBzdGVwIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPiBlbmQgJiYgc3RlcCA+IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBzdGVwKSB7XG4gICAgICAgIHJsLnB1c2gobGlzdFtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IHN0YXJ0OyBpID4gZW5kO2kgKz0gc3RlcCkge1xuICAgICAgICBybC5wdXNoKGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmw7XG4gIH1cblxuICBmdW5jdGlvbiBzbGljZShsaXN0LCByY1NsaWNlKSB7XG4gICAgdmFyIGNvbFNsaWNlLCByb3dTbGljZTtcbiAgICByY1NsaWNlID0gcmNTbGljZSB8fCB7fTtcbiAgICBpZiAoaXNOdW1iZXIocmNTbGljZS5yb3cpKSB7XG4gICAgICBpZiAoaXNOdW1iZXIocmNTbGljZS5jb2wpKVxuICAgICAgICByZXR1cm4gbGlzdFtyY1NsaWNlLnJvd11bcmNTbGljZS5jb2xdO1xuICAgICAgdmFyIHJvdyA9IGpTdGF0LnJvd2EobGlzdCwgcmNTbGljZS5yb3cpO1xuICAgICAgY29sU2xpY2UgPSByY1NsaWNlLmNvbCB8fCB7fTtcbiAgICAgIHJldHVybiBfc2xpY2Uocm93LCBjb2xTbGljZS5zdGFydCwgY29sU2xpY2UuZW5kLCBjb2xTbGljZS5zdGVwKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIocmNTbGljZS5jb2wpKSB7XG4gICAgICB2YXIgY29sID0galN0YXQuY29sYShsaXN0LCByY1NsaWNlLmNvbCk7XG4gICAgICByb3dTbGljZSA9IHJjU2xpY2Uucm93IHx8IHt9O1xuICAgICAgcmV0dXJuIF9zbGljZShjb2wsIHJvd1NsaWNlLnN0YXJ0LCByb3dTbGljZS5lbmQsIHJvd1NsaWNlLnN0ZXApO1xuICAgIH1cblxuICAgIHJvd1NsaWNlID0gcmNTbGljZS5yb3cgfHwge307XG4gICAgY29sU2xpY2UgPSByY1NsaWNlLmNvbCB8fCB7fTtcbiAgICB2YXIgcm93cyA9IF9zbGljZShsaXN0LCByb3dTbGljZS5zdGFydCwgcm93U2xpY2UuZW5kLCByb3dTbGljZS5zdGVwKTtcbiAgICByZXR1cm4gcm93cy5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICByZXR1cm4gX3NsaWNlKHJvdywgY29sU2xpY2Uuc3RhcnQsIGNvbFNsaWNlLmVuZCwgY29sU2xpY2Uuc3RlcCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc2xpY2U7XG59KCkpO1xuXG5cbi8vIEE9W1sxLDIsM10sWzQsNSw2XSxbNyw4LDldXVxuLy8gc2xpY2VBc3NpZ24oQSx7cm93OntzdGFydDoxfSxjb2w6e3N0YXJ0OjF9fSxbWzAsMF0sWzAsMF1dKVxuLy8gQT1bWzEsMiwzXSxbNCwwLDBdLFs3LDAsMF1dXG5qU3RhdC5zbGljZUFzc2lnbiA9IGZ1bmN0aW9uIHNsaWNlQXNzaWduKEEsIHJjU2xpY2UsIEIpIHtcbiAgdmFyIG5sLCBtbDtcbiAgaWYgKGlzTnVtYmVyKHJjU2xpY2Uucm93KSkge1xuICAgIGlmIChpc051bWJlcihyY1NsaWNlLmNvbCkpXG4gICAgICByZXR1cm4gQVtyY1NsaWNlLnJvd11bcmNTbGljZS5jb2xdID0gQjtcbiAgICByY1NsaWNlLmNvbCA9IHJjU2xpY2UuY29sIHx8IHt9O1xuICAgIHJjU2xpY2UuY29sLnN0YXJ0ID0gcmNTbGljZS5jb2wuc3RhcnQgfHwgMDtcbiAgICByY1NsaWNlLmNvbC5lbmQgPSByY1NsaWNlLmNvbC5lbmQgfHwgQVswXS5sZW5ndGg7XG4gICAgcmNTbGljZS5jb2wuc3RlcCA9IHJjU2xpY2UuY29sLnN0ZXAgfHwgMTtcbiAgICBubCA9IGpTdGF0LmFyYW5nZShyY1NsaWNlLmNvbC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oQS5sZW5ndGgsIHJjU2xpY2UuY29sLmVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJjU2xpY2UuY29sLnN0ZXApO1xuICAgIHZhciBtID0gcmNTbGljZS5yb3c7XG4gICAgbmwuZm9yRWFjaChmdW5jdGlvbihuLCBpKSB7XG4gICAgICBBW21dW25dID0gQltpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gQTtcbiAgfVxuXG4gIGlmIChpc051bWJlcihyY1NsaWNlLmNvbCkpIHtcbiAgICByY1NsaWNlLnJvdyA9IHJjU2xpY2Uucm93IHx8IHt9O1xuICAgIHJjU2xpY2Uucm93LnN0YXJ0ID0gcmNTbGljZS5yb3cuc3RhcnQgfHwgMDtcbiAgICByY1NsaWNlLnJvdy5lbmQgPSByY1NsaWNlLnJvdy5lbmQgfHwgQS5sZW5ndGg7XG4gICAgcmNTbGljZS5yb3cuc3RlcCA9IHJjU2xpY2Uucm93LnN0ZXAgfHwgMTtcbiAgICBtbCA9IGpTdGF0LmFyYW5nZShyY1NsaWNlLnJvdy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oQVswXS5sZW5ndGgsIHJjU2xpY2Uucm93LmVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJjU2xpY2Uucm93LnN0ZXApO1xuICAgIHZhciBuID0gcmNTbGljZS5jb2w7XG4gICAgbWwuZm9yRWFjaChmdW5jdGlvbihtLCBqKSB7XG4gICAgICBBW21dW25dID0gQltqXTtcbiAgICB9KTtcbiAgICByZXR1cm4gQTtcbiAgfVxuXG4gIGlmIChCWzBdLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgQiA9IFtCXTtcbiAgfVxuICByY1NsaWNlLnJvdy5zdGFydCA9IHJjU2xpY2Uucm93LnN0YXJ0IHx8IDA7XG4gIHJjU2xpY2Uucm93LmVuZCA9IHJjU2xpY2Uucm93LmVuZCB8fCBBLmxlbmd0aDtcbiAgcmNTbGljZS5yb3cuc3RlcCA9IHJjU2xpY2Uucm93LnN0ZXAgfHwgMTtcbiAgcmNTbGljZS5jb2wuc3RhcnQgPSByY1NsaWNlLmNvbC5zdGFydCB8fCAwO1xuICByY1NsaWNlLmNvbC5lbmQgPSByY1NsaWNlLmNvbC5lbmQgfHwgQVswXS5sZW5ndGg7XG4gIHJjU2xpY2UuY29sLnN0ZXAgPSByY1NsaWNlLmNvbC5zdGVwIHx8IDE7XG4gIG1sID0galN0YXQuYXJhbmdlKHJjU2xpY2Uucm93LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oQS5sZW5ndGgsIHJjU2xpY2Uucm93LmVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICByY1NsaWNlLnJvdy5zdGVwKTtcbiAgbmwgPSBqU3RhdC5hcmFuZ2UocmNTbGljZS5jb2wuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihBWzBdLmxlbmd0aCwgcmNTbGljZS5jb2wuZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJjU2xpY2UuY29sLnN0ZXApO1xuICBtbC5mb3JFYWNoKGZ1bmN0aW9uKG0sIGkpIHtcbiAgICBubC5mb3JFYWNoKGZ1bmN0aW9uKG4sIGopIHtcbiAgICAgIEFbbV1bbl0gPSBCW2ldW2pdO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIEE7XG59O1xuXG5cbi8vIFsxLDIsM10gLT5cbi8vIFtbMSwwLDBdLFswLDIsMF0sWzAsMCwzXV1cbmpTdGF0LmRpYWdvbmFsID0gZnVuY3Rpb24gZGlhZ29uYWwoZGlhZ0FycmF5KSB7XG4gIHZhciBtYXQgPSBqU3RhdC56ZXJvcyhkaWFnQXJyYXkubGVuZ3RoLCBkaWFnQXJyYXkubGVuZ3RoKTtcbiAgZGlhZ0FycmF5LmZvckVhY2goZnVuY3Rpb24odCwgaSkge1xuICAgIG1hdFtpXVtpXSA9IHQ7XG4gIH0pO1xuICByZXR1cm4gbWF0O1xufTtcblxuXG4vLyByZXR1cm4gY29weSBvZiBBXG5qU3RhdC5jb3B5ID0gZnVuY3Rpb24gY29weShBKSB7XG4gIHJldHVybiBBLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICBpZiAoaXNOdW1iZXIocm93KSlcbiAgICAgIHJldHVybiByb3c7XG4gICAgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuXG4vLyBUT0RPOiBHbyBvdmVyIHRoaXMgZW50aXJlIGltcGxlbWVudGF0aW9uLiBTZWVtcyBhIHRyYWdpYyB3YXN0ZSBvZiByZXNvdXJjZXNcbi8vIGRvaW5nIGFsbCB0aGlzIHdvcmsuIEluc3RlYWQsIGFuZCB3aGlsZSB1Z2x5LCB1c2UgbmV3IEZ1bmN0aW9uKCkgdG8gZ2VuZXJhdGVcbi8vIGEgY3VzdG9tIGZ1bmN0aW9uIGZvciBlYWNoIHN0YXRpYyBtZXRob2QuXG5cbi8vIFF1aWNrIHJlZmVyZW5jZS5cbnZhciBqUHJvdG8gPSBqU3RhdC5wcm90b3R5cGU7XG5cbi8vIERlZmF1bHQgbGVuZ3RoLlxualByb3RvLmxlbmd0aCA9IDA7XG5cbi8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbi8vIFRPRE86IENoZWNrIGlmIHRoZXkncmUgYWN0dWFsbHkgdXNlZCwgYW5kIGlmIHRoZXkgYXJlIHRoZW4gcmVuYW1lIHRoZW1cbi8vIHRvIF8qXG5qUHJvdG8ucHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xualByb3RvLnNvcnQgPSBBcnJheS5wcm90b3R5cGUuc29ydDtcbmpQcm90by5zcGxpY2UgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xualByb3RvLnNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5cbi8vIFJldHVybiBhIGNsZWFuIGFycmF5LlxualByb3RvLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCh0aGlzKSA6IHNsaWNlLmNhbGwodGhpcylbMF07XG59O1xuXG5cbi8vIE1hcCBhIGZ1bmN0aW9uIHRvIGEgbWF0cml4IG9yIHZlY3Rvci5cbmpQcm90by5tYXAgPSBmdW5jdGlvbiBtYXAoZnVuYywgdG9BbHRlcikge1xuICByZXR1cm4galN0YXQoalN0YXQubWFwKHRoaXMsIGZ1bmMsIHRvQWx0ZXIpKTtcbn07XG5cblxuLy8gQ3VtdWxhdGl2ZWx5IGNvbWJpbmUgdGhlIGVsZW1lbnRzIG9mIGEgbWF0cml4IG9yIHZlY3RvciB1c2luZyBhIGZ1bmN0aW9uLlxualByb3RvLmN1bXJlZHVjZSA9IGZ1bmN0aW9uIGN1bXJlZHVjZShmdW5jLCB0b0FsdGVyKSB7XG4gIHJldHVybiBqU3RhdChqU3RhdC5jdW1yZWR1Y2UodGhpcywgZnVuYywgdG9BbHRlcikpO1xufTtcblxuXG4vLyBEZXN0cnVjdGl2ZWx5IGFsdGVyIGFuIGFycmF5LlxualByb3RvLmFsdGVyID0gZnVuY3Rpb24gYWx0ZXIoZnVuYykge1xuICBqU3RhdC5hbHRlcih0aGlzLCBmdW5jKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIEV4dGVuZCBwcm90b3R5cGUgd2l0aCBtZXRob2RzIHRoYXQgaGF2ZSBubyBhcmd1bWVudC5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgcmVzdWx0cztcbiAgICAgIC8vIENoZWNrIGZvciBjYWxsYmFjay5cbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuYy5jYWxsKHNlbGYsIGpQcm90b1twYXNzZnVuY10uY2FsbChzZWxmKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMgPSBqU3RhdFtwYXNzZnVuY10odGhpcyk7XG4gICAgICByZXR1cm4gaXNBcnJheShyZXN1bHRzKSA/IGpTdGF0KHJlc3VsdHMpIDogcmVzdWx0cztcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgndHJhbnNwb3NlIGNsZWFyIHN5bW1ldHJpYyByb3dzIGNvbHMgZGltZW5zaW9ucyBkaWFnIGFudGlkaWFnJy5zcGxpdCgnICcpKTtcblxuXG4vLyBFeHRlbmQgcHJvdG90eXBlIHdpdGggbWV0aG9kcyB0aGF0IGhhdmUgb25lIGFyZ3VtZW50LlxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpQcm90b1twYXNzZnVuY10gPSBmdW5jdGlvbihpbmRleCwgZnVuYykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgLy8gY2hlY2sgZm9yIGNhbGxiYWNrXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmMuY2FsbChzZWxmLCBqUHJvdG9bcGFzc2Z1bmNdLmNhbGwoc2VsZiwgaW5kZXgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpTdGF0KGpTdGF0W3Bhc3NmdW5jXSh0aGlzLCBpbmRleCkpO1xuICAgIH07XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCdyb3cgY29sJy5zcGxpdCgnICcpKTtcblxuXG4vLyBFeHRlbmQgcHJvdG90eXBlIHdpdGggc2ltcGxlIHNob3J0Y3V0IG1ldGhvZHMuXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalByb3RvW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGpTdGF0KGpTdGF0W3Bhc3NmdW5jXS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgnY3JlYXRlIHplcm9zIG9uZXMgcmFuZCBpZGVudGl0eScuc3BsaXQoJyAnKSk7XG5cblxuLy8gRXhwb3NpbmcgalN0YXQuXG5yZXR1cm4galN0YXQ7XG5cbn0oTWF0aCkpO1xuKGZ1bmN0aW9uKGpTdGF0LCBNYXRoKSB7XG5cbnZhciBpc0Z1bmN0aW9uID0galN0YXQudXRpbHMuaXNGdW5jdGlvbjtcblxuLy8gQXNjZW5kaW5nIGZ1bmN0aW9ucyBmb3Igc29ydFxuZnVuY3Rpb24gYXNjTnVtKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9XG5cbmZ1bmN0aW9uIGNsaXAoYXJnLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihhcmcsIG1heCkpO1xufVxuXG5cbi8vIHN1bSBvZiBhbiBhcnJheVxualN0YXQuc3VtID0gZnVuY3Rpb24gc3VtKGFycikge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoLS1pID49IDApXG4gICAgc3VtICs9IGFycltpXTtcbiAgcmV0dXJuIHN1bTtcbn07XG5cblxuLy8gc3VtIHNxdWFyZWRcbmpTdGF0LnN1bXNxcmQgPSBmdW5jdGlvbiBzdW1zcXJkKGFycikge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoLS1pID49IDApXG4gICAgc3VtICs9IGFycltpXSAqIGFycltpXTtcbiAgcmV0dXJuIHN1bTtcbn07XG5cblxuLy8gc3VtIG9mIHNxdWFyZWQgZXJyb3JzIG9mIHByZWRpY3Rpb24gKFNTRSlcbmpTdGF0LnN1bXNxZXJyID0gZnVuY3Rpb24gc3Vtc3FlcnIoYXJyKSB7XG4gIHZhciBtZWFuID0galN0YXQubWVhbihhcnIpO1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB2YXIgdG1wO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICB0bXAgPSBhcnJbaV0gLSBtZWFuO1xuICAgIHN1bSArPSB0bXAgKiB0bXA7XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIHN1bSBvZiBhbiBhcnJheSBpbiBlYWNoIHJvd1xualN0YXQuc3Vtcm93ID0gZnVuY3Rpb24gc3Vtcm93KGFycikge1xuICB2YXIgc3VtID0gMDtcbiAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoLS1pID49IDApXG4gICAgc3VtICs9IGFycltpXTtcbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIHByb2R1Y3Qgb2YgYW4gYXJyYXlcbmpTdGF0LnByb2R1Y3QgPSBmdW5jdGlvbiBwcm9kdWN0KGFycikge1xuICB2YXIgcHJvZCA9IDE7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKC0taSA+PSAwKVxuICAgIHByb2QgKj0gYXJyW2ldO1xuICByZXR1cm4gcHJvZDtcbn07XG5cblxuLy8gbWluaW11bSB2YWx1ZSBvZiBhbiBhcnJheVxualN0YXQubWluID0gZnVuY3Rpb24gbWluKGFycikge1xuICB2YXIgbG93ID0gYXJyWzBdO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBhcnIubGVuZ3RoKVxuICAgIGlmIChhcnJbaV0gPCBsb3cpXG4gICAgICBsb3cgPSBhcnJbaV07XG4gIHJldHVybiBsb3c7XG59O1xuXG5cbi8vIG1heGltdW0gdmFsdWUgb2YgYW4gYXJyYXlcbmpTdGF0Lm1heCA9IGZ1bmN0aW9uIG1heChhcnIpIHtcbiAgdmFyIGhpZ2ggPSBhcnJbMF07XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGFyci5sZW5ndGgpXG4gICAgaWYgKGFycltpXSA+IGhpZ2gpXG4gICAgICBoaWdoID0gYXJyW2ldO1xuICByZXR1cm4gaGlnaDtcbn07XG5cblxuLy8gdW5pcXVlIHZhbHVlcyBvZiBhbiBhcnJheVxualN0YXQudW5pcXVlID0gZnVuY3Rpb24gdW5pcXVlKGFycikge1xuICB2YXIgaGFzaCA9IHt9LCBfYXJyID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc2hbYXJyW2ldXSkge1xuICAgICAgaGFzaFthcnJbaV1dID0gdHJ1ZTtcbiAgICAgIF9hcnIucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2Fycjtcbn07XG5cblxuLy8gbWVhbiB2YWx1ZSBvZiBhbiBhcnJheVxualN0YXQubWVhbiA9IGZ1bmN0aW9uIG1lYW4oYXJyKSB7XG4gIHJldHVybiBqU3RhdC5zdW0oYXJyKSAvIGFyci5sZW5ndGg7XG59O1xuXG5cbi8vIG1lYW4gc3F1YXJlZCBlcnJvciAoTVNFKVxualN0YXQubWVhbnNxZXJyID0gZnVuY3Rpb24gbWVhbnNxZXJyKGFycikge1xuICByZXR1cm4galN0YXQuc3Vtc3FlcnIoYXJyKSAvIGFyci5sZW5ndGg7XG59O1xuXG5cbi8vIGdlb21ldHJpYyBtZWFuIG9mIGFuIGFycmF5XG5qU3RhdC5nZW9tZWFuID0gZnVuY3Rpb24gZ2VvbWVhbihhcnIpIHtcbiAgdmFyIGxvZ3MgPSBhcnIubWFwKE1hdGgubG9nKVxuICB2YXIgbWVhbk9mTG9ncyA9IGpTdGF0Lm1lYW4obG9ncylcbiAgcmV0dXJuIE1hdGguZXhwKG1lYW5PZkxvZ3MpXG59O1xuXG5cbi8vIG1lZGlhbiBvZiBhbiBhcnJheVxualN0YXQubWVkaWFuID0gZnVuY3Rpb24gbWVkaWFuKGFycikge1xuICB2YXIgYXJybGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIF9hcnIgPSBhcnIuc2xpY2UoKS5zb3J0KGFzY051bSk7XG4gIC8vIGNoZWNrIGlmIGFycmF5IGlzIGV2ZW4gb3Igb2RkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGVcbiAgcmV0dXJuICEoYXJybGVuICYgMSlcbiAgICA/IChfYXJyWyhhcnJsZW4gLyAyKSAtIDEgXSArIF9hcnJbKGFycmxlbiAvIDIpXSkgLyAyXG4gICAgOiBfYXJyWyhhcnJsZW4gLyAyKSB8IDAgXTtcbn07XG5cblxuLy8gY3VtdWxhdGl2ZSBzdW0gb2YgYW4gYXJyYXlcbmpTdGF0LmN1bXN1bSA9IGZ1bmN0aW9uIGN1bXN1bShhcnIpIHtcbiAgcmV0dXJuIGpTdGF0LmN1bXJlZHVjZShhcnIsIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYjsgfSk7XG59O1xuXG5cbi8vIGN1bXVsYXRpdmUgcHJvZHVjdCBvZiBhbiBhcnJheVxualN0YXQuY3VtcHJvZCA9IGZ1bmN0aW9uIGN1bXByb2QoYXJyKSB7XG4gIHJldHVybiBqU3RhdC5jdW1yZWR1Y2UoYXJyLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAqIGI7IH0pO1xufTtcblxuXG4vLyBzdWNjZXNzaXZlIGRpZmZlcmVuY2VzIG9mIGEgc2VxdWVuY2VcbmpTdGF0LmRpZmYgPSBmdW5jdGlvbiBkaWZmKGFycikge1xuICB2YXIgZGlmZnMgPSBbXTtcbiAgdmFyIGFyckxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAxOyBpIDwgYXJyTGVuOyBpKyspXG4gICAgZGlmZnMucHVzaChhcnJbaV0gLSBhcnJbaSAtIDFdKTtcbiAgcmV0dXJuIGRpZmZzO1xufTtcblxuXG4vLyByYW5rcyBvZiBhbiBhcnJheVxualN0YXQucmFuayA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIGk7XG4gIHZhciBkaXN0aW5jdE51bWJlcnMgPSBbXTtcbiAgdmFyIG51bWJlckNvdW50cyA9IHt9O1xuICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG51bWJlciA9IGFycltpXTtcbiAgICBpZiAobnVtYmVyQ291bnRzW251bWJlcl0pIHtcbiAgICAgIG51bWJlckNvdW50c1tudW1iZXJdKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bWJlckNvdW50c1tudW1iZXJdID0gMTtcbiAgICAgIGRpc3RpbmN0TnVtYmVycy5wdXNoKG51bWJlcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNvcnRlZERpc3RpbmN0TnVtYmVycyA9IGRpc3RpbmN0TnVtYmVycy5zb3J0KGFzY051bSk7XG4gIHZhciBudW1iZXJSYW5rcyA9IHt9O1xuICB2YXIgY3VycmVudFJhbmsgPSAxO1xuICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkRGlzdGluY3ROdW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG51bWJlciA9IHNvcnRlZERpc3RpbmN0TnVtYmVyc1tpXTtcbiAgICB2YXIgY291bnQgPSBudW1iZXJDb3VudHNbbnVtYmVyXTtcbiAgICB2YXIgZmlyc3QgPSBjdXJyZW50UmFuaztcbiAgICB2YXIgbGFzdCA9IGN1cnJlbnRSYW5rICsgY291bnQgLSAxO1xuICAgIHZhciByYW5rID0gKGZpcnN0ICsgbGFzdCkgLyAyO1xuICAgIG51bWJlclJhbmtzW251bWJlcl0gPSByYW5rO1xuICAgIGN1cnJlbnRSYW5rICs9IGNvdW50O1xuICB9XG5cbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHJldHVybiBudW1iZXJSYW5rc1tudW1iZXJdO1xuICB9KTtcbn07XG5cblxuLy8gbW9kZSBvZiBhbiBhcnJheVxuLy8gaWYgdGhlcmUgYXJlIG11bHRpcGxlIG1vZGVzIG9mIGFuIGFycmF5LCByZXR1cm4gYWxsIG9mIHRoZW1cbi8vIGlzIHRoaXMgdGhlIGFwcHJvcHJpYXRlIHdheSBvZiBoYW5kbGluZyBpdD9cbmpTdGF0Lm1vZGUgPSBmdW5jdGlvbiBtb2RlKGFycikge1xuICB2YXIgYXJyTGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIF9hcnIgPSBhcnIuc2xpY2UoKS5zb3J0KGFzY051bSk7XG4gIHZhciBjb3VudCA9IDE7XG4gIHZhciBtYXhDb3VudCA9IDA7XG4gIHZhciBudW1NYXhDb3VudCA9IDA7XG4gIHZhciBtb2RlX2FyciA9IFtdO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYXJyTGVuOyBpKyspIHtcbiAgICBpZiAoX2FycltpXSA9PT0gX2FycltpICsgMV0pIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb3VudCA+IG1heENvdW50KSB7XG4gICAgICAgIG1vZGVfYXJyID0gW19hcnJbaV1dO1xuICAgICAgICBtYXhDb3VudCA9IGNvdW50O1xuICAgICAgICBudW1NYXhDb3VudCA9IDA7XG4gICAgICB9XG4gICAgICAvLyBhcmUgdGhlcmUgbXVsdGlwbGUgbWF4IGNvdW50c1xuICAgICAgZWxzZSBpZiAoY291bnQgPT09IG1heENvdW50KSB7XG4gICAgICAgIG1vZGVfYXJyLnB1c2goX2FycltpXSk7XG4gICAgICAgIG51bU1heENvdW50Kys7XG4gICAgICB9XG4gICAgICAvLyByZXNldHRpbmcgY291bnQgZm9yIG5ldyB2YWx1ZSBpbiBhcnJheVxuICAgICAgY291bnQgPSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudW1NYXhDb3VudCA9PT0gMCA/IG1vZGVfYXJyWzBdIDogbW9kZV9hcnI7XG59O1xuXG5cbi8vIHJhbmdlIG9mIGFuIGFycmF5XG5qU3RhdC5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGFycikge1xuICByZXR1cm4galN0YXQubWF4KGFycikgLSBqU3RhdC5taW4oYXJyKTtcbn07XG5cbi8vIHZhcmlhbmNlIG9mIGFuIGFycmF5XG4vLyBmbGFnID0gdHJ1ZSBpbmRpY2F0ZXMgc2FtcGxlIGluc3RlYWQgb2YgcG9wdWxhdGlvblxualN0YXQudmFyaWFuY2UgPSBmdW5jdGlvbiB2YXJpYW5jZShhcnIsIGZsYWcpIHtcbiAgcmV0dXJuIGpTdGF0LnN1bXNxZXJyKGFycikgLyAoYXJyLmxlbmd0aCAtIChmbGFnID8gMSA6IDApKTtcbn07XG5cbi8vIHBvb2xlZCB2YXJpYW5jZSBvZiBhbiBhcnJheSBvZiBhcnJheXNcbmpTdGF0LnBvb2xlZHZhcmlhbmNlID0gZnVuY3Rpb24gcG9vbGVkdmFyaWFuY2UoYXJyKSB7XG4gIHZhciBzdW1zcWVyciA9IGFyci5yZWR1Y2UoZnVuY3Rpb24gKGEsIHNhbXBsZXMpIHtyZXR1cm4gYSArIGpTdGF0LnN1bXNxZXJyKHNhbXBsZXMpO30sIDApO1xuICB2YXIgY291bnQgPSBhcnIucmVkdWNlKGZ1bmN0aW9uIChhLCBzYW1wbGVzKSB7cmV0dXJuIGEgKyBzYW1wbGVzLmxlbmd0aDt9LCAwKTtcbiAgcmV0dXJuIHN1bXNxZXJyIC8gKGNvdW50IC0gYXJyLmxlbmd0aCk7XG59O1xuXG4vLyBkZXZpYXRpb24gb2YgYW4gYXJyYXlcbmpTdGF0LmRldmlhdGlvbiA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKGFycik7XG4gIHZhciBhcnJsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgZGV2ID0gbmV3IEFycmF5KGFycmxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJybGVuOyBpKyspIHtcbiAgICBkZXZbaV0gPSBhcnJbaV0gLSBtZWFuO1xuICB9XG4gIHJldHVybiBkZXY7XG59O1xuXG4vLyBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYW4gYXJyYXlcbi8vIGZsYWcgPSB0cnVlIGluZGljYXRlcyBzYW1wbGUgaW5zdGVhZCBvZiBwb3B1bGF0aW9uXG5qU3RhdC5zdGRldiA9IGZ1bmN0aW9uIHN0ZGV2KGFyciwgZmxhZykge1xuICByZXR1cm4gTWF0aC5zcXJ0KGpTdGF0LnZhcmlhbmNlKGFyciwgZmxhZykpO1xufTtcblxuLy8gcG9vbGVkIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheSBvZiBhcnJheXNcbmpTdGF0LnBvb2xlZHN0ZGV2ID0gZnVuY3Rpb24gcG9vbGVkc3RkZXYoYXJyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoalN0YXQucG9vbGVkdmFyaWFuY2UoYXJyKSk7XG59O1xuXG4vLyBtZWFuIGRldmlhdGlvbiAobWVhbiBhYnNvbHV0ZSBkZXZpYXRpb24pIG9mIGFuIGFycmF5XG5qU3RhdC5tZWFuZGV2ID0gZnVuY3Rpb24gbWVhbmRldihhcnIpIHtcbiAgdmFyIG1lYW4gPSBqU3RhdC5tZWFuKGFycik7XG4gIHZhciBhID0gW107XG4gIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBhLnB1c2goTWF0aC5hYnMoYXJyW2ldIC0gbWVhbikpO1xuICB9XG4gIHJldHVybiBqU3RhdC5tZWFuKGEpO1xufTtcblxuXG4vLyBtZWRpYW4gZGV2aWF0aW9uIChtZWRpYW4gYWJzb2x1dGUgZGV2aWF0aW9uKSBvZiBhbiBhcnJheVxualN0YXQubWVkZGV2ID0gZnVuY3Rpb24gbWVkZGV2KGFycikge1xuICB2YXIgbWVkaWFuID0galN0YXQubWVkaWFuKGFycik7XG4gIHZhciBhID0gW107XG4gIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBhLnB1c2goTWF0aC5hYnMoYXJyW2ldIC0gbWVkaWFuKSk7XG4gIH1cbiAgcmV0dXJuIGpTdGF0Lm1lZGlhbihhKTtcbn07XG5cblxuLy8gY29lZmZpY2llbnQgb2YgdmFyaWF0aW9uXG5qU3RhdC5jb2VmZnZhciA9IGZ1bmN0aW9uIGNvZWZmdmFyKGFycikge1xuICByZXR1cm4galN0YXQuc3RkZXYoYXJyKSAvIGpTdGF0Lm1lYW4oYXJyKTtcbn07XG5cblxuLy8gcXVhcnRpbGVzIG9mIGFuIGFycmF5XG5qU3RhdC5xdWFydGlsZXMgPSBmdW5jdGlvbiBxdWFydGlsZXMoYXJyKSB7XG4gIHZhciBhcnJsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgX2FyciA9IGFyci5zbGljZSgpLnNvcnQoYXNjTnVtKTtcbiAgcmV0dXJuIFtcbiAgICBfYXJyWyBNYXRoLnJvdW5kKChhcnJsZW4pIC8gNCkgLSAxIF0sXG4gICAgX2FyclsgTWF0aC5yb3VuZCgoYXJybGVuKSAvIDIpIC0gMSBdLFxuICAgIF9hcnJbIE1hdGgucm91bmQoKGFycmxlbikgKiAzIC8gNCkgLSAxIF1cbiAgXTtcbn07XG5cblxuLy8gQXJiaXRhcnkgcXVhbnRpbGVzIG9mIGFuIGFycmF5LiBEaXJlY3QgcG9ydCBvZiB0aGUgc2NpcHkuc3RhdHNcbi8vIGltcGxlbWVudGF0aW9uIGJ5IFBpZXJyZSBHRiBHZXJhcmQtTWFyY2hhbnQuXG5qU3RhdC5xdWFudGlsZXMgPSBmdW5jdGlvbiBxdWFudGlsZXMoYXJyLCBxdWFudGlsZXNBcnJheSwgYWxwaGFwLCBiZXRhcCkge1xuICB2YXIgc29ydGVkQXJyYXkgPSBhcnIuc2xpY2UoKS5zb3J0KGFzY051bSk7XG4gIHZhciBxdWFudGlsZVZhbHMgPSBbcXVhbnRpbGVzQXJyYXkubGVuZ3RoXTtcbiAgdmFyIG4gPSBhcnIubGVuZ3RoO1xuICB2YXIgaSwgcCwgbSwgYWxlcGgsIGssIGdhbW1hO1xuXG4gIGlmICh0eXBlb2YgYWxwaGFwID09PSAndW5kZWZpbmVkJylcbiAgICBhbHBoYXAgPSAzIC8gODtcbiAgaWYgKHR5cGVvZiBiZXRhcCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgYmV0YXAgPSAzIC8gODtcblxuICBmb3IgKGkgPSAwOyBpIDwgcXVhbnRpbGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBwID0gcXVhbnRpbGVzQXJyYXlbaV07XG4gICAgbSA9IGFscGhhcCArIHAgKiAoMSAtIGFscGhhcCAtIGJldGFwKTtcbiAgICBhbGVwaCA9IG4gKiBwICsgbTtcbiAgICBrID0gTWF0aC5mbG9vcihjbGlwKGFsZXBoLCAxLCBuIC0gMSkpO1xuICAgIGdhbW1hID0gY2xpcChhbGVwaCAtIGssIDAsIDEpO1xuICAgIHF1YW50aWxlVmFsc1tpXSA9ICgxIC0gZ2FtbWEpICogc29ydGVkQXJyYXlbayAtIDFdICsgZ2FtbWEgKiBzb3J0ZWRBcnJheVtrXTtcbiAgfVxuXG4gIHJldHVybiBxdWFudGlsZVZhbHM7XG59O1xuXG4vLyBSZXR1cm4gdGhlIGstdGggcGVyY2VudGlsZSBvZiB2YWx1ZXMgaW4gYSByYW5nZSwgd2hlcmUgayBpcyBpbiB0aGUgcmFuZ2UgMC4uMSwgaW5jbHVzaXZlLlxuLy8gUGFzc2luZyB0cnVlIGZvciB0aGUgZXhjbHVzaXZlIHBhcmFtZXRlciBleGNsdWRlcyBib3RoIGVuZHBvaW50cyBvZiB0aGUgcmFuZ2UuXG5qU3RhdC5wZXJjZW50aWxlID0gZnVuY3Rpb24gcGVyY2VudGlsZShhcnIsIGssIGV4Y2x1c2l2ZSkge1xuICB2YXIgX2FyciA9IGFyci5zbGljZSgpLnNvcnQoYXNjTnVtKTtcbiAgdmFyIHJlYWxJbmRleCA9IGsgKiAoX2Fyci5sZW5ndGggKyAoZXhjbHVzaXZlID8gMSA6IC0xKSkgKyAoZXhjbHVzaXZlID8gMCA6IDEpO1xuICB2YXIgaW5kZXggPSBwYXJzZUludChyZWFsSW5kZXgpO1xuICB2YXIgZnJhYyA9IHJlYWxJbmRleCAtIGluZGV4O1xuICBpZiAoaW5kZXggKyAxIDwgX2Fyci5sZW5ndGgpIHtcbiAgICByZXR1cm4gX2FycltpbmRleCAtIDFdICsgZnJhYyAqIChfYXJyW2luZGV4XSAtIF9hcnJbaW5kZXggLSAxXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIF9hcnJbaW5kZXggLSAxXTtcbiAgfVxufVxuXG4vLyBUaGUgcGVyY2VudGlsZSByYW5rIG9mIHNjb3JlIGluIGEgZ2l2ZW4gYXJyYXkuIFJldHVybnMgdGhlIHBlcmNlbnRhZ2Vcbi8vIG9mIGFsbCB2YWx1ZXMgaW4gdGhlIGlucHV0IGFycmF5IHRoYXQgYXJlIGxlc3MgdGhhbiAoa2luZD0nc3RyaWN0Jykgb3Jcbi8vIGxlc3Mgb3IgZXF1YWwgdGhhbiAoa2luZD0nd2VhaycpIHNjb3JlLiBEZWZhdWx0IGlzIHdlYWsuXG5qU3RhdC5wZXJjZW50aWxlT2ZTY29yZSA9IGZ1bmN0aW9uIHBlcmNlbnRpbGVPZlNjb3JlKGFyciwgc2NvcmUsIGtpbmQpIHtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHN0cmljdCA9IGZhbHNlO1xuICB2YXIgdmFsdWUsIGk7XG5cbiAgaWYgKGtpbmQgPT09ICdzdHJpY3QnKVxuICAgIHN0cmljdCA9IHRydWU7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJbaV07XG4gICAgaWYgKChzdHJpY3QgJiYgdmFsdWUgPCBzY29yZSkgfHxcbiAgICAgICAgKCFzdHJpY3QgJiYgdmFsdWUgPD0gc2NvcmUpKSB7XG4gICAgICBjb3VudGVyKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvdW50ZXIgLyBsZW47XG59O1xuXG5cbi8vIEhpc3RvZ3JhbSAoYmluIGNvdW50KSBkYXRhXG5qU3RhdC5oaXN0b2dyYW0gPSBmdW5jdGlvbiBoaXN0b2dyYW0oYXJyLCBiaW5DbnQpIHtcbiAgYmluQ250ID0gYmluQ250IHx8IDQ7XG4gIHZhciBmaXJzdCA9IGpTdGF0Lm1pbihhcnIpO1xuICB2YXIgYmluV2lkdGggPSAoalN0YXQubWF4KGFycikgLSBmaXJzdCkgLyBiaW5DbnQ7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgYmlucyA9IFtdO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYmluQ250OyBpKyspXG4gICAgYmluc1tpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICBiaW5zW01hdGgubWluKE1hdGguZmxvb3IoKChhcnJbaV0gLSBmaXJzdCkgLyBiaW5XaWR0aCkpLCBiaW5DbnQgLSAxKV0gKz0gMTtcblxuICByZXR1cm4gYmlucztcbn07XG5cblxuLy8gY292YXJpYW5jZSBvZiB0d28gYXJyYXlzXG5qU3RhdC5jb3ZhcmlhbmNlID0gZnVuY3Rpb24gY292YXJpYW5jZShhcnIxLCBhcnIyKSB7XG4gIHZhciB1ID0galN0YXQubWVhbihhcnIxKTtcbiAgdmFyIHYgPSBqU3RhdC5tZWFuKGFycjIpO1xuICB2YXIgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuICB2YXIgc3FfZGV2ID0gbmV3IEFycmF5KGFycjFMZW4pO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYXJyMUxlbjsgaSsrKVxuICAgIHNxX2RldltpXSA9IChhcnIxW2ldIC0gdSkgKiAoYXJyMltpXSAtIHYpO1xuXG4gIHJldHVybiBqU3RhdC5zdW0oc3FfZGV2KSAvIChhcnIxTGVuIC0gMSk7XG59O1xuXG5cbi8vIChwZWFyc29uJ3MpIHBvcHVsYXRpb24gY29ycmVsYXRpb24gY29lZmZpY2llbnQsIHJob1xualN0YXQuY29ycmNvZWZmID0gZnVuY3Rpb24gY29ycmNvZWZmKGFycjEsIGFycjIpIHtcbiAgcmV0dXJuIGpTdGF0LmNvdmFyaWFuY2UoYXJyMSwgYXJyMikgL1xuICAgICAgalN0YXQuc3RkZXYoYXJyMSwgMSkgL1xuICAgICAgalN0YXQuc3RkZXYoYXJyMiwgMSk7XG59O1xuXG4gIC8vIChzcGVhcm1hbidzKSByYW5rIGNvcnJlbGF0aW9uIGNvZWZmaWNpZW50LCBzcFxualN0YXQuc3BlYXJtYW5jb2VmZiA9ICBmdW5jdGlvbiAoYXJyMSwgYXJyMikge1xuICBhcnIxID0galN0YXQucmFuayhhcnIxKTtcbiAgYXJyMiA9IGpTdGF0LnJhbmsoYXJyMik7XG4gIC8vcmV0dXJuIHBlYXJzb24ncyBjb3JyZWxhdGlvbiBvZiB0aGUgcmFua3M6XG4gIHJldHVybiBqU3RhdC5jb3JyY29lZmYoYXJyMSwgYXJyMik7XG59XG5cblxuLy8gc3RhdGlzdGljYWwgc3RhbmRhcmRpemVkIG1vbWVudHMgKGdlbmVyYWwgZm9ybSBvZiBza2V3L2t1cnQpXG5qU3RhdC5zdGFuTW9tZW50ID0gZnVuY3Rpb24gc3Rhbk1vbWVudChhcnIsIG4pIHtcbiAgdmFyIG11ID0galN0YXQubWVhbihhcnIpO1xuICB2YXIgc2lnbWEgPSBqU3RhdC5zdGRldihhcnIpO1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHNrZXdTdW0gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgc2tld1N1bSArPSBNYXRoLnBvdygoYXJyW2ldIC0gbXUpIC8gc2lnbWEsIG4pO1xuXG4gIHJldHVybiBza2V3U3VtIC8gYXJyLmxlbmd0aDtcbn07XG5cbi8vIChwZWFyc29uJ3MpIG1vbWVudCBjb2VmZmljaWVudCBvZiBza2V3bmVzc1xualN0YXQuc2tld25lc3MgPSBmdW5jdGlvbiBza2V3bmVzcyhhcnIpIHtcbiAgcmV0dXJuIGpTdGF0LnN0YW5Nb21lbnQoYXJyLCAzKTtcbn07XG5cbi8vIChwZWFyc29uJ3MpIChleGNlc3MpIGt1cnRvc2lzXG5qU3RhdC5rdXJ0b3NpcyA9IGZ1bmN0aW9uIGt1cnRvc2lzKGFycikge1xuICByZXR1cm4galN0YXQuc3Rhbk1vbWVudChhcnIsIDQpIC0gMztcbn07XG5cblxudmFyIGpQcm90byA9IGpTdGF0LnByb3RvdHlwZTtcblxuXG4vLyBFeHRlbmQgalByb3RvIHdpdGggbWV0aG9kIGZvciBjYWxjdWxhdGluZyBjdW11bGF0aXZlIHN1bXMgYW5kIHByb2R1Y3RzLlxuLy8gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHNpbWlsYXIgZXh0ZW5zaW9uIGJlbG93IGFzIGN1bXN1bSBhbmQgY3VtcHJvZCBzaG91bGRcbi8vIG5vdCBiZSBydW4gYWdhaW4gaW4gdGhlIGNhc2UgZnVsbGJvb2wgPT09IHRydWUuXG4vLyBJZiBhIG1hdHJpeCBpcyBwYXNzZWQsIGF1dG9tYXRpY2FsbHkgYXNzdW1lIG9wZXJhdGlvbiBzaG91bGQgYmUgZG9uZSBvbiB0aGVcbi8vIGNvbHVtbnMuXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgLy8gSWYgYSBtYXRyaXggaXMgcGFzc2VkLCBhdXRvbWF0aWNhbGx5IGFzc3VtZSBvcGVyYXRpb24gc2hvdWxkIGJlIGRvbmUgb25cbiAgICAvLyB0aGUgY29sdW1ucy5cbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gZnVuY3Rpb24oZnVsbGJvb2wsIGZ1bmMpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciB0bXB0aGlzID0gdGhpcztcbiAgICAgIC8vIEFzc2lnbm1lbnQgcmVhc3NpZ25hdGlvbiBkZXBlbmRpbmcgb24gaG93IHBhcmFtZXRlcnMgd2VyZSBwYXNzZWQgaW4uXG4gICAgICBpZiAoaXNGdW5jdGlvbihmdWxsYm9vbCkpIHtcbiAgICAgICAgZnVuYyA9IGZ1bGxib29sO1xuICAgICAgICBmdWxsYm9vbCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgYSBjYWxsYmFjayB3YXMgcGFzc2VkIHdpdGggdGhlIGZ1bmN0aW9uLlxuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jLmNhbGwodG1wdGhpcywgalByb3RvW3Bhc3NmdW5jXS5jYWxsKHRtcHRoaXMsIGZ1bGxib29sKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGlmIG1hdHJpeCBhbmQgcnVuIGNhbGN1bGF0aW9ucy5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdG1wdGhpcyA9IGZ1bGxib29sID09PSB0cnVlID8gdGhpcyA6IHRoaXMudHJhbnNwb3NlKCk7XG4gICAgICAgIGZvciAoOyBpIDwgdG1wdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICBhcnJbaV0gPSBqU3RhdFtwYXNzZnVuY10odG1wdGhpc1tpXSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG4gICAgICAvLyBQYXNzIGZ1bGxib29sIGlmIG9ubHkgdmVjdG9yLCBub3QgYSBtYXRyaXguIGZvciB2YXJpYW5jZSBhbmQgc3RkZXYuXG4gICAgICByZXR1cm4galN0YXRbcGFzc2Z1bmNdKHRoaXNbMF0sIGZ1bGxib29sKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgoJ2N1bXN1bSBjdW1wcm9kJykuc3BsaXQoJyAnKSk7XG5cblxuLy8gRXh0ZW5kIGpQcm90byB3aXRoIG1ldGhvZHMgd2hpY2ggZG9uJ3QgcmVxdWlyZSBhcmd1bWVudHMgYW5kIHdvcmsgb24gY29sdW1ucy5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICAvLyBJZiBhIG1hdHJpeCBpcyBwYXNzZWQsIGF1dG9tYXRpY2FsbHkgYXNzdW1lIG9wZXJhdGlvbiBzaG91bGQgYmUgZG9uZSBvblxuICAgIC8vIHRoZSBjb2x1bW5zLlxuICAgIGpQcm90b1twYXNzZnVuY10gPSBmdW5jdGlvbihmdWxsYm9vbCwgZnVuYykge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHRtcHRoaXMgPSB0aGlzO1xuICAgICAgLy8gQXNzaWdubWVudCByZWFzc2lnbmF0aW9uIGRlcGVuZGluZyBvbiBob3cgcGFyYW1ldGVycyB3ZXJlIHBhc3NlZCBpbi5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGZ1bGxib29sKSkge1xuICAgICAgICBmdW5jID0gZnVsbGJvb2w7XG4gICAgICAgIGZ1bGxib29sID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiBhIGNhbGxiYWNrIHdhcyBwYXNzZWQgd2l0aCB0aGUgZnVuY3Rpb24uXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmMuY2FsbCh0bXB0aGlzLCBqUHJvdG9bcGFzc2Z1bmNdLmNhbGwodG1wdGhpcywgZnVsbGJvb2wpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgbWF0cml4IGFuZCBydW4gY2FsY3VsYXRpb25zLlxuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAocGFzc2Z1bmMgIT09ICdzdW1yb3cnKVxuICAgICAgICAgIHRtcHRoaXMgPSBmdWxsYm9vbCA9PT0gdHJ1ZSA/IHRoaXMgOiB0aGlzLnRyYW5zcG9zZSgpO1xuICAgICAgICBmb3IgKDsgaSA8IHRtcHRoaXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgYXJyW2ldID0galN0YXRbcGFzc2Z1bmNdKHRtcHRoaXNbaV0pO1xuICAgICAgICByZXR1cm4gZnVsbGJvb2wgPT09IHRydWVcbiAgICAgICAgICAgID8galN0YXRbcGFzc2Z1bmNdKGpTdGF0LnV0aWxzLnRvVmVjdG9yKGFycikpXG4gICAgICAgICAgICA6IGFycjtcbiAgICAgIH1cbiAgICAgIC8vIFBhc3MgZnVsbGJvb2wgaWYgb25seSB2ZWN0b3IsIG5vdCBhIG1hdHJpeC4gZm9yIHZhcmlhbmNlIGFuZCBzdGRldi5cbiAgICAgIHJldHVybiBqU3RhdFtwYXNzZnVuY10odGhpc1swXSwgZnVsbGJvb2wpO1xuICAgIH07XG4gIH0pKGZ1bmNzW2ldKTtcbn0pKCgnc3VtIHN1bXNxcmQgc3Vtc3FlcnIgc3Vtcm93IHByb2R1Y3QgbWluIG1heCB1bmlxdWUgbWVhbiBtZWFuc3FlcnIgJyArXG4gICAgJ2dlb21lYW4gbWVkaWFuIGRpZmYgcmFuayBtb2RlIHJhbmdlIHZhcmlhbmNlIGRldmlhdGlvbiBzdGRldiBtZWFuZGV2ICcgK1xuICAgICdtZWRkZXYgY29lZmZ2YXIgcXVhcnRpbGVzIGhpc3RvZ3JhbSBza2V3bmVzcyBrdXJ0b3NpcycpLnNwbGl0KCcgJykpO1xuXG5cbi8vIEV4dGVuZCBqUHJvdG8gd2l0aCBmdW5jdGlvbnMgdGhhdCB0YWtlIGFyZ3VtZW50cy4gT3BlcmF0aW9ucyBvbiBtYXRyaWNlcyBhcmVcbi8vIGRvbmUgb24gY29sdW1ucy5cbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqUHJvdG9bcGFzc2Z1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgdG1wdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB2YXIgY2FsbGJhY2tGdW5jdGlvbjtcblxuICAgICAgLy8gSWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgYSBmdW5jdGlvbiwgd2UgYXNzdW1lIGl0J3MgYSBjYWxsYmFjazsgd2VcbiAgICAgIC8vIHN0cmlwIHRoZSBjYWxsYmFjayBvdXQgYW5kIGNhbGwgdGhlIGZ1bmN0aW9uIGFnYWluLlxuICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnc1thcmdzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBjYWxsYmFja0Z1bmN0aW9uID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgYXJnc1RvUGFzcyA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrRnVuY3Rpb24uY2FsbCh0bXB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUHJvdG9bcGFzc2Z1bmNdLmFwcGx5KHRtcHRoaXMsIGFyZ3NUb1Bhc3MpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBPdGhlcndpc2Ugd2UgY3VycnkgdGhlIGZ1bmN0aW9uIGFyZ3MgYW5kIGNhbGwgbm9ybWFsbHkuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFja0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY3VycmllZEZ1bmN0aW9uID0gZnVuY3Rpb24gY3VycmllZEZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICAgIHJldHVybiBqU3RhdFtwYXNzZnVuY10uYXBwbHkodG1wdGhpcywgW3ZlY3Rvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgbWF0cml4LCBydW4gY29sdW1uLWJ5LWNvbHVtbi5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdG1wdGhpcyA9IHRtcHRoaXMudHJhbnNwb3NlKCk7XG4gICAgICAgIGZvciAoOyBpIDwgdG1wdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICBhcnJbaV0gPSBjdXJyaWVkRnVuY3Rpb24odG1wdGhpc1tpXSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSBydW4gb24gdGhlIHZlY3Rvci5cbiAgICAgIHJldHVybiBjdXJyaWVkRnVuY3Rpb24odGhpc1swXSk7XG4gICAgfTtcbiAgfSkoZnVuY3NbaV0pO1xufSkoJ3F1YW50aWxlcyBwZXJjZW50aWxlT2ZTY29yZScuc3BsaXQoJyAnKSk7XG5cbn0oalN0YXQsIE1hdGgpKTtcbi8vIFNwZWNpYWwgZnVuY3Rpb25zIC8vXG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxuLy8gTG9nLWdhbW1hIGZ1bmN0aW9uXG5qU3RhdC5nYW1tYWxuID0gZnVuY3Rpb24gZ2FtbWFsbih4KSB7XG4gIHZhciBqID0gMDtcbiAgdmFyIGNvZiA9IFtcbiAgICA3Ni4xODAwOTE3Mjk0NzE0NiwgLTg2LjUwNTMyMDMyOTQxNjc3LCAyNC4wMTQwOTgyNDA4MzA5MSxcbiAgICAtMS4yMzE3Mzk1NzI0NTAxNTUsIDAuMTIwODY1MDk3Mzg2NjE3OWUtMiwgLTAuNTM5NTIzOTM4NDk1M2UtNVxuICBdO1xuICB2YXIgc2VyID0gMS4wMDAwMDAwMDAxOTAwMTU7XG4gIHZhciB4eCwgeSwgdG1wO1xuICB0bXAgPSAoeSA9IHh4ID0geCkgKyA1LjU7XG4gIHRtcCAtPSAoeHggKyAwLjUpICogTWF0aC5sb2codG1wKTtcbiAgZm9yICg7IGogPCA2OyBqKyspXG4gICAgc2VyICs9IGNvZltqXSAvICsreTtcbiAgcmV0dXJuIE1hdGgubG9nKDIuNTA2NjI4Mjc0NjMxMDAwNSAqIHNlciAvIHh4KSAtIHRtcDtcbn07XG5cbi8qXG4gKiBsb2ctZ2FtbWEgZnVuY3Rpb24gdG8gc3VwcG9ydCBwb2lzc29uIGRpc3RyaWJ1dGlvbiBzYW1wbGluZy4gVGhlXG4gKiBhbGdvcml0aG0gY29tZXMgZnJvbSBTUEVDRlVOIGJ5IFNoYW5qaWUgWmhhbmcgYW5kIEppYW5taW5nIEppbiBhbmQgdGhlaXJcbiAqIGJvb2sgXCJDb21wdXRhdGlvbiBvZiBTcGVjaWFsIEZ1bmN0aW9uc1wiLCAxOTk2LCBKb2huIFdpbGV5ICYgU29ucywgSW5jLlxuICovXG5qU3RhdC5sb2dnYW0gPSBmdW5jdGlvbiBsb2dnYW0oeCkge1xuICB2YXIgeDAsIHgyLCB4cCwgZ2wsIGdsMDtcbiAgdmFyIGssIG47XG5cbiAgdmFyIGEgPSBbOC4zMzMzMzMzMzMzMzMzMzNlLTAyLCAtMi43Nzc3Nzc3Nzc3Nzc3NzhlLTAzLFxuICAgICAgICAgIDcuOTM2NTA3OTM2NTA3OTM3ZS0wNCwgLTUuOTUyMzgwOTUyMzgwOTUyZS0wNCxcbiAgICAgICAgICA4LjQxNzUwODQxNzUwODQxOGUtMDQsIC0xLjkxNzUyNjkxNzUyNjkxOGUtMDMsXG4gICAgICAgICAgNi40MTAyNTY0MTAyNTY0MTBlLTAzLCAtMi45NTUwNjUzNTk0NzcxMjRlLTAyLFxuICAgICAgICAgIDEuNzk2NDQzNzIzNjg4MzA3ZS0wMSwgLTEuMzkyNDMyMjE2OTA1OTBlKzAwXTtcbiAgeDAgPSB4O1xuICBuID0gMDtcbiAgaWYgKCh4ID09IDEuMCkgfHwgKHggPT0gMi4wKSkge1xuICAgICAgcmV0dXJuIDAuMDtcbiAgfVxuICBpZiAoeCA8PSA3LjApIHtcbiAgICAgIG4gPSBNYXRoLmZsb29yKDcgLSB4KTtcbiAgICAgIHgwID0geCArIG47XG4gIH1cbiAgeDIgPSAxLjAgLyAoeDAgKiB4MCk7XG4gIHhwID0gMiAqIE1hdGguUEk7XG4gIGdsMCA9IGFbOV07XG4gIGZvciAoayA9IDg7IGsgPj0gMDsgay0tKSB7XG4gICAgICBnbDAgKj0geDI7XG4gICAgICBnbDAgKz0gYVtrXTtcbiAgfVxuICBnbCA9IGdsMCAvIHgwICsgMC41ICogTWF0aC5sb2coeHApICsgKHgwIC0gMC41KSAqIE1hdGgubG9nKHgwKSAtIHgwO1xuICBpZiAoeCA8PSA3LjApIHtcbiAgICAgIGZvciAoayA9IDE7IGsgPD0gbjsgaysrKSB7XG4gICAgICAgICAgZ2wgLT0gTWF0aC5sb2coeDAgLSAxLjApO1xuICAgICAgICAgIHgwIC09IDEuMDtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZ2w7XG59XG5cbi8vIGdhbW1hIG9mIHhcbmpTdGF0LmdhbW1hZm4gPSBmdW5jdGlvbiBnYW1tYWZuKHgpIHtcbiAgdmFyIHAgPSBbLTEuNzE2MTg1MTM4ODY1NDk1LCAyNC43NjU2NTA4MDU1NzU5MiwgLTM3OS44MDQyNTY0NzA5NDU2MyxcbiAgICAgICAgICAgNjI5LjMzMTE1NTMxMjgxODQsIDg2Ni45NjYyMDI3OTA0MTMzLCAtMzE0NTEuMjcyOTY4ODQ4MzY3LFxuICAgICAgICAgICAtMzYxNDQuNDEzNDE4NjkxMTc2LCA2NjQ1Ni4xNDM4MjAyNDA1NFxuICBdO1xuICB2YXIgcSA9IFstMzAuODQwMjMwMDExOTczOSwgMzE1LjM1MDYyNjk3OTYwNDE2LCAtMTAxNS4xNTYzNjc0OTAyMTkyLFxuICAgICAgICAgICAtMzEwNy43NzE2NzE1NzIzMTEsIDIyNTM4LjExODQyMDk4MDE1MSwgNDc1NS44NDYyNzc1Mjc4ODExLFxuICAgICAgICAgICAtMTM0NjU5Ljk1OTg2NDk2OTMsIC0xMTUxMzIuMjU5Njc1NTUzNV07XG4gIHZhciBmYWN0ID0gZmFsc2U7XG4gIHZhciBuID0gMDtcbiAgdmFyIHhkZW4gPSAwO1xuICB2YXIgeG51bSA9IDA7XG4gIHZhciB5ID0geDtcbiAgdmFyIGksIHosIHlpLCByZXM7XG4gIGlmICh4ID4gMTcxLjYyNDM3Njk1MzYwNzYpIHtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cbiAgaWYgKHkgPD0gMCkge1xuICAgIHJlcyA9IHkgJSAxICsgMy42ZS0xNjtcbiAgICBpZiAocmVzKSB7XG4gICAgICBmYWN0ID0gKCEoeSAmIDEpID8gMSA6IC0xKSAqIE1hdGguUEkgLyBNYXRoLnNpbihNYXRoLlBJICogcmVzKTtcbiAgICAgIHkgPSAxIC0geTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgfVxuICB5aSA9IHk7XG4gIGlmICh5IDwgMSkge1xuICAgIHogPSB5Kys7XG4gIH0gZWxzZSB7XG4gICAgeiA9ICh5IC09IG4gPSAoeSB8IDApIC0gMSkgLSAxO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICB4bnVtID0gKHhudW0gKyBwW2ldKSAqIHo7XG4gICAgeGRlbiA9IHhkZW4gKiB6ICsgcVtpXTtcbiAgfVxuICByZXMgPSB4bnVtIC8geGRlbiArIDE7XG4gIGlmICh5aSA8IHkpIHtcbiAgICByZXMgLz0geWk7XG4gIH0gZWxzZSBpZiAoeWkgPiB5KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgcmVzICo9IHk7XG4gICAgICB5Kys7XG4gICAgfVxuICB9XG4gIGlmIChmYWN0KSB7XG4gICAgcmVzID0gZmFjdCAvIHJlcztcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG4vLyBsb3dlciBpbmNvbXBsZXRlIGdhbW1hIGZ1bmN0aW9uLCB3aGljaCBpcyB1c3VhbGx5IHR5cGVzZXQgd2l0aCBhXG4vLyBsb3dlci1jYXNlIGdyZWVrIGdhbW1hIGFzIHRoZSBmdW5jdGlvbiBzeW1ib2xcbmpTdGF0LmdhbW1hcCA9IGZ1bmN0aW9uIGdhbW1hcChhLCB4KSB7XG4gIHJldHVybiBqU3RhdC5sb3dSZWdHYW1tYShhLCB4KSAqIGpTdGF0LmdhbW1hZm4oYSk7XG59O1xuXG5cbi8vIFRoZSBsb3dlciByZWd1bGFyaXplZCBpbmNvbXBsZXRlIGdhbW1hIGZ1bmN0aW9uLCB1c3VhbGx5IHdyaXR0ZW4gUChhLHgpXG5qU3RhdC5sb3dSZWdHYW1tYSA9IGZ1bmN0aW9uIGxvd1JlZ0dhbW1hKGEsIHgpIHtcbiAgdmFyIGFsbiA9IGpTdGF0LmdhbW1hbG4oYSk7XG4gIHZhciBhcCA9IGE7XG4gIHZhciBzdW0gPSAxIC8gYTtcbiAgdmFyIGRlbCA9IHN1bTtcbiAgdmFyIGIgPSB4ICsgMSAtIGE7XG4gIHZhciBjID0gMSAvIDEuMGUtMzA7XG4gIHZhciBkID0gMSAvIGI7XG4gIHZhciBoID0gZDtcbiAgdmFyIGkgPSAxO1xuICAvLyBjYWxjdWxhdGUgbWF4aW11bSBudW1iZXIgb2YgaXR0ZXJhdGlvbnMgcmVxdWlyZWQgZm9yIGFcbiAgdmFyIElUTUFYID0gLX4oTWF0aC5sb2coKGEgPj0gMSkgPyBhIDogMSAvIGEpICogOC41ICsgYSAqIDAuNCArIDE3KTtcbiAgdmFyIGFuO1xuXG4gIGlmICh4IDwgMCB8fCBhIDw9IDApIHtcbiAgICByZXR1cm4gTmFOO1xuICB9IGVsc2UgaWYgKHggPCBhICsgMSkge1xuICAgIGZvciAoOyBpIDw9IElUTUFYOyBpKyspIHtcbiAgICAgIHN1bSArPSBkZWwgKj0geCAvICsrYXA7XG4gICAgfVxuICAgIHJldHVybiAoc3VtICogTWF0aC5leHAoLXggKyBhICogTWF0aC5sb2coeCkgLSAoYWxuKSkpO1xuICB9XG5cbiAgZm9yICg7IGkgPD0gSVRNQVg7IGkrKykge1xuICAgIGFuID0gLWkgKiAoaSAtIGEpO1xuICAgIGIgKz0gMjtcbiAgICBkID0gYW4gKiBkICsgYjtcbiAgICBjID0gYiArIGFuIC8gYztcbiAgICBkID0gMSAvIGQ7XG4gICAgaCAqPSBkICogYztcbiAgfVxuXG4gIHJldHVybiAoMSAtIGggKiBNYXRoLmV4cCgteCArIGEgKiBNYXRoLmxvZyh4KSAtIChhbG4pKSk7XG59O1xuXG4vLyBuYXR1cmFsIGxvZyBmYWN0b3JpYWwgb2YgblxualN0YXQuZmFjdG9yaWFsbG4gPSBmdW5jdGlvbiBmYWN0b3JpYWxsbihuKSB7XG4gIHJldHVybiBuIDwgMCA/IE5hTiA6IGpTdGF0LmdhbW1hbG4obiArIDEpO1xufTtcblxuLy8gZmFjdG9yaWFsIG9mIG5cbmpTdGF0LmZhY3RvcmlhbCA9IGZ1bmN0aW9uIGZhY3RvcmlhbChuKSB7XG4gIHJldHVybiBuIDwgMCA/IE5hTiA6IGpTdGF0LmdhbW1hZm4obiArIDEpO1xufTtcblxuLy8gY29tYmluYXRpb25zIG9mIG4sIG1cbmpTdGF0LmNvbWJpbmF0aW9uID0gZnVuY3Rpb24gY29tYmluYXRpb24obiwgbSkge1xuICAvLyBtYWtlIHN1cmUgbiBvciBtIGRvbid0IGV4Y2VlZCB0aGUgdXBwZXIgbGltaXQgb2YgdXNhYmxlIHZhbHVlc1xuICByZXR1cm4gKG4gPiAxNzAgfHwgbSA+IDE3MClcbiAgICAgID8gTWF0aC5leHAoalN0YXQuY29tYmluYXRpb25sbihuLCBtKSlcbiAgICAgIDogKGpTdGF0LmZhY3RvcmlhbChuKSAvIGpTdGF0LmZhY3RvcmlhbChtKSkgLyBqU3RhdC5mYWN0b3JpYWwobiAtIG0pO1xufTtcblxuXG5qU3RhdC5jb21iaW5hdGlvbmxuID0gZnVuY3Rpb24gY29tYmluYXRpb25sbihuLCBtKXtcbiAgcmV0dXJuIGpTdGF0LmZhY3RvcmlhbGxuKG4pIC0galN0YXQuZmFjdG9yaWFsbG4obSkgLSBqU3RhdC5mYWN0b3JpYWxsbihuIC0gbSk7XG59O1xuXG5cbi8vIHBlcm11dGF0aW9ucyBvZiBuLCBtXG5qU3RhdC5wZXJtdXRhdGlvbiA9IGZ1bmN0aW9uIHBlcm11dGF0aW9uKG4sIG0pIHtcbiAgcmV0dXJuIGpTdGF0LmZhY3RvcmlhbChuKSAvIGpTdGF0LmZhY3RvcmlhbChuIC0gbSk7XG59O1xuXG5cbi8vIGJldGEgZnVuY3Rpb25cbmpTdGF0LmJldGFmbiA9IGZ1bmN0aW9uIGJldGFmbih4LCB5KSB7XG4gIC8vIGVuc3VyZSBhcmd1bWVudHMgYXJlIHBvc2l0aXZlXG4gIGlmICh4IDw9IDAgfHwgeSA8PSAwKVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIC8vIG1ha2Ugc3VyZSB4ICsgeSBkb2Vzbid0IGV4Y2VlZCB0aGUgdXBwZXIgbGltaXQgb2YgdXNhYmxlIHZhbHVlc1xuICByZXR1cm4gKHggKyB5ID4gMTcwKVxuICAgICAgPyBNYXRoLmV4cChqU3RhdC5iZXRhbG4oeCwgeSkpXG4gICAgICA6IGpTdGF0LmdhbW1hZm4oeCkgKiBqU3RhdC5nYW1tYWZuKHkpIC8galN0YXQuZ2FtbWFmbih4ICsgeSk7XG59O1xuXG5cbi8vIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGJldGEgZnVuY3Rpb25cbmpTdGF0LmJldGFsbiA9IGZ1bmN0aW9uIGJldGFsbih4LCB5KSB7XG4gIHJldHVybiBqU3RhdC5nYW1tYWxuKHgpICsgalN0YXQuZ2FtbWFsbih5KSAtIGpTdGF0LmdhbW1hbG4oeCArIHkpO1xufTtcblxuXG4vLyBFdmFsdWF0ZXMgdGhlIGNvbnRpbnVlZCBmcmFjdGlvbiBmb3IgaW5jb21wbGV0ZSBiZXRhIGZ1bmN0aW9uIGJ5IG1vZGlmaWVkXG4vLyBMZW50eidzIG1ldGhvZC5cbmpTdGF0LmJldGFjZiA9IGZ1bmN0aW9uIGJldGFjZih4LCBhLCBiKSB7XG4gIHZhciBmcG1pbiA9IDFlLTMwO1xuICB2YXIgbSA9IDE7XG4gIHZhciBxYWIgPSBhICsgYjtcbiAgdmFyIHFhcCA9IGEgKyAxO1xuICB2YXIgcWFtID0gYSAtIDE7XG4gIHZhciBjID0gMTtcbiAgdmFyIGQgPSAxIC0gcWFiICogeCAvIHFhcDtcbiAgdmFyIG0yLCBhYSwgZGVsLCBoO1xuXG4gIC8vIFRoZXNlIHEncyB3aWxsIGJlIHVzZWQgaW4gZmFjdG9ycyB0aGF0IG9jY3VyIGluIHRoZSBjb2VmZmljaWVudHNcbiAgaWYgKE1hdGguYWJzKGQpIDwgZnBtaW4pXG4gICAgZCA9IGZwbWluO1xuICBkID0gMSAvIGQ7XG4gIGggPSBkO1xuXG4gIGZvciAoOyBtIDw9IDEwMDsgbSsrKSB7XG4gICAgbTIgPSAyICogbTtcbiAgICBhYSA9IG0gKiAoYiAtIG0pICogeCAvICgocWFtICsgbTIpICogKGEgKyBtMikpO1xuICAgIC8vIE9uZSBzdGVwICh0aGUgZXZlbiBvbmUpIG9mIHRoZSByZWN1cnJlbmNlXG4gICAgZCA9IDEgKyBhYSAqIGQ7XG4gICAgaWYgKE1hdGguYWJzKGQpIDwgZnBtaW4pXG4gICAgICBkID0gZnBtaW47XG4gICAgYyA9IDEgKyBhYSAvIGM7XG4gICAgaWYgKE1hdGguYWJzKGMpIDwgZnBtaW4pXG4gICAgICBjID0gZnBtaW47XG4gICAgZCA9IDEgLyBkO1xuICAgIGggKj0gZCAqIGM7XG4gICAgYWEgPSAtKGEgKyBtKSAqIChxYWIgKyBtKSAqIHggLyAoKGEgKyBtMikgKiAocWFwICsgbTIpKTtcbiAgICAvLyBOZXh0IHN0ZXAgb2YgdGhlIHJlY3VycmVuY2UgKHRoZSBvZGQgb25lKVxuICAgIGQgPSAxICsgYWEgKiBkO1xuICAgIGlmIChNYXRoLmFicyhkKSA8IGZwbWluKVxuICAgICAgZCA9IGZwbWluO1xuICAgIGMgPSAxICsgYWEgLyBjO1xuICAgIGlmIChNYXRoLmFicyhjKSA8IGZwbWluKVxuICAgICAgYyA9IGZwbWluO1xuICAgIGQgPSAxIC8gZDtcbiAgICBkZWwgPSBkICogYztcbiAgICBoICo9IGRlbDtcbiAgICBpZiAoTWF0aC5hYnMoZGVsIC0gMS4wKSA8IDNlLTcpXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBoO1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBsb3dlciByZWd1bGFyaXplZCBpbm9tcGxldGUgZ2FtbWEgZnVuY3Rpb25cbmpTdGF0LmdhbW1hcGludiA9IGZ1bmN0aW9uIGdhbW1hcGludihwLCBhKSB7XG4gIHZhciBqID0gMDtcbiAgdmFyIGExID0gYSAtIDE7XG4gIHZhciBFUFMgPSAxZS04O1xuICB2YXIgZ2xuID0galN0YXQuZ2FtbWFsbihhKTtcbiAgdmFyIHgsIGVyciwgdCwgdSwgcHAsIGxuYTEsIGFmYWM7XG5cbiAgaWYgKHAgPj0gMSlcbiAgICByZXR1cm4gTWF0aC5tYXgoMTAwLCBhICsgMTAwICogTWF0aC5zcXJ0KGEpKTtcbiAgaWYgKHAgPD0gMClcbiAgICByZXR1cm4gMDtcbiAgaWYgKGEgPiAxKSB7XG4gICAgbG5hMSA9IE1hdGgubG9nKGExKTtcbiAgICBhZmFjID0gTWF0aC5leHAoYTEgKiAobG5hMSAtIDEpIC0gZ2xuKTtcbiAgICBwcCA9IChwIDwgMC41KSA/IHAgOiAxIC0gcDtcbiAgICB0ID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocHApKTtcbiAgICB4ID0gKDIuMzA3NTMgKyB0ICogMC4yNzA2MSkgLyAoMSArIHQgKiAoMC45OTIyOSArIHQgKiAwLjA0NDgxKSkgLSB0O1xuICAgIGlmIChwIDwgMC41KVxuICAgICAgeCA9IC14O1xuICAgIHggPSBNYXRoLm1heCgxZS0zLFxuICAgICAgICAgICAgICAgICBhICogTWF0aC5wb3coMSAtIDEgLyAoOSAqIGEpIC0geCAvICgzICogTWF0aC5zcXJ0KGEpKSwgMykpO1xuICB9IGVsc2Uge1xuICAgIHQgPSAxIC0gYSAqICgwLjI1MyArIGEgKiAwLjEyKTtcbiAgICBpZiAocCA8IHQpXG4gICAgICB4ID0gTWF0aC5wb3cocCAvIHQsIDEgLyBhKTtcbiAgICBlbHNlXG4gICAgICB4ID0gMSAtIE1hdGgubG9nKDEgLSAocCAtIHQpIC8gKDEgLSB0KSk7XG4gIH1cblxuICBmb3IoOyBqIDwgMTI7IGorKykge1xuICAgIGlmICh4IDw9IDApXG4gICAgICByZXR1cm4gMDtcbiAgICBlcnIgPSBqU3RhdC5sb3dSZWdHYW1tYShhLCB4KSAtIHA7XG4gICAgaWYgKGEgPiAxKVxuICAgICAgdCA9IGFmYWMgKiBNYXRoLmV4cCgtKHggLSBhMSkgKyBhMSAqIChNYXRoLmxvZyh4KSAtIGxuYTEpKTtcbiAgICBlbHNlXG4gICAgICB0ID0gTWF0aC5leHAoLXggKyBhMSAqIE1hdGgubG9nKHgpIC0gZ2xuKTtcbiAgICB1ID0gZXJyIC8gdDtcbiAgICB4IC09ICh0ID0gdSAvICgxIC0gMC41ICogTWF0aC5taW4oMSwgdSAqICgoYSAtIDEpIC8geCAtIDEpKSkpO1xuICAgIGlmICh4IDw9IDApXG4gICAgICB4ID0gMC41ICogKHggKyB0KTtcbiAgICBpZiAoTWF0aC5hYnModCkgPCBFUFMgKiB4KVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4geDtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgZXJyb3IgZnVuY3Rpb24gZXJmKHgpXG5qU3RhdC5lcmYgPSBmdW5jdGlvbiBlcmYoeCkge1xuICB2YXIgY29mID0gWy0xLjMwMjY1MzcxOTc4MTcwOTQsIDYuNDE5Njk3OTIzNTY0OTAyNmUtMSwgMS45NDc2NDczMjA0MTg1ODM2ZS0yLFxuICAgICAgICAgICAgIC05LjU2MTUxNDc4NjgwODYzMWUtMywgLTkuNDY1OTUzNDQ0ODIwMzZlLTQsIDMuNjY4Mzk0OTc4NTI3NjFlLTQsXG4gICAgICAgICAgICAgNC4yNTIzMzI0ODA2OTA3ZS01LCAtMi4wMjc4NTc4MTEyNTM0ZS01LCAtMS42MjQyOTAwMDQ2NDdlLTYsXG4gICAgICAgICAgICAgMS4zMDM2NTU4MzU1ODBlLTYsIDEuNTYyNjQ0MTcyMmUtOCwgLTguNTIzODA5NTkxNWUtOCxcbiAgICAgICAgICAgICA2LjUyOTA1NDQzOWUtOSwgNS4wNTkzNDM0OTVlLTksIC05LjkxMzY0MTU2ZS0xMCxcbiAgICAgICAgICAgICAtMi4yNzM2NTEyMmUtMTAsIDkuNjQ2NzkxMWUtMTEsIDIuMzk0MDM4ZS0xMixcbiAgICAgICAgICAgICAtNi44ODYwMjdlLTEyLCA4Ljk0NDg3ZS0xMywgMy4xMzA5MmUtMTMsXG4gICAgICAgICAgICAgLTEuMTI3MDhlLTEzLCAzLjgxZS0xNiwgNy4xMDZlLTE1LFxuICAgICAgICAgICAgIC0xLjUyM2UtMTUsIC05LjRlLTE3LCAxLjIxZS0xNixcbiAgICAgICAgICAgICAtMi44ZS0xN107XG4gIHZhciBqID0gY29mLmxlbmd0aCAtIDE7XG4gIHZhciBpc25lZyA9IGZhbHNlO1xuICB2YXIgZCA9IDA7XG4gIHZhciBkZCA9IDA7XG4gIHZhciB0LCB0eSwgdG1wLCByZXM7XG5cbiAgaWYgKHggPCAwKSB7XG4gICAgeCA9IC14O1xuICAgIGlzbmVnID0gdHJ1ZTtcbiAgfVxuXG4gIHQgPSAyIC8gKDIgKyB4KTtcbiAgdHkgPSA0ICogdCAtIDI7XG5cbiAgZm9yKDsgaiA+IDA7IGotLSkge1xuICAgIHRtcCA9IGQ7XG4gICAgZCA9IHR5ICogZCAtIGRkICsgY29mW2pdO1xuICAgIGRkID0gdG1wO1xuICB9XG5cbiAgcmVzID0gdCAqIE1hdGguZXhwKC14ICogeCArIDAuNSAqIChjb2ZbMF0gKyB0eSAqIGQpIC0gZGQpO1xuICByZXR1cm4gaXNuZWcgPyByZXMgLSAxIDogMSAtIHJlcztcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgY29tcGxtZW50YXJ5IGVycm9yIGZ1bmN0aW9uIGVyZmMoeClcbmpTdGF0LmVyZmMgPSBmdW5jdGlvbiBlcmZjKHgpIHtcbiAgcmV0dXJuIDEgLSBqU3RhdC5lcmYoeCk7XG59O1xuXG5cbi8vIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBsZW1lbnRhcnkgZXJyb3IgZnVuY3Rpb25cbmpTdGF0LmVyZmNpbnYgPSBmdW5jdGlvbiBlcmZjaW52KHApIHtcbiAgdmFyIGogPSAwO1xuICB2YXIgeCwgZXJyLCB0LCBwcDtcbiAgaWYgKHAgPj0gMilcbiAgICByZXR1cm4gLTEwMDtcbiAgaWYgKHAgPD0gMClcbiAgICByZXR1cm4gMTAwO1xuICBwcCA9IChwIDwgMSkgPyBwIDogMiAtIHA7XG4gIHQgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhwcCAvIDIpKTtcbiAgeCA9IC0wLjcwNzExICogKCgyLjMwNzUzICsgdCAqIDAuMjcwNjEpIC9cbiAgICAgICAgICAgICAgICAgICgxICsgdCAqICgwLjk5MjI5ICsgdCAqIDAuMDQ0ODEpKSAtIHQpO1xuICBmb3IgKDsgaiA8IDI7IGorKykge1xuICAgIGVyciA9IGpTdGF0LmVyZmMoeCkgLSBwcDtcbiAgICB4ICs9IGVyciAvICgxLjEyODM3OTE2NzA5NTUxMjU3ICogTWF0aC5leHAoLXggKiB4KSAtIHggKiBlcnIpO1xuICB9XG4gIHJldHVybiAocCA8IDEpID8geCA6IC14O1xufTtcblxuXG4vLyBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBpbmNvbXBsZXRlIGJldGEgZnVuY3Rpb25cbmpTdGF0LmliZXRhaW52ID0gZnVuY3Rpb24gaWJldGFpbnYocCwgYSwgYikge1xuICB2YXIgRVBTID0gMWUtODtcbiAgdmFyIGExID0gYSAtIDE7XG4gIHZhciBiMSA9IGIgLSAxO1xuICB2YXIgaiA9IDA7XG4gIHZhciBsbmEsIGxuYiwgcHAsIHQsIHUsIGVyciwgeCwgYWwsIGgsIHcsIGFmYWM7XG4gIGlmIChwIDw9IDApXG4gICAgcmV0dXJuIDA7XG4gIGlmIChwID49IDEpXG4gICAgcmV0dXJuIDE7XG4gIGlmIChhID49IDEgJiYgYiA+PSAxKSB7XG4gICAgcHAgPSAocCA8IDAuNSkgPyBwIDogMSAtIHA7XG4gICAgdCA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHBwKSk7XG4gICAgeCA9ICgyLjMwNzUzICsgdCAqIDAuMjcwNjEpIC8gKDEgKyB0KiAoMC45OTIyOSArIHQgKiAwLjA0NDgxKSkgLSB0O1xuICAgIGlmIChwIDwgMC41KVxuICAgICAgeCA9IC14O1xuICAgIGFsID0gKHggKiB4IC0gMykgLyA2O1xuICAgIGggPSAyIC8gKDEgLyAoMiAqIGEgLSAxKSAgKyAxIC8gKDIgKiBiIC0gMSkpO1xuICAgIHcgPSAoeCAqIE1hdGguc3FydChhbCArIGgpIC8gaCkgLSAoMSAvICgyICogYiAtIDEpIC0gMSAvICgyICogYSAtIDEpKSAqXG4gICAgICAgIChhbCArIDUgLyA2IC0gMiAvICgzICogaCkpO1xuICAgIHggPSBhIC8gKGEgKyBiICogTWF0aC5leHAoMiAqIHcpKTtcbiAgfSBlbHNlIHtcbiAgICBsbmEgPSBNYXRoLmxvZyhhIC8gKGEgKyBiKSk7XG4gICAgbG5iID0gTWF0aC5sb2coYiAvIChhICsgYikpO1xuICAgIHQgPSBNYXRoLmV4cChhICogbG5hKSAvIGE7XG4gICAgdSA9IE1hdGguZXhwKGIgKiBsbmIpIC8gYjtcbiAgICB3ID0gdCArIHU7XG4gICAgaWYgKHAgPCB0IC8gdylcbiAgICAgIHggPSBNYXRoLnBvdyhhICogdyAqIHAsIDEgLyBhKTtcbiAgICBlbHNlXG4gICAgICB4ID0gMSAtIE1hdGgucG93KGIgKiB3ICogKDEgLSBwKSwgMSAvIGIpO1xuICB9XG4gIGFmYWMgPSAtalN0YXQuZ2FtbWFsbihhKSAtIGpTdGF0LmdhbW1hbG4oYikgKyBqU3RhdC5nYW1tYWxuKGEgKyBiKTtcbiAgZm9yKDsgaiA8IDEwOyBqKyspIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSAxKVxuICAgICAgcmV0dXJuIHg7XG4gICAgZXJyID0galN0YXQuaWJldGEoeCwgYSwgYikgLSBwO1xuICAgIHQgPSBNYXRoLmV4cChhMSAqIE1hdGgubG9nKHgpICsgYjEgKiBNYXRoLmxvZygxIC0geCkgKyBhZmFjKTtcbiAgICB1ID0gZXJyIC8gdDtcbiAgICB4IC09ICh0ID0gdSAvICgxIC0gMC41ICogTWF0aC5taW4oMSwgdSAqIChhMSAvIHggLSBiMSAvICgxIC0geCkpKSkpO1xuICAgIGlmICh4IDw9IDApXG4gICAgICB4ID0gMC41ICogKHggKyB0KTtcbiAgICBpZiAoeCA+PSAxKVxuICAgICAgeCA9IDAuNSAqICh4ICsgdCArIDEpO1xuICAgIGlmIChNYXRoLmFicyh0KSA8IEVQUyAqIHggJiYgaiA+IDApXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4geDtcbn07XG5cblxuLy8gUmV0dXJucyB0aGUgaW5jb21wbGV0ZSBiZXRhIGZ1bmN0aW9uIElfeChhLGIpXG5qU3RhdC5pYmV0YSA9IGZ1bmN0aW9uIGliZXRhKHgsIGEsIGIpIHtcbiAgLy8gRmFjdG9ycyBpbiBmcm9udCBvZiB0aGUgY29udGludWVkIGZyYWN0aW9uLlxuICB2YXIgYnQgPSAoeCA9PT0gMCB8fCB4ID09PSAxKSA/ICAwIDpcbiAgICBNYXRoLmV4cChqU3RhdC5nYW1tYWxuKGEgKyBiKSAtIGpTdGF0LmdhbW1hbG4oYSkgLVxuICAgICAgICAgICAgIGpTdGF0LmdhbW1hbG4oYikgKyBhICogTWF0aC5sb2coeCkgKyBiICpcbiAgICAgICAgICAgICBNYXRoLmxvZygxIC0geCkpO1xuICBpZiAoeCA8IDAgfHwgeCA+IDEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoeCA8IChhICsgMSkgLyAoYSArIGIgKyAyKSlcbiAgICAvLyBVc2UgY29udGludWVkIGZyYWN0aW9uIGRpcmVjdGx5LlxuICAgIHJldHVybiBidCAqIGpTdGF0LmJldGFjZih4LCBhLCBiKSAvIGE7XG4gIC8vIGVsc2UgdXNlIGNvbnRpbnVlZCBmcmFjdGlvbiBhZnRlciBtYWtpbmcgdGhlIHN5bW1ldHJ5IHRyYW5zZm9ybWF0aW9uLlxuICByZXR1cm4gMSAtIGJ0ICogalN0YXQuYmV0YWNmKDEgLSB4LCBiLCBhKSAvIGI7XG59O1xuXG5cbi8vIFJldHVybnMgYSBub3JtYWwgZGV2aWF0ZSAobXU9MCwgc2lnbWE9MSkuXG4vLyBJZiBuIGFuZCBtIGFyZSBzcGVjaWZpZWQgaXQgcmV0dXJucyBhIG9iamVjdCBvZiBub3JtYWwgZGV2aWF0ZXMuXG5qU3RhdC5yYW5kbiA9IGZ1bmN0aW9uIHJhbmRuKG4sIG0pIHtcbiAgdmFyIHUsIHYsIHgsIHksIHE7XG4gIGlmICghbSlcbiAgICBtID0gbjtcbiAgaWYgKG4pXG4gICAgcmV0dXJuIGpTdGF0LmNyZWF0ZShuLCBtLCBmdW5jdGlvbigpIHsgcmV0dXJuIGpTdGF0LnJhbmRuKCk7IH0pO1xuICBkbyB7XG4gICAgdSA9IGpTdGF0Ll9yYW5kb21fZm4oKTtcbiAgICB2ID0gMS43MTU2ICogKGpTdGF0Ll9yYW5kb21fZm4oKSAtIDAuNSk7XG4gICAgeCA9IHUgLSAwLjQ0OTg3MTtcbiAgICB5ID0gTWF0aC5hYnModikgKyAwLjM4NjU5NTtcbiAgICBxID0geCAqIHggKyB5ICogKDAuMTk2MDAgKiB5IC0gMC4yNTQ3MiAqIHgpO1xuICB9IHdoaWxlIChxID4gMC4yNzU5NyAmJiAocSA+IDAuMjc4NDYgfHwgdiAqIHYgPiAtNCAqIE1hdGgubG9nKHUpICogdSAqIHUpKTtcbiAgcmV0dXJuIHYgLyB1O1xufTtcblxuXG4vLyBSZXR1cm5zIGEgZ2FtbWEgZGV2aWF0ZSBieSB0aGUgbWV0aG9kIG9mIE1hcnNhZ2xpYSBhbmQgVHNhbmcuXG5qU3RhdC5yYW5kZyA9IGZ1bmN0aW9uIHJhbmRnKHNoYXBlLCBuLCBtKSB7XG4gIHZhciBvYWxwaCA9IHNoYXBlO1xuICB2YXIgYTEsIGEyLCB1LCB2LCB4LCBtYXQ7XG4gIGlmICghbSlcbiAgICBtID0gbjtcbiAgaWYgKCFzaGFwZSlcbiAgICBzaGFwZSA9IDE7XG4gIGlmIChuKSB7XG4gICAgbWF0ID0galN0YXQuemVyb3MobixtKTtcbiAgICBtYXQuYWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiBqU3RhdC5yYW5kZyhzaGFwZSk7IH0pO1xuICAgIHJldHVybiBtYXQ7XG4gIH1cbiAgaWYgKHNoYXBlIDwgMSlcbiAgICBzaGFwZSArPSAxO1xuICBhMSA9IHNoYXBlIC0gMSAvIDM7XG4gIGEyID0gMSAvIE1hdGguc3FydCg5ICogYTEpO1xuICBkbyB7XG4gICAgZG8ge1xuICAgICAgeCA9IGpTdGF0LnJhbmRuKCk7XG4gICAgICB2ID0gMSArIGEyICogeDtcbiAgICB9IHdoaWxlKHYgPD0gMCk7XG4gICAgdiA9IHYgKiB2ICogdjtcbiAgICB1ID0galN0YXQuX3JhbmRvbV9mbigpO1xuICB9IHdoaWxlKHUgPiAxIC0gMC4zMzEgKiBNYXRoLnBvdyh4LCA0KSAmJlxuICAgICAgICAgIE1hdGgubG9nKHUpID4gMC41ICogeCp4ICsgYTEgKiAoMSAtIHYgKyBNYXRoLmxvZyh2KSkpO1xuICAvLyBhbHBoYSA+IDFcbiAgaWYgKHNoYXBlID09IG9hbHBoKVxuICAgIHJldHVybiBhMSAqIHY7XG4gIC8vIGFscGhhIDwgMVxuICBkbyB7XG4gICAgdSA9IGpTdGF0Ll9yYW5kb21fZm4oKTtcbiAgfSB3aGlsZSh1ID09PSAwKTtcbiAgcmV0dXJuIE1hdGgucG93KHUsIDEgLyBvYWxwaCkgKiBhMSAqIHY7XG59O1xuXG5cbi8vIG1ha2luZyB1c2Ugb2Ygc3RhdGljIG1ldGhvZHMgb24gdGhlIGluc3RhbmNlXG4oZnVuY3Rpb24oZnVuY3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKHBhc3NmdW5jKSB7XG4gICAgalN0YXQuZm5bcGFzc2Z1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4galN0YXQoXG4gICAgICAgICAgalN0YXQubWFwKHRoaXMsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBqU3RhdFtwYXNzZnVuY10odmFsdWUpOyB9KSk7XG4gICAgfVxuICB9KShmdW5jc1tpXSk7XG59KSgnZ2FtbWFsbiBnYW1tYWZuIGZhY3RvcmlhbCBmYWN0b3JpYWxsbicuc3BsaXQoJyAnKSk7XG5cblxuKGZ1bmN0aW9uKGZ1bmNzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIChmdW5jdGlvbihwYXNzZnVuYykge1xuICAgIGpTdGF0LmZuW3Bhc3NmdW5jXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGpTdGF0KGpTdGF0W3Bhc3NmdW5jXS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KShmdW5jc1tpXSk7XG59KSgncmFuZG4nLnNwbGl0KCcgJykpO1xuXG59KGpTdGF0LCBNYXRoKSk7XG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxuLy8gZ2VuZXJhdGUgYWxsIGRpc3RyaWJ1dGlvbiBpbnN0YW5jZSBtZXRob2RzXG4oZnVuY3Rpb24obGlzdCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIChmdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gZGlzdHJpYnV0aW9uIGluc3RhbmNlIG1ldGhvZFxuICAgIGpTdGF0W2Z1bmNdID0gZnVuY3Rpb24gZihhLCBiLCBjKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgZikpXG4gICAgICAgIHJldHVybiBuZXcgZihhLCBiLCBjKTtcbiAgICAgIHRoaXMuX2EgPSBhO1xuICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICB0aGlzLl9jID0gYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gZGlzdHJpYnV0aW9uIG1ldGhvZCB0byBiZSB1c2VkIG9uIGEgalN0YXQgaW5zdGFuY2VcbiAgICBqU3RhdC5mbltmdW5jXSA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIHZhciBuZXd0aGlzID0galN0YXRbZnVuY10oYSwgYiwgYyk7XG4gICAgICBuZXd0aGlzLmRhdGEgPSB0aGlzO1xuICAgICAgcmV0dXJuIG5ld3RoaXM7XG4gICAgfTtcbiAgICAvLyBzYW1wbGUgaW5zdGFuY2UgbWV0aG9kXG4gICAgalN0YXRbZnVuY10ucHJvdG90eXBlLnNhbXBsZSA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgdmFyIGEgPSB0aGlzLl9hO1xuICAgICAgdmFyIGIgPSB0aGlzLl9iO1xuICAgICAgdmFyIGMgPSB0aGlzLl9jO1xuICAgICAgaWYgKGFycilcbiAgICAgICAgcmV0dXJuIGpTdGF0LmFsdGVyKGFyciwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdLnNhbXBsZShhLCBiLCBjKTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBqU3RhdFtmdW5jXS5zYW1wbGUoYSwgYiwgYyk7XG4gICAgfTtcbiAgICAvLyBnZW5lcmF0ZSB0aGUgcGRmLCBjZGYgYW5kIGludiBpbnN0YW5jZSBtZXRob2RzXG4gICAgKGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykgKGZ1bmN0aW9uKGZuZnVuYykge1xuICAgICAgICBqU3RhdFtmdW5jXS5wcm90b3R5cGVbZm5mdW5jXSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuX2E7XG4gICAgICAgICAgdmFyIGIgPSB0aGlzLl9iO1xuICAgICAgICAgIHZhciBjID0gdGhpcy5fYztcbiAgICAgICAgICBpZiAoIXggJiYgeCAhPT0gMClcbiAgICAgICAgICAgIHggPSB0aGlzLmRhdGE7XG4gICAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGpTdGF0LmZuLm1hcC5jYWxsKHgsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10oeCwgYSwgYiwgYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10oeCwgYSwgYiwgYyk7XG4gICAgICAgIH07XG4gICAgICB9KSh2YWxzW2ldKTtcbiAgICB9KSgncGRmIGNkZiBpbnYnLnNwbGl0KCcgJykpO1xuICAgIC8vIGdlbmVyYXRlIHRoZSBtZWFuLCBtZWRpYW4sIG1vZGUgYW5kIHZhcmlhbmNlIGluc3RhbmNlIG1ldGhvZHNcbiAgICAoZnVuY3Rpb24odmFscykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24oZm5mdW5jKSB7XG4gICAgICAgIGpTdGF0W2Z1bmNdLnByb3RvdHlwZVtmbmZ1bmNdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGpTdGF0W2Z1bmNdW2ZuZnVuY10odGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYyk7XG4gICAgICAgIH07XG4gICAgICB9KSh2YWxzW2ldKTtcbiAgICB9KSgnbWVhbiBtZWRpYW4gbW9kZSB2YXJpYW5jZScuc3BsaXQoJyAnKSk7XG4gIH0pKGxpc3RbaV0pO1xufSkoKFxuICAnYmV0YSBjZW50cmFsRiBjYXVjaHkgY2hpc3F1YXJlIGV4cG9uZW50aWFsIGdhbW1hIGludmdhbW1hIGt1bWFyYXN3YW15ICcgK1xuICAnbGFwbGFjZSBsb2dub3JtYWwgbm9uY2VudHJhbHQgbm9ybWFsIHBhcmV0byBzdHVkZW50dCB3ZWlidWxsIHVuaWZvcm0gJyArXG4gICdiaW5vbWlhbCBuZWdiaW4gaHlwZ2VvbSBwb2lzc29uIHRyaWFuZ3VsYXIgdHVrZXkgYXJjc2luZSdcbikuc3BsaXQoJyAnKSk7XG5cblxuXG4vLyBleHRlbmQgYmV0YSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuYmV0YSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBhbHBoYSwgYmV0YSkge1xuICAgIC8vIFBERiBpcyB6ZXJvIG91dHNpZGUgdGhlIHN1cHBvcnRcbiAgICBpZiAoeCA+IDEgfHwgeCA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICAvLyBQREYgaXMgb25lIGZvciB0aGUgdW5pZm9ybSBjYXNlXG4gICAgaWYgKGFscGhhID09IDEgJiYgYmV0YSA9PSAxKVxuICAgICAgcmV0dXJuIDE7XG5cbiAgICBpZiAoYWxwaGEgPCA1MTIgJiYgYmV0YSA8IDUxMikge1xuICAgICAgcmV0dXJuIChNYXRoLnBvdyh4LCBhbHBoYSAtIDEpICogTWF0aC5wb3coMSAtIHgsIGJldGEgLSAxKSkgL1xuICAgICAgICAgIGpTdGF0LmJldGFmbihhbHBoYSwgYmV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmV4cCgoYWxwaGEgLSAxKSAqIE1hdGgubG9nKHgpICtcbiAgICAgICAgICAgICAgICAgICAgICAoYmV0YSAtIDEpICogTWF0aC5sb2coMSAtIHgpIC1cbiAgICAgICAgICAgICAgICAgICAgICBqU3RhdC5iZXRhbG4oYWxwaGEsIGJldGEpKTtcbiAgICB9XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4gKHggPiAxIHx8IHggPCAwKSA/ICh4ID4gMSkgKiAxIDogalN0YXQuaWJldGEoeCwgYWxwaGEsIGJldGEpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHgsIGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIGpTdGF0LmliZXRhaW52KHgsIGFscGhhLCBiZXRhKTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIGFscGhhIC8gKGFscGhhICsgYmV0YSk7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4oYWxwaGEsIGJldGEpIHtcbiAgICByZXR1cm4galN0YXQuaWJldGFpbnYoMC41LCBhbHBoYSwgYmV0YSk7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoYWxwaGEgLSAxICkgLyAoIGFscGhhICsgYmV0YSAtIDIpO1xuICB9LFxuXG4gIC8vIHJldHVybiBhIHJhbmRvbSBzYW1wbGVcbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoYWxwaGEsIGJldGEpIHtcbiAgICB2YXIgdSA9IGpTdGF0LnJhbmRnKGFscGhhKTtcbiAgICByZXR1cm4gdSAvICh1ICsgalN0YXQucmFuZGcoYmV0YSkpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoYWxwaGEgKiBiZXRhKSAvIChNYXRoLnBvdyhhbHBoYSArIGJldGEsIDIpICogKGFscGhhICsgYmV0YSArIDEpKTtcbiAgfVxufSk7XG5cbi8vIGV4dGVuZCBGIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5jZW50cmFsRiwge1xuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIG9mIHRoZSBwZGYgZnVuY3Rpb24gYXZvaWRzIGZsb2F0IG92ZXJmbG93XG4gIC8vIFNlZSB0aGUgd2F5IHRoYXQgUiBjYWxjdWxhdGVzIHRoaXMgdmFsdWU6XG4gIC8vIGh0dHBzOi8vc3ZuLnItcHJvamVjdC5vcmcvUi90cnVuay9zcmMvbm1hdGgvZGYuY1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBkZjEsIGRmMikge1xuICAgIHZhciBwLCBxLCBmO1xuXG4gICAgaWYgKHggPCAwKVxuICAgICAgcmV0dXJuIDA7XG5cbiAgICBpZiAoZGYxIDw9IDIpIHtcbiAgICAgIGlmICh4ID09PSAwICYmIGRmMSA8IDIpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKHggPT09IDAgJiYgZGYxID09PSAyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgxIC8galN0YXQuYmV0YWZuKGRmMSAvIDIsIGRmMiAvIDIpKSAqXG4gICAgICAgICAgICAgIE1hdGgucG93KGRmMSAvIGRmMiwgZGYxIC8gMikgKlxuICAgICAgICAgICAgICBNYXRoLnBvdyh4LCAoZGYxLzIpIC0gMSkgKlxuICAgICAgICAgICAgICBNYXRoLnBvdygoMSArIChkZjEgLyBkZjIpICogeCksIC0oZGYxICsgZGYyKSAvIDIpO1xuICAgIH1cblxuICAgIHAgPSAoZGYxICogeCkgLyAoZGYyICsgeCAqIGRmMSk7XG4gICAgcSA9IGRmMiAvIChkZjIgKyB4ICogZGYxKTtcbiAgICBmID0gZGYxICogcSAvIDIuMDtcbiAgICByZXR1cm4gZiAqIGpTdGF0LmJpbm9taWFsLnBkZigoZGYxIC0gMikgLyAyLCAoZGYxICsgZGYyIC0gMikgLyAyLCBwKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBkZjEsIGRmMikge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiBqU3RhdC5pYmV0YSgoZGYxICogeCkgLyAoZGYxICogeCArIGRmMiksIGRmMSAvIDIsIGRmMiAvIDIpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHgsIGRmMSwgZGYyKSB7XG4gICAgcmV0dXJuIGRmMiAvIChkZjEgKiAoMSAvIGpTdGF0LmliZXRhaW52KHgsIGRmMSAvIDIsIGRmMiAvIDIpIC0gMSkpO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gKGRmMiA+IDIpID8gZGYyIC8gKGRmMiAtIDIpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoZGYxLCBkZjIpIHtcbiAgICByZXR1cm4gKGRmMSA+IDIpID8gKGRmMiAqIChkZjEgLSAyKSkgLyAoZGYxICogKGRmMiArIDIpKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvLyByZXR1cm4gYSByYW5kb20gc2FtcGxlXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGRmMSwgZGYyKSB7XG4gICAgdmFyIHgxID0galN0YXQucmFuZGcoZGYxIC8gMikgKiAyO1xuICAgIHZhciB4MiA9IGpTdGF0LnJhbmRnKGRmMiAvIDIpICogMjtcbiAgICByZXR1cm4gKHgxIC8gZGYxKSAvICh4MiAvIGRmMik7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGRmMSwgZGYyKSB7XG4gICAgaWYgKGRmMiA8PSA0KVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gMiAqIGRmMiAqIGRmMiAqIChkZjEgKyBkZjIgLSAyKSAvXG4gICAgICAgIChkZjEgKiAoZGYyIC0gMikgKiAoZGYyIC0gMikgKiAoZGYyIC0gNCkpO1xuICB9XG59KTtcblxuXG4vLyBleHRlbmQgY2F1Y2h5IGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5jYXVjaHksIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgbG9jYWwsIHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlIDwgMCkgeyByZXR1cm4gMDsgfVxuXG4gICAgcmV0dXJuIChzY2FsZSAvIChNYXRoLnBvdyh4IC0gbG9jYWwsIDIpICsgTWF0aC5wb3coc2NhbGUsIDIpKSkgLyBNYXRoLlBJO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGxvY2FsLCBzY2FsZSkge1xuICAgIHJldHVybiBNYXRoLmF0YW4oKHggLSBsb2NhbCkgLyBzY2FsZSkgLyBNYXRoLlBJICsgMC41O1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgbG9jYWwsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsICsgc2NhbGUgKiBNYXRoLnRhbihNYXRoLlBJICogKHAgLSAwLjUpKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihsb2NhbC8qLCBzY2FsZSovKSB7XG4gICAgcmV0dXJuIGxvY2FsO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUobG9jYWwvKiwgc2NhbGUqLykge1xuICAgIHJldHVybiBsb2NhbDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShsb2NhbCwgc2NhbGUpIHtcbiAgICByZXR1cm4galN0YXQucmFuZG4oKSAqXG4gICAgICAgIE1hdGguc3FydCgxIC8gKDIgKiBqU3RhdC5yYW5kZygwLjUpKSkgKiBzY2FsZSArIGxvY2FsO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCBjaGlzcXVhcmUgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmNoaXNxdWFyZSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBkb2YpIHtcbiAgICBpZiAoeCA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKHggPT09IDAgJiYgZG9mID09PSAyKSA/IDAuNSA6XG4gICAgICAgIE1hdGguZXhwKChkb2YgLyAyIC0gMSkgKiBNYXRoLmxvZyh4KSAtIHggLyAyIC0gKGRvZiAvIDIpICpcbiAgICAgICAgICAgICAgICAgTWF0aC5sb2coMikgLSBqU3RhdC5nYW1tYWxuKGRvZiAvIDIpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBkb2YpIHtcbiAgICBpZiAoeCA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4galN0YXQubG93UmVnR2FtbWEoZG9mIC8gMiwgeCAvIDIpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgZG9mKSB7XG4gICAgcmV0dXJuIDIgKiBqU3RhdC5nYW1tYXBpbnYocCwgMC41ICogZG9mKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oZG9mKSB7XG4gICAgcmV0dXJuIGRvZjtcbiAgfSxcblxuICAvLyBUT0RPOiB0aGlzIGlzIGFuIGFwcHJveGltYXRpb24gKGlzIHRoZXJlIGEgYmV0dGVyIHdheT8pXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGRvZikge1xuICAgIHJldHVybiBkb2YgKiBNYXRoLnBvdygxIC0gKDIgLyAoOSAqIGRvZikpLCAzKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKGRvZikge1xuICAgIHJldHVybiAoZG9mIC0gMiA+IDApID8gZG9mIC0gMiA6IDA7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoZG9mKSB7XG4gICAgcmV0dXJuIGpTdGF0LnJhbmRnKGRvZiAvIDIpICogMjtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoZG9mKSB7XG4gICAgcmV0dXJuIDIgKiBkb2Y7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIGV4cG9uZW50aWFsIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5leHBvbmVudGlhbCwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCByYXRlKSB7XG4gICAgcmV0dXJuIHggPCAwID8gMCA6IHJhdGUgKiBNYXRoLmV4cCgtcmF0ZSAqIHgpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHJhdGUpIHtcbiAgICByZXR1cm4geCA8IDAgPyAwIDogMSAtIE1hdGguZXhwKC1yYXRlICogeCk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCByYXRlKSB7XG4gICAgcmV0dXJuIC1NYXRoLmxvZygxIC0gcCkgLyByYXRlO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihyYXRlKSB7XG4gICAgcmV0dXJuIDEgLyByYXRlO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gKHJhdGUpIHtcbiAgICByZXR1cm4gKDEgLyByYXRlKSAqIE1hdGgubG9nKDIpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoLypyYXRlKi8pIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShyYXRlKSB7XG4gICAgcmV0dXJuIC0xIC8gcmF0ZSAqIE1hdGgubG9nKGpTdGF0Ll9yYW5kb21fZm4oKSk7XG4gIH0sXG5cbiAgdmFyaWFuY2UgOiBmdW5jdGlvbihyYXRlKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHJhdGUsIC0yKTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgZ2FtbWEgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmdhbW1hLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIHNoYXBlLCBzY2FsZSkge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAoeCA9PT0gMCAmJiBzaGFwZSA9PT0gMSkgPyAxIC8gc2NhbGUgOlxuICAgICAgICAgICAgTWF0aC5leHAoKHNoYXBlIC0gMSkgKiBNYXRoLmxvZyh4KSAtIHggLyBzY2FsZSAtXG4gICAgICAgICAgICAgICAgICAgIGpTdGF0LmdhbW1hbG4oc2hhcGUpIC0gc2hhcGUgKiBNYXRoLmxvZyhzY2FsZSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNoYXBlLCBzY2FsZSkge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiBqU3RhdC5sb3dSZWdHYW1tYShzaGFwZSwgeCAvIHNjYWxlKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBqU3RhdC5nYW1tYXBpbnYocCwgc2hhcGUpICogc2NhbGU7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzaGFwZSAqIHNjYWxlO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoc2hhcGUsIHNjYWxlKSB7XG4gICAgaWYoc2hhcGUgPiAxKSByZXR1cm4gKHNoYXBlIC0gMSkgKiBzY2FsZTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBqU3RhdC5yYW5kZyhzaGFwZSkgKiBzY2FsZTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2Uoc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIHNoYXBlICogc2NhbGUgKiBzY2FsZTtcbiAgfVxufSk7XG5cbi8vIGV4dGVuZCBpbnZlcnNlIGdhbW1hIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5pbnZnYW1tYSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBzaGFwZSwgc2NhbGUpIHtcbiAgICBpZiAoeCA8PSAwKVxuICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIE1hdGguZXhwKC0oc2hhcGUgKyAxKSAqIE1hdGgubG9nKHgpIC0gc2NhbGUgLyB4IC1cbiAgICAgICAgICAgICAgICAgICAgalN0YXQuZ2FtbWFsbihzaGFwZSkgKyBzaGFwZSAqIE1hdGgubG9nKHNjYWxlKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgc2hhcGUsIHNjYWxlKSB7XG4gICAgaWYgKHggPD0gMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAxIC0galN0YXQubG93UmVnR2FtbWEoc2hhcGUsIHNjYWxlIC8geCk7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBzaGFwZSwgc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgLyBqU3RhdC5nYW1tYXBpbnYoMSAtIHAsIHNoYXBlKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oc2hhcGUsIHNjYWxlKSB7XG4gICAgcmV0dXJuIChzaGFwZSA+IDEpID8gc2NhbGUgLyAoc2hhcGUgLSAxKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSAvIChzaGFwZSArIDEpO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKHNoYXBlLCBzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSAvIGpTdGF0LnJhbmRnKHNoYXBlKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2Uoc2hhcGUsIHNjYWxlKSB7XG4gICAgaWYgKHNoYXBlIDw9IDIpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzY2FsZSAqIHNjYWxlIC8gKChzaGFwZSAtIDEpICogKHNoYXBlIC0gMSkgKiAoc2hhcGUgLSAyKSk7XG4gIH1cbn0pO1xuXG5cbi8vIGV4dGVuZCBrdW1hcmFzd2FteSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQua3VtYXJhc3dhbXksIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgYWxwaGEsIGJldGEpIHtcbiAgICBpZiAoeCA9PT0gMCAmJiBhbHBoYSA9PT0gMSlcbiAgICAgIHJldHVybiBiZXRhO1xuICAgIGVsc2UgaWYgKHggPT09IDEgJiYgYmV0YSA9PT0gMSlcbiAgICAgIHJldHVybiBhbHBoYTtcbiAgICByZXR1cm4gTWF0aC5leHAoTWF0aC5sb2coYWxwaGEpICsgTWF0aC5sb2coYmV0YSkgKyAoYWxwaGEgLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKHgpICsgKGJldGEgLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubG9nKDEgLSBNYXRoLnBvdyh4LCBhbHBoYSkpKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBhbHBoYSwgYmV0YSkge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIGVsc2UgaWYgKHggPiAxKVxuICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuICgxIC0gTWF0aC5wb3coMSAtIE1hdGgucG93KHgsIGFscGhhKSwgYmV0YSkpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHAsIGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEgLSBNYXRoLnBvdygxIC0gcCwgMSAvIGJldGEpLCAxIC8gYWxwaGEpO1xuICB9LFxuXG4gIG1lYW4gOiBmdW5jdGlvbihhbHBoYSwgYmV0YSkge1xuICAgIHJldHVybiAoYmV0YSAqIGpTdGF0LmdhbW1hZm4oMSArIDEgLyBhbHBoYSkgKlxuICAgICAgICAgICAgalN0YXQuZ2FtbWFmbihiZXRhKSkgLyAoalN0YXQuZ2FtbWFmbigxICsgMSAvIGFscGhhICsgYmV0YSkpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGFscGhhLCBiZXRhKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEgLSBNYXRoLnBvdygyLCAtMSAvIGJldGEpLCAxIC8gYWxwaGEpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoYWxwaGEsIGJldGEpIHtcbiAgICBpZiAoIShhbHBoYSA+PSAxICYmIGJldGEgPj0gMSAmJiAoYWxwaGEgIT09IDEgJiYgYmV0YSAhPT0gMSkpKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gTWF0aC5wb3coKGFscGhhIC0gMSkgLyAoYWxwaGEgKiBiZXRhIC0gMSksIDEgLyBhbHBoYSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKC8qYWxwaGEsIGJldGEqLykge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFuY2Ugbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgIC8vIFRPRE86IGNvbXBsZXRlIHRoaXNcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgbG9nbm9ybWFsIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5sb2dub3JtYWwsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgbXUsIHNpZ21hKSB7XG4gICAgaWYgKHggPD0gMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiBNYXRoLmV4cCgtTWF0aC5sb2coeCkgLSAwLjUgKiBNYXRoLmxvZygyICogTWF0aC5QSSkgLVxuICAgICAgICAgICAgICAgICAgICBNYXRoLmxvZyhzaWdtYSkgLSBNYXRoLnBvdyhNYXRoLmxvZyh4KSAtIG11LCAyKSAvXG4gICAgICAgICAgICAgICAgICAgICgyICogc2lnbWEgKiBzaWdtYSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIG11LCBzaWdtYSkge1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAwLjUgK1xuICAgICAgICAoMC41ICogalN0YXQuZXJmKChNYXRoLmxvZyh4KSAtIG11KSAvIE1hdGguc3FydCgyICogc2lnbWEgKiBzaWdtYSkpKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIG11LCBzaWdtYSkge1xuICAgIHJldHVybiBNYXRoLmV4cCgtMS40MTQyMTM1NjIzNzMwOTUwNSAqIHNpZ21hICogalN0YXQuZXJmY2ludigyICogcCkgKyBtdSk7XG4gIH0sXG5cbiAgbWVhbjogZnVuY3Rpb24gbWVhbihtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAobXUgKyBzaWdtYSAqIHNpZ21hIC8gMik7XG4gIH0sXG5cbiAgbWVkaWFuOiBmdW5jdGlvbiBtZWRpYW4obXUvKiwgc2lnbWEqLykge1xuICAgIHJldHVybiBNYXRoLmV4cChtdSk7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZShtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAobXUgLSBzaWdtYSAqIHNpZ21hKTtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gTWF0aC5leHAoalN0YXQucmFuZG4oKSAqIHNpZ21hICsgbXUpO1xuICB9LFxuXG4gIHZhcmlhbmNlOiBmdW5jdGlvbiB2YXJpYW5jZShtdSwgc2lnbWEpIHtcbiAgICByZXR1cm4gKE1hdGguZXhwKHNpZ21hICogc2lnbWEpIC0gMSkgKiBNYXRoLmV4cCgyICogbXUgKyBzaWdtYSAqIHNpZ21hKTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgbm9uY2VudHJhbHQgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0Lm5vbmNlbnRyYWx0LCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGRvZiwgbmNwKSB7XG4gICAgdmFyIHRvbCA9IDFlLTE0O1xuICAgIGlmIChNYXRoLmFicyhuY3ApIDwgdG9sKSAgLy8gbmNwIGFwcHJveCAwOyB1c2Ugc3R1ZGVudC10XG4gICAgICByZXR1cm4galN0YXQuc3R1ZGVudHQucGRmKHgsIGRvZilcblxuICAgIGlmIChNYXRoLmFicyh4KSA8IHRvbCkgeyAgLy8gZGlmZmVyZW50IGZvcm11bGEgZm9yIHggPT0gMFxuICAgICAgcmV0dXJuIE1hdGguZXhwKGpTdGF0LmdhbW1hbG4oKGRvZiArIDEpIC8gMikgLSBuY3AgKiBuY3AgLyAyIC1cbiAgICAgICAgICAgICAgICAgICAgICAwLjUgKiBNYXRoLmxvZyhNYXRoLlBJICogZG9mKSAtIGpTdGF0LmdhbW1hbG4oZG9mIC8gMikpO1xuICAgIH1cblxuICAgIC8vIGZvcm11bGEgZm9yIHggIT0gMFxuICAgIHJldHVybiBkb2YgLyB4ICpcbiAgICAgICAgKGpTdGF0Lm5vbmNlbnRyYWx0LmNkZih4ICogTWF0aC5zcXJ0KDEgKyAyIC8gZG9mKSwgZG9mKzIsIG5jcCkgLVxuICAgICAgICAgalN0YXQubm9uY2VudHJhbHQuY2RmKHgsIGRvZiwgbmNwKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgZG9mLCBuY3ApIHtcbiAgICB2YXIgdG9sID0gMWUtMTQ7XG4gICAgdmFyIG1pbl9pdGVyYXRpb25zID0gMjAwO1xuXG4gICAgaWYgKE1hdGguYWJzKG5jcCkgPCB0b2wpICAvLyBuY3AgYXBwcm94IDA7IHVzZSBzdHVkZW50LXRcbiAgICAgIHJldHVybiBqU3RhdC5zdHVkZW50dC5jZGYoeCwgZG9mKTtcblxuICAgIC8vIHR1cm4gbmVnYXRpdmUgeCBpbnRvIHBvc2l0aXZlIGFuZCBmbGlwIHJlc3VsdCBhZnRlcndhcmRzXG4gICAgdmFyIGZsaXAgPSBmYWxzZTtcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIGZsaXAgPSB0cnVlO1xuICAgICAgbmNwID0gLW5jcDtcbiAgICB9XG5cbiAgICB2YXIgcHJvYiA9IGpTdGF0Lm5vcm1hbC5jZGYoLW5jcCwgMCwgMSk7XG4gICAgdmFyIHZhbHVlID0gdG9sICsgMTtcbiAgICAvLyB1c2UgdmFsdWUgYXQgbGFzdCB0d28gc3RlcHMgdG8gZGV0ZXJtaW5lIGNvbnZlcmdlbmNlXG4gICAgdmFyIGxhc3R2YWx1ZSA9IHZhbHVlO1xuICAgIHZhciB5ID0geCAqIHggLyAoeCAqIHggKyBkb2YpO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIgcCA9IE1hdGguZXhwKC1uY3AgKiBuY3AgLyAyKTtcbiAgICB2YXIgcSA9IE1hdGguZXhwKC1uY3AgKiBuY3AgLyAyIC0gMC41ICogTWF0aC5sb2coMikgLVxuICAgICAgICAgICAgICAgICAgICAgalN0YXQuZ2FtbWFsbigzIC8gMikpICogbmNwO1xuICAgIHdoaWxlIChqIDwgbWluX2l0ZXJhdGlvbnMgfHwgbGFzdHZhbHVlID4gdG9sIHx8IHZhbHVlID4gdG9sKSB7XG4gICAgICBsYXN0dmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBwICo9IChuY3AgKiBuY3ApIC8gKDIgKiBqKTtcbiAgICAgICAgcSAqPSAobmNwICogbmNwKSAvICgyICogKGogKyAxIC8gMikpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBwICogalN0YXQuYmV0YS5jZGYoeSwgaiArIDAuNSwgZG9mIC8gMikgK1xuICAgICAgICAgIHEgKiBqU3RhdC5iZXRhLmNkZih5LCBqKzEsIGRvZi8yKTtcbiAgICAgIHByb2IgKz0gMC41ICogdmFsdWU7XG4gICAgICBqKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsaXAgPyAoMSAtIHByb2IpIDogcHJvYjtcbiAgfVxufSk7XG5cblxuLy8gZXh0ZW5kIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQubm9ybWFsLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBNYXRoLmV4cCgtMC41ICogTWF0aC5sb2coMiAqIE1hdGguUEkpIC1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5sb2coc3RkKSAtIE1hdGgucG93KHggLSBtZWFuLCAyKSAvICgyICogc3RkICogc3RkKSk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbWVhbiwgc3RkKSB7XG4gICAgcmV0dXJuIDAuNSAqICgxICsgalN0YXQuZXJmKCh4IC0gbWVhbikgLyBNYXRoLnNxcnQoMiAqIHN0ZCAqIHN0ZCkpKTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiAtMS40MTQyMTM1NjIzNzMwOTUwNSAqIHN0ZCAqIGpTdGF0LmVyZmNpbnYoMiAqIHApICsgbWVhbjtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24obWVhbi8qLCBzdGQqLykge1xuICAgIHJldHVybiBtZWFuO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKG1lYW4vKiwgc3RkKi8pIHtcbiAgICByZXR1cm4gbWVhbjtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiAobWVhbi8qLCBzdGQqLykge1xuICAgIHJldHVybiBtZWFuO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBqU3RhdC5yYW5kbigpICogc3RkICsgbWVhbjtcbiAgfSxcblxuICB2YXJpYW5jZSA6IGZ1bmN0aW9uKG1lYW4sIHN0ZCkge1xuICAgIHJldHVybiBzdGQgKiBzdGQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHBhcmV0byBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQucGFyZXRvLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIGlmICh4IDwgc2NhbGUpXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKHNoYXBlICogTWF0aC5wb3coc2NhbGUsIHNoYXBlKSkgLyBNYXRoLnBvdyh4LCBzaGFwZSArIDEpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIGlmICh4IDwgc2NhbGUpXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KHNjYWxlIC8geCwgc2hhcGUpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHAsIHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZSAvIE1hdGgucG93KDEgLSBwLCAxIC8gc2hhcGUpO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oc2NhbGUsIHNoYXBlKSB7XG4gICAgaWYgKHNoYXBlIDw9IDEpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiAoc2hhcGUgKiBNYXRoLnBvdyhzY2FsZSwgc2hhcGUpKSAvIChzaGFwZSAtIDEpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiBzY2FsZSAqIChzaGFwZSAqIE1hdGguU1FSVDIpO1xuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoc2NhbGUvKiwgc2hhcGUqLykge1xuICAgIHJldHVybiBzY2FsZTtcbiAgfSxcblxuICB2YXJpYW5jZSA6IGZ1bmN0aW9uKHNjYWxlLCBzaGFwZSkge1xuICAgIGlmIChzaGFwZSA8PSAyKVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gKHNjYWxlKnNjYWxlICogc2hhcGUpIC8gKE1hdGgucG93KHNoYXBlIC0gMSwgMikgKiAoc2hhcGUgLSAyKSk7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHN0dWRlbnR0IGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5zdHVkZW50dCwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBkb2YpIHtcbiAgICBkb2YgPSBkb2YgPiAxZTEwMCA/IDFlMTAwIDogZG9mO1xuICAgIHJldHVybiAoMS8oTWF0aC5zcXJ0KGRvZikgKiBqU3RhdC5iZXRhZm4oMC41LCBkb2YvMikpKSAqXG4gICAgICAgIE1hdGgucG93KDEgKyAoKHggKiB4KSAvIGRvZiksIC0oKGRvZiArIDEpIC8gMikpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGRvZikge1xuICAgIHZhciBkb2YyID0gZG9mIC8gMjtcbiAgICByZXR1cm4galN0YXQuaWJldGEoKHggKyBNYXRoLnNxcnQoeCAqIHggKyBkb2YpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICgyICogTWF0aC5zcXJ0KHggKiB4ICsgZG9mKSksIGRvZjIsIGRvZjIpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgZG9mKSB7XG4gICAgdmFyIHggPSBqU3RhdC5pYmV0YWludigyICogTWF0aC5taW4ocCwgMSAtIHApLCAwLjUgKiBkb2YsIDAuNSk7XG4gICAgeCA9IE1hdGguc3FydChkb2YgKiAoMSAtIHgpIC8geCk7XG4gICAgcmV0dXJuIChwID4gMC41KSA/IHggOiAteDtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGRvZikge1xuICAgIHJldHVybiAoZG9mID4gMSkgPyAwIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKC8qZG9mKi8pIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKC8qZG9mKi8pIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShkb2YpIHtcbiAgICByZXR1cm4galN0YXQucmFuZG4oKSAqIE1hdGguc3FydChkb2YgLyAoMiAqIGpTdGF0LnJhbmRnKGRvZiAvIDIpKSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGRvZikge1xuICAgIHJldHVybiAoZG9mICA+IDIpID8gZG9mIC8gKGRvZiAtIDIpIDogKGRvZiA+IDEpID8gSW5maW5pdHkgOiB1bmRlZmluZWQ7XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHdlaWJ1bGwgZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LndlaWJ1bGwsIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoeCwgc2NhbGUsIHNoYXBlKSB7XG4gICAgaWYgKHggPCAwIHx8IHNjYWxlIDwgMCB8fCBzaGFwZSA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKHNoYXBlIC8gc2NhbGUpICogTWF0aC5wb3coKHggLyBzY2FsZSksIChzaGFwZSAtIDEpKSAqXG4gICAgICAgIE1hdGguZXhwKC0oTWF0aC5wb3coKHggLyBzY2FsZSksIHNoYXBlKSkpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIHNjYWxlLCBzaGFwZSkge1xuICAgIHJldHVybiB4IDwgMCA/IDAgOiAxIC0gTWF0aC5leHAoLU1hdGgucG93KCh4IC8gc2NhbGUpLCBzaGFwZSkpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24ocCwgc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogTWF0aC5wb3coLU1hdGgubG9nKDEgLSBwKSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBtZWFuIDogZnVuY3Rpb24oc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogalN0YXQuZ2FtbWFmbigxICsgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBNYXRoLnBvdyhNYXRoLmxvZygyKSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKHNjYWxlLCBzaGFwZSkge1xuICAgIGlmIChzaGFwZSA8PSAxKVxuICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHNjYWxlICogTWF0aC5wb3coKHNoYXBlIC0gMSkgLyBzaGFwZSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShzY2FsZSwgc2hhcGUpIHtcbiAgICByZXR1cm4gc2NhbGUgKiBNYXRoLnBvdygtTWF0aC5sb2coalN0YXQuX3JhbmRvbV9mbigpKSwgMSAvIHNoYXBlKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2Uoc2NhbGUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIHNjYWxlICogc2NhbGUgKiBqU3RhdC5nYW1tYWZuKDEgKyAyIC8gc2hhcGUpIC1cbiAgICAgICAgTWF0aC5wb3coalN0YXQud2VpYnVsbC5tZWFuKHNjYWxlLCBzaGFwZSksIDIpO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB1bmlmb3JtIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC51bmlmb3JtLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGEsIGIpIHtcbiAgICByZXR1cm4gKHggPCBhIHx8IHggPiBiKSA/IDAgOiAxIC8gKGIgLSBhKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCBhLCBiKSB7XG4gICAgaWYgKHggPCBhKVxuICAgICAgcmV0dXJuIDA7XG4gICAgZWxzZSBpZiAoeCA8IGIpXG4gICAgICByZXR1cm4gKHggLSBhKSAvIChiIC0gYSk7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG5cbiAgaW52OiBmdW5jdGlvbihwLCBhLCBiKSB7XG4gICAgcmV0dXJuIGEgKyAocCAqIChiIC0gYSkpO1xuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uIG1lYW4oYSwgYikge1xuICAgIHJldHVybiAwLjUgKiAoYSArIGIpO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGEsIGIpIHtcbiAgICByZXR1cm4galN0YXQubWVhbihhLCBiKTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbiBtb2RlKC8qYSwgYiovKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShhLCBiKSB7XG4gICAgcmV0dXJuIChhIC8gMiArIGIgLyAyKSArIChiIC8gMiAtIGEgLyAyKSAqICgyICogalN0YXQuX3JhbmRvbV9mbigpIC0gMSk7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uIHZhcmlhbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coYiAtIGEsIDIpIC8gMTI7XG4gIH1cbn0pO1xuXG5cbi8vIEdvdCB0aGlzIGZyb20gaHR0cDovL3d3dy5tYXRoLnVjbGEuZWR1L350b20vZGlzdHJpYnV0aW9ucy9iaW5vbWlhbC5odG1sXG5mdW5jdGlvbiBiZXRpbmMoeCwgYSwgYiwgZXBzKSB7XG4gIHZhciBhMCA9IDA7XG4gIHZhciBiMCA9IDE7XG4gIHZhciBhMSA9IDE7XG4gIHZhciBiMSA9IDE7XG4gIHZhciBtOSA9IDA7XG4gIHZhciBhMiA9IDA7XG4gIHZhciBjOTtcblxuICB3aGlsZSAoTWF0aC5hYnMoKGExIC0gYTIpIC8gYTEpID4gZXBzKSB7XG4gICAgYTIgPSBhMTtcbiAgICBjOSA9IC0oYSArIG05KSAqIChhICsgYiArIG05KSAqIHggLyAoYSArIDIgKiBtOSkgLyAoYSArIDIgKiBtOSArIDEpO1xuICAgIGEwID0gYTEgKyBjOSAqIGEwO1xuICAgIGIwID0gYjEgKyBjOSAqIGIwO1xuICAgIG05ID0gbTkgKyAxO1xuICAgIGM5ID0gbTkgKiAoYiAtIG05KSAqIHggLyAoYSArIDIgKiBtOSAtIDEpIC8gKGEgKyAyICogbTkpO1xuICAgIGExID0gYTAgKyBjOSAqIGExO1xuICAgIGIxID0gYjAgKyBjOSAqIGIxO1xuICAgIGEwID0gYTAgLyBiMTtcbiAgICBiMCA9IGIwIC8gYjE7XG4gICAgYTEgPSBhMSAvIGIxO1xuICAgIGIxID0gMTtcbiAgfVxuXG4gIHJldHVybiBhMSAvIGE7XG59XG5cblxuLy8gZXh0ZW5kIHVuaWZvcm0gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LmJpbm9taWFsLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKGssIG4sIHApIHtcbiAgICByZXR1cm4gKHAgPT09IDAgfHwgcCA9PT0gMSkgP1xuICAgICAgKChuICogcCkgPT09IGsgPyAxIDogMCkgOlxuICAgICAgalN0YXQuY29tYmluYXRpb24obiwgaykgKiBNYXRoLnBvdyhwLCBrKSAqIE1hdGgucG93KDEgLSBwLCBuIC0gayk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbiwgcCkge1xuICAgIHZhciBiZXRhY2RmO1xuICAgIHZhciBlcHMgPSAxZS0xMDtcblxuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiAwO1xuICAgIGlmICh4ID49IG4pXG4gICAgICByZXR1cm4gMTtcbiAgICBpZiAocCA8IDAgfHwgcCA+IDEgfHwgbiA8PSAwKVxuICAgICAgcmV0dXJuIE5hTjtcblxuICAgIHggPSBNYXRoLmZsb29yKHgpO1xuICAgIHZhciB6ID0gcDtcbiAgICB2YXIgYSA9IHggKyAxO1xuICAgIHZhciBiID0gbiAtIHg7XG4gICAgdmFyIHMgPSBhICsgYjtcbiAgICB2YXIgYnQgPSBNYXRoLmV4cChqU3RhdC5nYW1tYWxuKHMpIC0galN0YXQuZ2FtbWFsbihiKSAtXG4gICAgICAgICAgICAgICAgICAgICAgalN0YXQuZ2FtbWFsbihhKSArIGEgKiBNYXRoLmxvZyh6KSArIGIgKiBNYXRoLmxvZygxIC0geikpO1xuXG4gICAgaWYgKHogPCAoYSArIDEpIC8gKHMgKyAyKSlcbiAgICAgIGJldGFjZGYgPSBidCAqIGJldGluYyh6LCBhLCBiLCBlcHMpO1xuICAgIGVsc2VcbiAgICAgIGJldGFjZGYgPSAxIC0gYnQgKiBiZXRpbmMoMSAtIHosIGIsIGEsIGVwcyk7XG5cbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoMSAtIGJldGFjZGYpICogKDEgLyBlcHMpKSAvICgxIC8gZXBzKTtcbiAgfVxufSk7XG5cblxuXG4vLyBleHRlbmQgdW5pZm9ybSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQubmVnYmluLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKGssIHIsIHApIHtcbiAgICBpZiAoayAhPT0gayA+Pj4gMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoayA8IDApXG4gICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4galN0YXQuY29tYmluYXRpb24oayArIHIgLSAxLCByIC0gMSkgKlxuICAgICAgICBNYXRoLnBvdygxIC0gcCwgaykgKiBNYXRoLnBvdyhwLCByKTtcbiAgfSxcblxuICBjZGY6IGZ1bmN0aW9uIGNkZih4LCByLCBwKSB7XG4gICAgdmFyIHN1bSA9IDAsXG4gICAgayA9IDA7XG4gICAgaWYgKHggPCAwKSByZXR1cm4gMDtcbiAgICBmb3IgKDsgayA8PSB4OyBrKyspIHtcbiAgICAgIHN1bSArPSBqU3RhdC5uZWdiaW4ucGRmKGssIHIsIHApO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xuICB9XG59KTtcblxuXG5cbi8vIGV4dGVuZCB1bmlmb3JtIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC5oeXBnZW9tLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKGssIE4sIG0sIG4pIHtcbiAgICAvLyBIeXBlcmdlb21ldHJpYyBQREYuXG5cbiAgICAvLyBBIHNpbXBsaWZpY2F0aW9uIG9mIHRoZSBDREYgYWxnb3JpdGhtIGJlbG93LlxuXG4gICAgLy8gayA9IG51bWJlciBvZiBzdWNjZXNzZXMgZHJhd25cbiAgICAvLyBOID0gcG9wdWxhdGlvbiBzaXplXG4gICAgLy8gbSA9IG51bWJlciBvZiBzdWNjZXNzZXMgaW4gcG9wdWxhdGlvblxuICAgIC8vIG4gPSBudW1iZXIgb2YgaXRlbXMgZHJhd24gZnJvbSBwb3B1bGF0aW9uXG5cbiAgICBpZihrICE9PSBrIHwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZihrIDwgMCB8fCBrIDwgbSAtIChOIC0gbikpIHtcbiAgICAgIC8vIEl0J3MgaW1wb3NzaWJsZSB0byBoYXZlIHRoaXMgZmV3IHN1Y2Nlc3NlcyBkcmF3bi5cbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZihrID4gbiB8fCBrID4gbSkge1xuICAgICAgLy8gSXQncyBpbXBvc3NpYmxlIHRvIGhhdmUgdGhpcyBtYW55IHN1Y2Nlc3NlcyBkcmF3bi5cbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAobSAqIDIgPiBOKSB7XG4gICAgICAvLyBNb3JlIHRoYW4gaGFsZiB0aGUgcG9wdWxhdGlvbiBpcyBzdWNjZXNzZXMuXG5cbiAgICAgIGlmKG4gKiAyID4gTikge1xuICAgICAgICAvLyBNb3JlIHRoYW4gaGFsZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuXG4gICAgICAgIHJldHVybiBqU3RhdC5oeXBnZW9tLnBkZihOIC0gbSAtIG4gKyBrLCBOLCBOIC0gbSwgTiAtIG4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYWxmIG9yIGxlc3Mgb2YgdGhlIHBvcHVsYXRpb24gaXMgc2FtcGxlZC5cblxuICAgICAgICByZXR1cm4galN0YXQuaHlwZ2VvbS5wZGYobiAtIGssIE4sIE4gLSBtLCBuKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZihuICogMiA+IE4pIHtcbiAgICAgIC8vIEhhbGYgb3IgbGVzcyBpcyBzdWNjZXNzZXMuXG5cbiAgICAgIHJldHVybiBqU3RhdC5oeXBnZW9tLnBkZihtIC0gaywgTiwgbSwgTiAtIG4pO1xuXG4gICAgfSBlbHNlIGlmKG0gPCBuKSB7XG4gICAgICAvLyBXZSB3YW50IHRvIGhhdmUgdGhlIG51bWJlciBvZiB0aGluZ3Mgc2FtcGxlZCB0byBiZSBsZXNzIHRoYW4gdGhlXG4gICAgICAvLyBzdWNjZXNzZXMgYXZhaWxhYmxlLiBTbyBzd2FwIHRoZSBkZWZpbml0aW9ucyBvZiBzdWNjZXNzZnVsIGFuZCBzYW1wbGVkLlxuICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20ucGRmKGssIE4sIG4sIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgaGFsZiBvciBsZXNzIG9mIHRoZSBwb3B1bGF0aW9uIHdhcyBzYW1wbGVkLCBoYWxmIG9yXG4gICAgICAvLyBsZXNzIG9mIGl0IHdhcyBzdWNjZXNzZXMsIGFuZCB3ZSBoYWQgZmV3ZXIgc2FtcGxlZCB0aGluZ3MgdGhhblxuICAgICAgLy8gc3VjY2Vzc2VzLiBOb3cgd2UgY2FuIGRvIHRoaXMgY29tcGxpY2F0ZWQgaXRlcmF0aXZlIGFsZ29yaXRobSBpbiBhblxuICAgICAgLy8gZWZmaWNpZW50IHdheS5cblxuICAgICAgLy8gVGhlIGJhc2ljIHByZW1pc2Ugb2YgdGhlIGFsZ29yaXRobSBpcyB0aGF0IHdlIHBhcnRpYWxseSBub3JtYWxpemUgb3VyXG4gICAgICAvLyBpbnRlcm1lZGlhdGUgcHJvZHVjdCB0byBrZWVwIGl0IGluIGEgbnVtZXJpY2FsbHkgZ29vZCByZWdpb24sIGFuZCB0aGVuXG4gICAgICAvLyBmaW5pc2ggdGhlIG5vcm1hbGl6YXRpb24gYXQgdGhlIGVuZC5cblxuICAgICAgLy8gVGhpcyB2YXJpYWJsZSBob2xkcyB0aGUgc2NhbGVkIHByb2JhYmlsaXR5IG9mIHRoZSBjdXJyZW50IG51bWJlciBvZlxuICAgICAgLy8gc3VjY2Vzc2VzLlxuICAgICAgdmFyIHNjYWxlZFBERiA9IDE7XG5cbiAgICAgIC8vIFRoaXMga2VlcHMgdHJhY2sgb2YgaG93IG11Y2ggd2UgaGF2ZSBub3JtYWxpemVkLlxuICAgICAgdmFyIHNhbXBsZXNEb25lID0gMDtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICAvLyBGb3IgZXZlcnkgcG9zc2libGUgbnVtYmVyIG9mIHN1Y2Nlc3NlcyB1cCB0byB0aGF0IG9ic2VydmVkLi4uXG5cbiAgICAgICAgd2hpbGUoc2NhbGVkUERGID4gMSAmJiBzYW1wbGVzRG9uZSA8IG4pIHtcbiAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgcmVzdWx0IGlzIGdyb3dpbmcgdG9vIGJpZy4gQXBwbHkgc29tZSBvZiB0aGVcbiAgICAgICAgICAvLyBub3JtYWxpemF0aW9uIHRvIHNocmluayBldmVyeXRoaW5nLlxuXG4gICAgICAgICAgc2NhbGVkUERGICo9IDEgLSAobSAvIChOIC0gc2FtcGxlc0RvbmUpKTtcblxuICAgICAgICAgIC8vIFNheSB3ZSd2ZSBub3JtYWxpemVkIGJ5IHRoaXMgc2FtcGxlIGFscmVhZHkuXG4gICAgICAgICAgc2FtcGxlc0RvbmUrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdvcmsgb3V0IHRoZSBwYXJ0aWFsbHktbm9ybWFsaXplZCBoeXBlcmdlb21ldHJpYyBQREYgZm9yIHRoZSBuZXh0XG4gICAgICAgIC8vIG51bWJlciBvZiBzdWNjZXNzZXNcbiAgICAgICAgc2NhbGVkUERGICo9IChuIC0gaSkgKiAobSAtIGkpIC8gKChpICsgMSkgKiAoTiAtIG0gLSBuICsgaSArIDEpKTtcbiAgICAgIH1cblxuICAgICAgZm9yKDsgc2FtcGxlc0RvbmUgPCBuOyBzYW1wbGVzRG9uZSsrKSB7XG4gICAgICAgIC8vIEFwcGx5IGFsbCB0aGUgcmVzdCBvZiB0aGUgbm9ybWFsaXphdGlvblxuICAgICAgICBzY2FsZWRQREYgKj0gMSAtIChtIC8gKE4gLSBzYW1wbGVzRG9uZSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBCb3VuZCBhbnN3ZXIgc2FuZWx5IGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgc2NhbGVkUERGKSk7XG4gICAgfVxuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIE4sIG0sIG4pIHtcbiAgICAvLyBIeXBlcmdlb21ldHJpYyBDREYuXG5cbiAgICAvLyBUaGlzIGFsZ29yaXRobSBpcyBkdWUgdG8gUHJvZi4gVGhvbWFzIFMuIEZlcmd1c29uLCA8dG9tQG1hdGgudWNsYS5lZHU+LFxuICAgIC8vIGFuZCBjb21lcyBmcm9tIGhpcyBoeXBlcmdlb21ldHJpYyB0ZXN0IGNhbGN1bGF0b3IgYXRcbiAgICAvLyA8aHR0cDovL3d3dy5tYXRoLnVjbGEuZWR1L350b20vZGlzdHJpYnV0aW9ucy9IeXBlcmdlb21ldHJpYy5odG1sPi5cblxuICAgIC8vIHggPSBudW1iZXIgb2Ygc3VjY2Vzc2VzIGRyYXduXG4gICAgLy8gTiA9IHBvcHVsYXRpb24gc2l6ZVxuICAgIC8vIG0gPSBudW1iZXIgb2Ygc3VjY2Vzc2VzIGluIHBvcHVsYXRpb25cbiAgICAvLyBuID0gbnVtYmVyIG9mIGl0ZW1zIGRyYXduIGZyb20gcG9wdWxhdGlvblxuXG4gICAgaWYoeCA8IDAgfHwgeCA8IG0gLSAoTiAtIG4pKSB7XG4gICAgICAvLyBJdCdzIGltcG9zc2libGUgdG8gaGF2ZSB0aGlzIGZldyBzdWNjZXNzZXMgZHJhd24gb3IgZmV3ZXIuXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYoeCA+PSBuIHx8IHggPj0gbSkge1xuICAgICAgLy8gV2Ugd2lsbCBhbHdheXMgaGF2ZSB0aGlzIG1hbnkgc3VjY2Vzc2VzIG9yIGZld2VyLlxuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChtICogMiA+IE4pIHtcbiAgICAgIC8vIE1vcmUgdGhhbiBoYWxmIHRoZSBwb3B1bGF0aW9uIGlzIHN1Y2Nlc3Nlcy5cblxuICAgICAgaWYobiAqIDIgPiBOKSB7XG4gICAgICAgIC8vIE1vcmUgdGhhbiBoYWxmIHRoZSBwb3B1bGF0aW9uIGlzIHNhbXBsZWQuXG5cbiAgICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20uY2RmKE4gLSBtIC0gbiArIHgsIE4sIE4gLSBtLCBOIC0gbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbGYgb3IgbGVzcyBvZiB0aGUgcG9wdWxhdGlvbiBpcyBzYW1wbGVkLlxuXG4gICAgICAgIHJldHVybiAxIC0galN0YXQuaHlwZ2VvbS5jZGYobiAtIHggLSAxLCBOLCBOIC0gbSwgbik7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYobiAqIDIgPiBOKSB7XG4gICAgICAvLyBIYWxmIG9yIGxlc3MgaXMgc3VjY2Vzc2VzLlxuXG4gICAgICByZXR1cm4gMSAtIGpTdGF0Lmh5cGdlb20uY2RmKG0gLSB4IC0gMSwgTiwgbSwgTiAtIG4pO1xuXG4gICAgfSBlbHNlIGlmKG0gPCBuKSB7XG4gICAgICAvLyBXZSB3YW50IHRvIGhhdmUgdGhlIG51bWJlciBvZiB0aGluZ3Mgc2FtcGxlZCB0byBiZSBsZXNzIHRoYW4gdGhlXG4gICAgICAvLyBzdWNjZXNzZXMgYXZhaWxhYmxlLiBTbyBzd2FwIHRoZSBkZWZpbml0aW9ucyBvZiBzdWNjZXNzZnVsIGFuZCBzYW1wbGVkLlxuICAgICAgcmV0dXJuIGpTdGF0Lmh5cGdlb20uY2RmKHgsIE4sIG4sIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgaGFsZiBvciBsZXNzIG9mIHRoZSBwb3B1bGF0aW9uIHdhcyBzYW1wbGVkLCBoYWxmIG9yXG4gICAgICAvLyBsZXNzIG9mIGl0IHdhcyBzdWNjZXNzZXMsIGFuZCB3ZSBoYWQgZmV3ZXIgc2FtcGxlZCB0aGluZ3MgdGhhblxuICAgICAgLy8gc3VjY2Vzc2VzLiBOb3cgd2UgY2FuIGRvIHRoaXMgY29tcGxpY2F0ZWQgaXRlcmF0aXZlIGFsZ29yaXRobSBpbiBhblxuICAgICAgLy8gZWZmaWNpZW50IHdheS5cblxuICAgICAgLy8gVGhlIGJhc2ljIHByZW1pc2Ugb2YgdGhlIGFsZ29yaXRobSBpcyB0aGF0IHdlIHBhcnRpYWxseSBub3JtYWxpemUgb3VyXG4gICAgICAvLyBpbnRlcm1lZGlhdGUgc3VtIHRvIGtlZXAgaXQgaW4gYSBudW1lcmljYWxseSBnb29kIHJlZ2lvbiwgYW5kIHRoZW5cbiAgICAgIC8vIGZpbmlzaCB0aGUgbm9ybWFsaXphdGlvbiBhdCB0aGUgZW5kLlxuXG4gICAgICAvLyBIb2xkcyB0aGUgaW50ZXJtZWRpYXRlLCBzY2FsZWQgdG90YWwgQ0RGLlxuICAgICAgdmFyIHNjYWxlZENERiA9IDE7XG5cbiAgICAgIC8vIFRoaXMgdmFyaWFibGUgaG9sZHMgdGhlIHNjYWxlZCBwcm9iYWJpbGl0eSBvZiB0aGUgY3VycmVudCBudW1iZXIgb2ZcbiAgICAgIC8vIHN1Y2Nlc3Nlcy5cbiAgICAgIHZhciBzY2FsZWRQREYgPSAxO1xuXG4gICAgICAvLyBUaGlzIGtlZXBzIHRyYWNrIG9mIGhvdyBtdWNoIHdlIGhhdmUgbm9ybWFsaXplZC5cbiAgICAgIHZhciBzYW1wbGVzRG9uZSA9IDA7XG5cbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4OyBpKyspIHtcbiAgICAgICAgLy8gRm9yIGV2ZXJ5IHBvc3NpYmxlIG51bWJlciBvZiBzdWNjZXNzZXMgdXAgdG8gdGhhdCBvYnNlcnZlZC4uLlxuXG4gICAgICAgIHdoaWxlKHNjYWxlZENERiA+IDEgJiYgc2FtcGxlc0RvbmUgPCBuKSB7XG4gICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIHJlc3VsdCBpcyBncm93aW5nIHRvbyBiaWcuIEFwcGx5IHNvbWUgb2YgdGhlXG4gICAgICAgICAgLy8gbm9ybWFsaXphdGlvbiB0byBzaHJpbmsgZXZlcnl0aGluZy5cblxuICAgICAgICAgIHZhciBmYWN0b3IgPSAxIC0gKG0gLyAoTiAtIHNhbXBsZXNEb25lKSk7XG5cbiAgICAgICAgICBzY2FsZWRQREYgKj0gZmFjdG9yO1xuICAgICAgICAgIHNjYWxlZENERiAqPSBmYWN0b3I7XG5cbiAgICAgICAgICAvLyBTYXkgd2UndmUgbm9ybWFsaXplZCBieSB0aGlzIHNhbXBsZSBhbHJlYWR5LlxuICAgICAgICAgIHNhbXBsZXNEb25lKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXb3JrIG91dCB0aGUgcGFydGlhbGx5LW5vcm1hbGl6ZWQgaHlwZXJnZW9tZXRyaWMgUERGIGZvciB0aGUgbmV4dFxuICAgICAgICAvLyBudW1iZXIgb2Ygc3VjY2Vzc2VzXG4gICAgICAgIHNjYWxlZFBERiAqPSAobiAtIGkpICogKG0gLSBpKSAvICgoaSArIDEpICogKE4gLSBtIC0gbiArIGkgKyAxKSk7XG5cbiAgICAgICAgLy8gQWRkIHRvIHRoZSBDREYgYW5zd2VyLlxuICAgICAgICBzY2FsZWRDREYgKz0gc2NhbGVkUERGO1xuICAgICAgfVxuXG4gICAgICBmb3IoOyBzYW1wbGVzRG9uZSA8IG47IHNhbXBsZXNEb25lKyspIHtcbiAgICAgICAgLy8gQXBwbHkgYWxsIHRoZSByZXN0IG9mIHRoZSBub3JtYWxpemF0aW9uXG4gICAgICAgIHNjYWxlZENERiAqPSAxIC0gKG0gLyAoTiAtIHNhbXBsZXNEb25lKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJvdW5kIGFuc3dlciBzYW5lbHkgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHJldHVybiBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBzY2FsZWRDREYpKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8gZXh0ZW5kIHVuaWZvcm0gZnVuY3Rpb24gd2l0aCBzdGF0aWMgbWV0aG9kc1xualN0YXQuZXh0ZW5kKGpTdGF0LnBvaXNzb24sIHtcbiAgcGRmOiBmdW5jdGlvbiBwZGYoaywgbCkge1xuICAgIGlmIChsIDwgMCB8fCAoayAlIDEpICE9PSAwIHx8IGsgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5wb3cobCwgaykgKiBNYXRoLmV4cCgtbCkgLyBqU3RhdC5mYWN0b3JpYWwoayk7XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgbCkge1xuICAgIHZhciBzdW1hcnIgPSBbXSxcbiAgICBrID0gMDtcbiAgICBpZiAoeCA8IDApIHJldHVybiAwO1xuICAgIGZvciAoOyBrIDw9IHg7IGsrKykge1xuICAgICAgc3VtYXJyLnB1c2goalN0YXQucG9pc3Nvbi5wZGYoaywgbCkpO1xuICAgIH1cbiAgICByZXR1cm4galN0YXQuc3VtKHN1bWFycik7XG4gIH0sXG5cbiAgbWVhbiA6IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gbDtcbiAgfSxcblxuICB2YXJpYW5jZSA6IGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gbDtcbiAgfSxcblxuICBzYW1wbGVTbWFsbDogZnVuY3Rpb24gc2FtcGxlU21hbGwobCkge1xuICAgIHZhciBwID0gMSwgayA9IDAsIEwgPSBNYXRoLmV4cCgtbCk7XG4gICAgZG8ge1xuICAgICAgaysrO1xuICAgICAgcCAqPSBqU3RhdC5fcmFuZG9tX2ZuKCk7XG4gICAgfSB3aGlsZSAocCA+IEwpO1xuICAgIHJldHVybiBrIC0gMTtcbiAgfSxcblxuICBzYW1wbGVMYXJnZTogZnVuY3Rpb24gc2FtcGxlTGFyZ2UobCkge1xuICAgIHZhciBsYW0gPSBsO1xuICAgIHZhciBrO1xuICAgIHZhciBVLCBWLCBzbGFtLCBsb2dsYW0sIGEsIGIsIGludmFscGhhLCB2ciwgdXM7XG5cbiAgICBzbGFtID0gTWF0aC5zcXJ0KGxhbSk7XG4gICAgbG9nbGFtID0gTWF0aC5sb2cobGFtKTtcbiAgICBiID0gMC45MzEgKyAyLjUzICogc2xhbTtcbiAgICBhID0gLTAuMDU5ICsgMC4wMjQ4MyAqIGI7XG4gICAgaW52YWxwaGEgPSAxLjEyMzkgKyAxLjEzMjggLyAoYiAtIDMuNCk7XG4gICAgdnIgPSAwLjkyNzcgLSAzLjYyMjQgLyAoYiAtIDIpO1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIFUgPSBNYXRoLnJhbmRvbSgpIC0gMC41O1xuICAgICAgViA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB1cyA9IDAuNSAtIE1hdGguYWJzKFUpO1xuICAgICAgayA9IE1hdGguZmxvb3IoKDIgKiBhIC8gdXMgKyBiKSAqIFUgKyBsYW0gKyAwLjQzKTtcbiAgICAgIGlmICgodXMgPj0gMC4wNykgJiYgKFYgPD0gdnIpKSB7XG4gICAgICAgICAgcmV0dXJuIGs7XG4gICAgICB9XG4gICAgICBpZiAoKGsgPCAwKSB8fCAoKHVzIDwgMC4wMTMpICYmIChWID4gdXMpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogbG9nKFYpID09IGxvZygwLjApIG9rIGhlcmUgKi9cbiAgICAgIC8qIGlmIFU9PTAuMCBzbyB0aGF0IHVzPT0wLjAsIGxvZyBpcyBvayBzaW5jZSBhbHdheXMgcmV0dXJucyAqL1xuICAgICAgaWYgKChNYXRoLmxvZyhWKSArIE1hdGgubG9nKGludmFscGhhKSAtIE1hdGgubG9nKGEgLyAodXMgKiB1cykgKyBiKSkgPD0gKC1sYW0gKyBrICogbG9nbGFtIC0galN0YXQubG9nZ2FtKGsgKyAxKSkpIHtcbiAgICAgICAgICByZXR1cm4gaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUobCkge1xuICAgIGlmIChsIDwgMTApXG4gICAgICByZXR1cm4gdGhpcy5zYW1wbGVTbWFsbChsKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5zYW1wbGVMYXJnZShsKTtcbiAgfVxufSk7XG5cbi8vIGV4dGVuZCB0cmlhbmd1bGFyIGZ1bmN0aW9uIHdpdGggc3RhdGljIG1ldGhvZHNcbmpTdGF0LmV4dGVuZChqU3RhdC50cmlhbmd1bGFyLCB7XG4gIHBkZjogZnVuY3Rpb24gcGRmKHgsIGEsIGIsIGMpIHtcbiAgICBpZiAoYiA8PSBhIHx8IGMgPCBhIHx8IGMgPiBiKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeCA8IGEgfHwgeCA+IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHggPCBjKSB7XG4gICAgICAgICAgcmV0dXJuICgyICogKHggLSBhKSkgLyAoKGIgLSBhKSAqIChjIC0gYSkpO1xuICAgICAgfSBlbHNlIGlmICh4ID09PSBjKSB7XG4gICAgICAgICAgcmV0dXJuICgyIC8gKGIgLSBhKSk7XG4gICAgICB9IGVsc2UgeyAvLyB4ID4gY1xuICAgICAgICAgIHJldHVybiAoMiAqIChiIC0geCkpIC8gKChiIC0gYSkgKiAoYiAtIGMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY2RmOiBmdW5jdGlvbiBjZGYoeCwgYSwgYiwgYykge1xuICAgIGlmIChiIDw9IGEgfHwgYyA8IGEgfHwgYyA+IGIpXG4gICAgICByZXR1cm4gTmFOO1xuICAgIGlmICh4IDw9IGEpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmICh4ID49IGIpXG4gICAgICByZXR1cm4gMTtcbiAgICBpZiAoeCA8PSBjKVxuICAgICAgcmV0dXJuIE1hdGgucG93KHggLSBhLCAyKSAvICgoYiAtIGEpICogKGMgLSBhKSk7XG4gICAgZWxzZSAvLyB4ID4gY1xuICAgICAgcmV0dXJuIDEgLSBNYXRoLnBvdyhiIC0geCwgMikgLyAoKGIgLSBhKSAqIChiIC0gYykpO1xuICB9LFxuXG4gIGludjogZnVuY3Rpb24gaW52KHAsIGEsIGIsIGMpIHtcbiAgICBpZiAoYiA8PSBhIHx8IGMgPCBhIHx8IGMgPiBiKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocCA8PSAoKGMgLSBhKSAvIChiIC0gYSkpKSB7XG4gICAgICAgIHJldHVybiBhICsgKGIgLSBhKSAqIE1hdGguc3FydChwICogKChjIC0gYSkgLyAoYiAtIGEpKSk7XG4gICAgICB9IGVsc2UgeyAvLyBwID4gKChjIC0gYSkgLyAoYiAtIGEpKVxuICAgICAgICByZXR1cm4gYSArIChiIC0gYSkgKiAoMSAtIE1hdGguc3FydCgoMSAtIHApICogKDEgLSAoKGMgLSBhKSAvIChiIC0gYSkpKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgKyBiICsgYykgLyAzO1xuICB9LFxuXG4gIG1lZGlhbjogZnVuY3Rpb24gbWVkaWFuKGEsIGIsIGMpIHtcbiAgICBpZiAoYyA8PSAoYSArIGIpIC8gMikge1xuICAgICAgcmV0dXJuIGIgLSBNYXRoLnNxcnQoKGIgLSBhKSAqIChiIC0gYykpIC8gTWF0aC5zcXJ0KDIpO1xuICAgIH0gZWxzZSBpZiAoYyA+IChhICsgYikgLyAyKSB7XG4gICAgICByZXR1cm4gYSArIE1hdGguc3FydCgoYiAtIGEpICogKGMgLSBhKSkgLyBNYXRoLnNxcnQoMik7XG4gICAgfVxuICB9LFxuXG4gIG1vZGU6IGZ1bmN0aW9uIG1vZGUoYSwgYiwgYykge1xuICAgIHJldHVybiBjO1xuICB9LFxuXG4gIHNhbXBsZTogZnVuY3Rpb24gc2FtcGxlKGEsIGIsIGMpIHtcbiAgICB2YXIgdSA9IGpTdGF0Ll9yYW5kb21fZm4oKTtcbiAgICBpZiAodSA8ICgoYyAtIGEpIC8gKGIgLSBhKSkpXG4gICAgICByZXR1cm4gYSArIE1hdGguc3FydCh1ICogKGIgLSBhKSAqIChjIC0gYSkpXG4gICAgcmV0dXJuIGIgLSBNYXRoLnNxcnQoKDEgLSB1KSAqIChiIC0gYSkgKiAoYiAtIGMpKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAqIGEgKyBiICogYiArIGMgKiBjIC0gYSAqIGIgLSBhICogYyAtIGIgKiBjKSAvIDE4O1xuICB9XG59KTtcblxuXG4vLyBleHRlbmQgYXJjc2luZSBmdW5jdGlvbiB3aXRoIHN0YXRpYyBtZXRob2RzXG5qU3RhdC5leHRlbmQoalN0YXQuYXJjc2luZSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBhLCBiKSB7XG4gICAgaWYgKGIgPD0gYSkgcmV0dXJuIE5hTjtcblxuICAgIHJldHVybiAoeCA8PSBhIHx8IHggPj0gYikgPyAwIDpcbiAgICAgICgyIC8gTWF0aC5QSSkgKlxuICAgICAgICBNYXRoLnBvdyhNYXRoLnBvdyhiIC0gYSwgMikgLVxuICAgICAgICAgICAgICAgICAgTWF0aC5wb3coMiAqIHggLSBhIC0gYiwgMiksIC0wLjUpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIGEsIGIpIHtcbiAgICBpZiAoeCA8IGEpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmICh4IDwgYilcbiAgICAgIHJldHVybiAoMiAvIE1hdGguUEkpICogTWF0aC5hc2luKE1hdGguc3FydCgoeCAtIGEpLyhiIC0gYSkpKTtcbiAgICByZXR1cm4gMTtcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIGEsIGIpIHtcbiAgICByZXR1cm4gYSArICgwLjUgLSAwLjUgKiBNYXRoLmNvcyhNYXRoLlBJICogcCkpICogKGIgLSBhKTtcbiAgfSxcblxuICBtZWFuOiBmdW5jdGlvbiBtZWFuKGEsIGIpIHtcbiAgICBpZiAoYiA8PSBhKSByZXR1cm4gTmFOO1xuICAgIHJldHVybiAoYSArIGIpIC8gMjtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uIG1lZGlhbihhLCBiKSB7XG4gICAgaWYgKGIgPD0gYSkgcmV0dXJuIE5hTjtcbiAgICByZXR1cm4gKGEgKyBiKSAvIDI7XG4gIH0sXG5cbiAgbW9kZTogZnVuY3Rpb24gbW9kZSgvKmEsIGIqLykge1xuICAgIHRocm93IG5ldyBFcnJvcignbW9kZSBpcyBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH0sXG5cbiAgc2FtcGxlOiBmdW5jdGlvbiBzYW1wbGUoYSwgYikge1xuICAgIHJldHVybiAoKGEgKyBiKSAvIDIpICsgKChiIC0gYSkgLyAyKSAqXG4gICAgICBNYXRoLnNpbigyICogTWF0aC5QSSAqIGpTdGF0LnVuaWZvcm0uc2FtcGxlKDAsIDEpKTtcbiAgfSxcblxuICB2YXJpYW5jZTogZnVuY3Rpb24gdmFyaWFuY2UoYSwgYikge1xuICAgIGlmIChiIDw9IGEpIHJldHVybiBOYU47XG4gICAgcmV0dXJuIE1hdGgucG93KGIgLSBhLCAyKSAvIDg7XG4gIH1cbn0pO1xuXG5cbmZ1bmN0aW9uIGxhcGxhY2VTaWduKHgpIHsgcmV0dXJuIHggLyBNYXRoLmFicyh4KTsgfVxuXG5qU3RhdC5leHRlbmQoalN0YXQubGFwbGFjZSwge1xuICBwZGY6IGZ1bmN0aW9uIHBkZih4LCBtdSwgYikge1xuICAgIHJldHVybiAoYiA8PSAwKSA/IDAgOiAoTWF0aC5leHAoLU1hdGguYWJzKHggLSBtdSkgLyBiKSkgLyAoMiAqIGIpO1xuICB9LFxuXG4gIGNkZjogZnVuY3Rpb24gY2RmKHgsIG11LCBiKSB7XG4gICAgaWYgKGIgPD0gMCkgeyByZXR1cm4gMDsgfVxuXG4gICAgaWYoeCA8IG11KSB7XG4gICAgICByZXR1cm4gMC41ICogTWF0aC5leHAoKHggLSBtdSkgLyBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDEgLSAwLjUgKiBNYXRoLmV4cCgtICh4IC0gbXUpIC8gYik7XG4gICAgfVxuICB9LFxuXG4gIG1lYW46IGZ1bmN0aW9uKG11LyosIGIqLykge1xuICAgIHJldHVybiBtdTtcbiAgfSxcblxuICBtZWRpYW46IGZ1bmN0aW9uKG11LyosIGIqLykge1xuICAgIHJldHVybiBtdTtcbiAgfSxcblxuICBtb2RlOiBmdW5jdGlvbihtdS8qLCBiKi8pIHtcbiAgICByZXR1cm4gbXU7XG4gIH0sXG5cbiAgdmFyaWFuY2U6IGZ1bmN0aW9uKG11LCBiKSB7XG4gICAgcmV0dXJuIDIgKiBiICogYjtcbiAgfSxcblxuICBzYW1wbGU6IGZ1bmN0aW9uIHNhbXBsZShtdSwgYikge1xuICAgIHZhciB1ID0galN0YXQuX3JhbmRvbV9mbigpIC0gMC41O1xuXG4gICAgcmV0dXJuIG11IC0gKGIgKiBsYXBsYWNlU2lnbih1KSAqIE1hdGgubG9nKDEgLSAoMiAqIE1hdGguYWJzKHUpKSkpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gdHVrZXlXcHJvYih3LCByciwgY2MpIHtcbiAgdmFyIG5sZWcgPSAxMjtcbiAgdmFyIGloYWxmID0gNjtcblxuICB2YXIgQzEgPSAtMzA7XG4gIHZhciBDMiA9IC01MDtcbiAgdmFyIEMzID0gNjA7XG4gIHZhciBiYiAgID0gODtcbiAgdmFyIHdsYXIgPSAzO1xuICB2YXIgd2luY3IxID0gMjtcbiAgdmFyIHdpbmNyMiA9IDM7XG4gIHZhciB4bGVnID0gW1xuICAgIDAuOTgxNTYwNjM0MjQ2NzE5MjUwNjkwNTQ5MDkwMTQ5LFxuICAgIDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1ODY2MTE5LFxuICAgIDAuNzY5OTAyNjc0MTk0MzA0Njg3MDM2ODkzODMzMjEzLFxuICAgIDAuNTg3MzE3OTU0Mjg2NjE3NDQ3Mjk2NzAyNDE4OTQxLFxuICAgIDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNTM2NjQ0LFxuICAgIDAuMTI1MjMzNDA4NTExNDY4OTE1NDcyNDQxMzY5NDY0XG4gIF07XG4gIHZhciBhbGVnID0gW1xuICAgIDAuMDQ3MTc1MzM2Mzg2NTExODI3MTk0NjE1OTYxNDg1LFxuICAgIDAuMTA2OTM5MzI1OTk1MzE4NDMwOTYwMjU0NzE4MTk0LFxuICAgIDAuMTYwMDc4MzI4NTQzMzQ2MjI2MzM0NjUyNTI5NTQzLFxuICAgIDAuMjAzMTY3NDI2NzIzMDY1OTIxNzQ5MDY0NDU1ODEwLFxuICAgIDAuMjMzNDkyNTM2NTM4MzU0ODA4NzYwODQ5ODk4OTI1LFxuICAgIDAuMjQ5MTQ3MDQ1ODEzNDAyNzg1MDAwNTYyNDM2MDQzXG4gIF07XG5cbiAgdmFyIHFzcXogPSB3ICogMC41O1xuXG4gIC8vIGlmIHcgPj0gMTYgdGhlbiB0aGUgaW50ZWdyYWwgbG93ZXIgYm91bmQgKG9jY3VycyBmb3IgYz0yMClcbiAgLy8gaXMgMC45OTk5OTk5OTk5OTk5NSBzbyByZXR1cm4gYSB2YWx1ZSBvZiAxLlxuXG4gIGlmIChxc3F6ID49IGJiKVxuICAgIHJldHVybiAxLjA7XG5cbiAgLy8gZmluZCAoZih3LzIpIC0gMSkgXiBjY1xuICAvLyAoZmlyc3QgdGVybSBpbiBpbnRlZ3JhbCBvZiBoYXJ0bGV5J3MgZm9ybSkuXG5cbiAgdmFyIHByX3cgPSAyICogalN0YXQubm9ybWFsLmNkZihxc3F6LCAwLCAxLCAxLCAwKSAtIDE7IC8vIGVyZihxc3F6IC8gTV9TUVJUMilcbiAgLy8gaWYgcHJfdyBeIGNjIDwgMmUtMjIgdGhlbiBzZXQgcHJfdyA9IDBcbiAgaWYgKHByX3cgPj0gTWF0aC5leHAoQzIgLyBjYykpXG4gICAgcHJfdyA9IE1hdGgucG93KHByX3csIGNjKTtcbiAgZWxzZVxuICAgIHByX3cgPSAwLjA7XG5cbiAgLy8gaWYgdyBpcyBsYXJnZSB0aGVuIHRoZSBzZWNvbmQgY29tcG9uZW50IG9mIHRoZVxuICAvLyBpbnRlZ3JhbCBpcyBzbWFsbCwgc28gZmV3ZXIgaW50ZXJ2YWxzIGFyZSBuZWVkZWQuXG5cbiAgdmFyIHdpbmNyO1xuICBpZiAodyA+IHdsYXIpXG4gICAgd2luY3IgPSB3aW5jcjE7XG4gIGVsc2VcbiAgICB3aW5jciA9IHdpbmNyMjtcblxuICAvLyBmaW5kIHRoZSBpbnRlZ3JhbCBvZiBzZWNvbmQgdGVybSBvZiBoYXJ0bGV5J3MgZm9ybVxuICAvLyBmb3IgdGhlIGludGVncmFsIG9mIHRoZSByYW5nZSBmb3IgZXF1YWwtbGVuZ3RoXG4gIC8vIGludGVydmFscyB1c2luZyBsZWdlbmRyZSBxdWFkcmF0dXJlLiAgbGltaXRzIG9mXG4gIC8vIGludGVncmF0aW9uIGFyZSBmcm9tICh3LzIsIDgpLiAgdHdvIG9yIHRocmVlXG4gIC8vIGVxdWFsLWxlbmd0aCBpbnRlcnZhbHMgYXJlIHVzZWQuXG5cbiAgLy8gYmxiIGFuZCBidWIgYXJlIGxvd2VyIGFuZCB1cHBlciBsaW1pdHMgb2YgaW50ZWdyYXRpb24uXG5cbiAgdmFyIGJsYiA9IHFzcXo7XG4gIHZhciBiaW5jID0gKGJiIC0gcXNxeikgLyB3aW5jcjtcbiAgdmFyIGJ1YiA9IGJsYiArIGJpbmM7XG4gIHZhciBlaW5zdW0gPSAwLjA7XG5cbiAgLy8gaW50ZWdyYXRlIG92ZXIgZWFjaCBpbnRlcnZhbFxuXG4gIHZhciBjYzEgPSBjYyAtIDEuMDtcbiAgZm9yICh2YXIgd2kgPSAxOyB3aSA8PSB3aW5jcjsgd2krKykge1xuICAgIHZhciBlbHN1bSA9IDAuMDtcbiAgICB2YXIgYSA9IDAuNSAqIChidWIgKyBibGIpO1xuXG4gICAgLy8gbGVnZW5kcmUgcXVhZHJhdHVyZSB3aXRoIG9yZGVyID0gbmxlZ1xuXG4gICAgdmFyIGIgPSAwLjUgKiAoYnViIC0gYmxiKTtcblxuICAgIGZvciAodmFyIGpqID0gMTsgamogPD0gbmxlZzsgamorKykge1xuICAgICAgdmFyIGosIHh4O1xuICAgICAgaWYgKGloYWxmIDwgamopIHtcbiAgICAgICAgaiA9IChubGVnIC0gamopICsgMTtcbiAgICAgICAgeHggPSB4bGVnW2otMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqID0gamo7XG4gICAgICAgIHh4ID0gLXhsZWdbai0xXTtcbiAgICAgIH1cbiAgICAgIHZhciBjID0gYiAqIHh4O1xuICAgICAgdmFyIGFjID0gYSArIGM7XG5cbiAgICAgIC8vIGlmIGV4cCgtcWV4cG8vMikgPCA5ZS0xNCxcbiAgICAgIC8vIHRoZW4gZG9lc24ndCBjb250cmlidXRlIHRvIGludGVncmFsXG5cbiAgICAgIHZhciBxZXhwbyA9IGFjICogYWM7XG4gICAgICBpZiAocWV4cG8gPiBDMylcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIHZhciBwcGx1cyA9IDIgKiBqU3RhdC5ub3JtYWwuY2RmKGFjLCAwLCAxLCAxLCAwKTtcbiAgICAgIHZhciBwbWludXM9IDIgKiBqU3RhdC5ub3JtYWwuY2RmKGFjLCB3LCAxLCAxLCAwKTtcblxuICAgICAgLy8gaWYgcmluc3VtIF4gKGNjLTEpIDwgOWUtMTQsXG4gICAgICAvLyB0aGVuIGRvZXNuJ3QgY29udHJpYnV0ZSB0byBpbnRlZ3JhbFxuXG4gICAgICB2YXIgcmluc3VtID0gKHBwbHVzICogMC41KSAtIChwbWludXMgKiAwLjUpO1xuICAgICAgaWYgKHJpbnN1bSA+PSBNYXRoLmV4cChDMSAvIGNjMSkpIHtcbiAgICAgICAgcmluc3VtID0gKGFsZWdbai0xXSAqIE1hdGguZXhwKC0oMC41ICogcWV4cG8pKSkgKiBNYXRoLnBvdyhyaW5zdW0sIGNjMSk7XG4gICAgICAgIGVsc3VtICs9IHJpbnN1bTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzdW0gKj0gKCgoMi4wICogYikgKiBjYykgLyBNYXRoLnNxcnQoMiAqIE1hdGguUEkpKTtcbiAgICBlaW5zdW0gKz0gZWxzdW07XG4gICAgYmxiID0gYnViO1xuICAgIGJ1YiArPSBiaW5jO1xuICB9XG5cbiAgLy8gaWYgcHJfdyBeIHJyIDwgOWUtMTQsIHRoZW4gcmV0dXJuIDBcbiAgcHJfdyArPSBlaW5zdW07XG4gIGlmIChwcl93IDw9IE1hdGguZXhwKEMxIC8gcnIpKVxuICAgIHJldHVybiAwO1xuXG4gIHByX3cgPSBNYXRoLnBvdyhwcl93LCBycik7XG4gIGlmIChwcl93ID49IDEpIC8vIDEgd2FzIGlNYXggd2FzIGVwc1xuICAgIHJldHVybiAxO1xuICByZXR1cm4gcHJfdztcbn1cblxuZnVuY3Rpb24gdHVrZXlRaW52KHAsIGMsIHYpIHtcbiAgdmFyIHAwID0gMC4zMjIyMzI0MjEwODg7XG4gIHZhciBxMCA9IDAuOTkzNDg0NjI2MDYwZS0wMTtcbiAgdmFyIHAxID0gLTEuMDtcbiAgdmFyIHExID0gMC41ODg1ODE1NzA0OTU7XG4gIHZhciBwMiA9IC0wLjM0MjI0MjA4ODU0NztcbiAgdmFyIHEyID0gMC41MzExMDM0NjIzNjY7XG4gIHZhciBwMyA9IC0wLjIwNDIzMTIxMDEyNTtcbiAgdmFyIHEzID0gMC4xMDM1Mzc3NTI4NTA7XG4gIHZhciBwNCA9IC0wLjQ1MzY0MjIxMDE0OGUtMDQ7XG4gIHZhciBxNCA9IDAuMzg1NjA3MDA2MzRlLTAyO1xuICB2YXIgYzEgPSAwLjg4MzI7XG4gIHZhciBjMiA9IDAuMjM2ODtcbiAgdmFyIGMzID0gMS4yMTQ7XG4gIHZhciBjNCA9IDEuMjA4O1xuICB2YXIgYzUgPSAxLjQxNDI7XG4gIHZhciB2bWF4ID0gMTIwLjA7XG5cbiAgdmFyIHBzID0gMC41IC0gMC41ICogcDtcbiAgdmFyIHlpID0gTWF0aC5zcXJ0KE1hdGgubG9nKDEuMCAvIChwcyAqIHBzKSkpO1xuICB2YXIgdCA9IHlpICsgKCgoKCB5aSAqIHA0ICsgcDMpICogeWkgKyBwMikgKiB5aSArIHAxKSAqIHlpICsgcDApXG4gICAgIC8gKCgoKCB5aSAqIHE0ICsgcTMpICogeWkgKyBxMikgKiB5aSArIHExKSAqIHlpICsgcTApO1xuICBpZiAodiA8IHZtYXgpIHQgKz0gKHQgKiB0ICogdCArIHQpIC8gdiAvIDQuMDtcbiAgdmFyIHEgPSBjMSAtIGMyICogdDtcbiAgaWYgKHYgPCB2bWF4KSBxICs9IC1jMyAvIHYgKyBjNCAqIHQgLyB2O1xuICByZXR1cm4gdCAqIChxICogTWF0aC5sb2coYyAtIDEuMCkgKyBjNSk7XG59XG5cbmpTdGF0LmV4dGVuZChqU3RhdC50dWtleSwge1xuICBjZGY6IGZ1bmN0aW9uIGNkZihxLCBubWVhbnMsIGRmKSB7XG4gICAgLy8gSWRlbnRpY2FsIGltcGxlbWVudGF0aW9uIGFzIHRoZSBSIHB0dWtleSgpIGZ1bmN0aW9uIGFzIG9mIGNvbW1pdCA2ODk0N1xuICAgIHZhciByciA9IDE7XG4gICAgdmFyIGNjID0gbm1lYW5zO1xuXG4gICAgdmFyIG5sZWdxID0gMTY7XG4gICAgdmFyIGloYWxmcSA9IDg7XG5cbiAgICB2YXIgZXBzMSA9IC0zMC4wO1xuICAgIHZhciBlcHMyID0gMS4wZS0xNDtcbiAgICB2YXIgZGhhZiAgPSAxMDAuMDtcbiAgICB2YXIgZHF1YXIgPSA4MDAuMDtcbiAgICB2YXIgZGVpZ2ggPSA1MDAwLjA7XG4gICAgdmFyIGRsYXJnID0gMjUwMDAuMDtcbiAgICB2YXIgdWxlbjEgPSAxLjA7XG4gICAgdmFyIHVsZW4yID0gMC41O1xuICAgIHZhciB1bGVuMyA9IDAuMjU7XG4gICAgdmFyIHVsZW40ID0gMC4xMjU7XG4gICAgdmFyIHhsZWdxID0gW1xuICAgICAgMC45ODk0MDA5MzQ5OTE2NDk5MzI1OTYxNTQxNzM0NTAsXG4gICAgICAwLjk0NDU3NTAyMzA3MzIzMjU3NjA3Nzk4ODQxNTUzNSxcbiAgICAgIDAuODY1NjMxMjAyMzg3ODMxNzQzODgwNDY3ODk3NzEyLFxuICAgICAgMC43NTU0MDQ0MDgzNTUwMDMwMzM4OTUxMDExOTQ4NDcsXG4gICAgICAwLjYxNzg3NjI0NDQwMjY0Mzc0ODQ0NjY3MTc2NDA0OSxcbiAgICAgIDAuNDU4MDE2Nzc3NjU3MjI3Mzg2MzQyNDE5NDQyOTg0LFxuICAgICAgMC4yODE2MDM1NTA3NzkyNTg5MTMyMzA0NjA1MDE0NjAsXG4gICAgICAwLjk1MDEyNTA5ODM3NjM3NDQwMTg1MzE5MzM1NDI1MGUtMVxuICAgIF07XG4gICAgdmFyIGFsZWdxID0gW1xuICAgICAgMC4yNzE1MjQ1OTQxMTc1NDA5NDg1MTc4MDU3MjQ1NjBlLTEsXG4gICAgICAwLjYyMjUzNTIzOTM4NjQ3ODkyODYyODQzODM2OTk0NGUtMSxcbiAgICAgIDAuOTUxNTg1MTE2ODI0OTI3ODQ4MDk5MjUxMDc2MDIyZS0xLFxuICAgICAgMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYyODIxOTIsXG4gICAgICAwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTczMDU0NyxcbiAgICAgIDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMDc5MDMwLFxuICAgICAgMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM2Njc5NjksXG4gICAgICAwLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcyMzIwOFxuICAgIF07XG5cbiAgICBpZiAocSA8PSAwKVxuICAgICAgcmV0dXJuIDA7XG5cbiAgICAvLyBkZiBtdXN0IGJlID4gMVxuICAgIC8vIHRoZXJlIG11c3QgYmUgYXQgbGVhc3QgdHdvIHZhbHVlc1xuXG4gICAgaWYgKGRmIDwgMiB8fCByciA8IDEgfHwgY2MgPCAyKSByZXR1cm4gTmFOO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocSkpXG4gICAgICByZXR1cm4gMTtcblxuICAgIGlmIChkZiA+IGRsYXJnKVxuICAgICAgcmV0dXJuIHR1a2V5V3Byb2IocSwgcnIsIGNjKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBsZWFkaW5nIGNvbnN0YW50XG5cbiAgICB2YXIgZjIgPSBkZiAqIDAuNTtcbiAgICB2YXIgZjJsZiA9ICgoZjIgKiBNYXRoLmxvZyhkZikpIC0gKGRmICogTWF0aC5sb2coMikpKSAtIGpTdGF0LmdhbW1hbG4oZjIpO1xuICAgIHZhciBmMjEgPSBmMiAtIDEuMDtcblxuICAgIC8vIGludGVncmFsIGlzIGRpdmlkZWQgaW50byB1bml0LCBoYWxmLXVuaXQsIHF1YXJ0ZXItdW5pdCwgb3JcbiAgICAvLyBlaWdodGgtdW5pdCBsZW5ndGggaW50ZXJ2YWxzIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgdGhlXG4gICAgLy8gZGVncmVlcyBvZiBmcmVlZG9tLlxuXG4gICAgdmFyIGZmNCA9IGRmICogMC4yNTtcbiAgICB2YXIgdWxlbjtcbiAgICBpZiAgICAgIChkZiA8PSBkaGFmKSAgdWxlbiA9IHVsZW4xO1xuICAgIGVsc2UgaWYgKGRmIDw9IGRxdWFyKSB1bGVuID0gdWxlbjI7XG4gICAgZWxzZSBpZiAoZGYgPD0gZGVpZ2gpIHVsZW4gPSB1bGVuMztcbiAgICBlbHNlICAgICAgICAgICAgICAgICAgdWxlbiA9IHVsZW40O1xuXG4gICAgZjJsZiArPSBNYXRoLmxvZyh1bGVuKTtcblxuICAgIC8vIGludGVncmF0ZSBvdmVyIGVhY2ggc3ViaW50ZXJ2YWxcblxuICAgIHZhciBhbnMgPSAwLjA7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSA1MDsgaSsrKSB7XG4gICAgICB2YXIgb3RzdW0gPSAwLjA7XG5cbiAgICAgIC8vIGxlZ2VuZHJlIHF1YWRyYXR1cmUgd2l0aCBvcmRlciA9IG5sZWdxXG4gICAgICAvLyBub2RlcyAoc3RvcmVkIGluIHhsZWdxKSBhcmUgc3ltbWV0cmljIGFyb3VuZCB6ZXJvLlxuXG4gICAgICB2YXIgdHdhMSA9ICgyICogaSAtIDEpICogdWxlbjtcblxuICAgICAgZm9yICh2YXIgamogPSAxOyBqaiA8PSBubGVncTsgamorKykge1xuICAgICAgICB2YXIgaiwgdDE7XG4gICAgICAgIGlmIChpaGFsZnEgPCBqaikge1xuICAgICAgICAgIGogPSBqaiAtIGloYWxmcSAtIDE7XG4gICAgICAgICAgdDEgPSAoZjJsZiArIChmMjEgKiBNYXRoLmxvZyh0d2ExICsgKHhsZWdxW2pdICogdWxlbikpKSlcbiAgICAgICAgICAgICAgLSAoKCh4bGVncVtqXSAqIHVsZW4pICsgdHdhMSkgKiBmZjQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGogPSBqaiAtIDE7XG4gICAgICAgICAgdDEgPSAoZjJsZiArIChmMjEgKiBNYXRoLmxvZyh0d2ExIC0gKHhsZWdxW2pdICogdWxlbikpKSlcbiAgICAgICAgICAgICAgKyAoKCh4bGVncVtqXSAqIHVsZW4pIC0gdHdhMSkgKiBmZjQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgZXhwKHQxKSA8IDllLTE0LCB0aGVuIGRvZXNuJ3QgY29udHJpYnV0ZSB0byBpbnRlZ3JhbFxuICAgICAgICB2YXIgcXNxejtcbiAgICAgICAgaWYgKHQxID49IGVwczEpIHtcbiAgICAgICAgICBpZiAoaWhhbGZxIDwgamopIHtcbiAgICAgICAgICAgIHFzcXogPSBxICogTWF0aC5zcXJ0KCgoeGxlZ3Fbal0gKiB1bGVuKSArIHR3YTEpICogMC41KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXNxeiA9IHEgKiBNYXRoLnNxcnQoKCgtKHhsZWdxW2pdICogdWxlbikpICsgdHdhMSkgKiAwLjUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNhbGwgd3Byb2IgdG8gZmluZCBpbnRlZ3JhbCBvZiByYW5nZSBwb3J0aW9uXG5cbiAgICAgICAgICB2YXIgd3ByYiA9IHR1a2V5V3Byb2IocXNxeiwgcnIsIGNjKTtcbiAgICAgICAgICB2YXIgcm90c3VtID0gKHdwcmIgKiBhbGVncVtqXSkgKiBNYXRoLmV4cCh0MSk7XG4gICAgICAgICAgb3RzdW0gKz0gcm90c3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZCBsZWdlbmRyZSBpbnRlZ3JhbCBmb3IgaW50ZXJ2YWwgaVxuICAgICAgICAvLyBMMjAwOlxuICAgICAgfVxuXG4gICAgICAvLyBpZiBpbnRlZ3JhbCBmb3IgaW50ZXJ2YWwgaSA8IDFlLTE0LCB0aGVuIHN0b3AuXG4gICAgICAvLyBIb3dldmVyLCBpbiBvcmRlciB0byBhdm9pZCBzbWFsbCBhcmVhIHVuZGVyIGxlZnQgdGFpbCxcbiAgICAgIC8vIGF0IGxlYXN0ICAxIC8gdWxlbiAgaW50ZXJ2YWxzIGFyZSBjYWxjdWxhdGVkLlxuICAgICAgaWYgKGkgKiB1bGVuID49IDEuMCAmJiBvdHN1bSA8PSBlcHMyKVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gZW5kIG9mIGludGVydmFsIGlcbiAgICAgIC8vIEwzMzA6XG5cbiAgICAgIGFucyArPSBvdHN1bTtcbiAgICB9XG5cbiAgICBpZiAob3RzdW0gPiBlcHMyKSB7IC8vIG5vdCBjb252ZXJnZWRcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHVrZXkuY2RmIGZhaWxlZCB0byBjb252ZXJnZScpO1xuICAgIH1cbiAgICBpZiAoYW5zID4gMSlcbiAgICAgIGFucyA9IDE7XG4gICAgcmV0dXJuIGFucztcbiAgfSxcblxuICBpbnY6IGZ1bmN0aW9uKHAsIG5tZWFucywgZGYpIHtcbiAgICAvLyBJZGVudGljYWwgaW1wbGVtZW50YXRpb24gYXMgdGhlIFIgcXR1a2V5KCkgZnVuY3Rpb24gYXMgb2YgY29tbWl0IDY4OTQ3XG4gICAgdmFyIHJyID0gMTtcbiAgICB2YXIgY2MgPSBubWVhbnM7XG5cbiAgICB2YXIgZXBzID0gMC4wMDAxO1xuICAgIHZhciBtYXhpdGVyID0gNTA7XG5cbiAgICAvLyBkZiBtdXN0IGJlID4gMSA7IHRoZXJlIG11c3QgYmUgYXQgbGVhc3QgdHdvIHZhbHVlc1xuICAgIGlmIChkZiA8IDIgfHwgcnIgPCAxIHx8IGNjIDwgMikgcmV0dXJuIE5hTjtcblxuICAgIGlmIChwIDwgMCB8fCBwID4gMSkgcmV0dXJuIE5hTjtcbiAgICBpZiAocCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgaWYgKHAgPT09IDEpIHJldHVybiBJbmZpbml0eTtcblxuICAgIC8vIEluaXRpYWwgdmFsdWVcblxuICAgIHZhciB4MCA9IHR1a2V5UWludihwLCBjYywgZGYpO1xuXG4gICAgLy8gRmluZCBwcm9iKHZhbHVlIDwgeDApXG5cbiAgICB2YXIgdmFseDAgPSBqU3RhdC50dWtleS5jZGYoeDAsIG5tZWFucywgZGYpIC0gcDtcblxuICAgIC8vIEZpbmQgdGhlIHNlY29uZCBpdGVyYXRlIGFuZCBwcm9iKHZhbHVlIDwgeDEpLlxuICAgIC8vIElmIHRoZSBmaXJzdCBpdGVyYXRlIGhhcyBwcm9iYWJpbGl0eSB2YWx1ZVxuICAgIC8vIGV4Y2VlZGluZyBwIHRoZW4gc2Vjb25kIGl0ZXJhdGUgaXMgMSBsZXNzIHRoYW5cbiAgICAvLyBmaXJzdCBpdGVyYXRlOyBvdGhlcndpc2UgaXQgaXMgMSBncmVhdGVyLlxuXG4gICAgdmFyIHgxO1xuICAgIGlmICh2YWx4MCA+IDAuMClcbiAgICAgIHgxID0gTWF0aC5tYXgoMC4wLCB4MCAtIDEuMCk7XG4gICAgZWxzZVxuICAgICAgeDEgPSB4MCArIDEuMDtcbiAgICB2YXIgdmFseDEgPSBqU3RhdC50dWtleS5jZGYoeDEsIG5tZWFucywgZGYpIC0gcDtcblxuICAgIC8vIEZpbmQgbmV3IGl0ZXJhdGVcblxuICAgIHZhciBhbnM7XG4gICAgZm9yKHZhciBpdGVyID0gMTsgaXRlciA8IG1heGl0ZXI7IGl0ZXIrKykge1xuICAgICAgYW5zID0geDEgLSAoKHZhbHgxICogKHgxIC0geDApKSAvICh2YWx4MSAtIHZhbHgwKSk7XG4gICAgICB2YWx4MCA9IHZhbHgxO1xuXG4gICAgICAvLyBOZXcgaXRlcmF0ZSBtdXN0IGJlID49IDBcblxuICAgICAgeDAgPSB4MTtcbiAgICAgIGlmIChhbnMgPCAwLjApIHtcbiAgICAgICAgYW5zID0gMC4wO1xuICAgICAgICB2YWx4MSA9IC1wO1xuICAgICAgfVxuICAgICAgLy8gRmluZCBwcm9iKHZhbHVlIDwgbmV3IGl0ZXJhdGUpXG5cbiAgICAgIHZhbHgxID0galN0YXQudHVrZXkuY2RmKGFucywgbm1lYW5zLCBkZikgLSBwO1xuICAgICAgeDEgPSBhbnM7XG5cbiAgICAgIC8vIElmIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIHN1Y2Nlc3NpdmVcbiAgICAgIC8vIGl0ZXJhdGVzIGlzIGxlc3MgdGhhbiBlcHMsIHN0b3BcblxuICAgICAgdmFyIHhhYnMgPSBNYXRoLmFicyh4MSAtIHgwKTtcbiAgICAgIGlmICh4YWJzIDwgZXBzKVxuICAgICAgICByZXR1cm4gYW5zO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcigndHVrZXkuaW52IGZhaWxlZCB0byBjb252ZXJnZScpO1xuICB9XG59KTtcblxufShqU3RhdCwgTWF0aCkpO1xuLyogUHJvdmlkZXMgZnVuY3Rpb25zIGZvciB0aGUgc29sdXRpb24gb2YgbGluZWFyIHN5c3RlbSBvZiBlcXVhdGlvbnMsIGludGVncmF0aW9uLCBleHRyYXBvbGF0aW9uLFxuICogaW50ZXJwb2xhdGlvbiwgZWlnZW52YWx1ZSBwcm9ibGVtcywgZGlmZmVyZW50aWFsIGVxdWF0aW9ucyBhbmQgUENBIGFuYWx5c2lzLiAqL1xuXG4oZnVuY3Rpb24oalN0YXQsIE1hdGgpIHtcblxudmFyIHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbnZhciBpc0FycmF5ID0galN0YXQudXRpbHMuaXNBcnJheTtcblxuZnVuY3Rpb24gaXNVc2FibGUoYXJnKSB7XG4gIHJldHVybiBpc0FycmF5KGFyZykgfHwgYXJnIGluc3RhbmNlb2YgalN0YXQ7XG59XG5cbmpTdGF0LmV4dGVuZCh7XG5cbiAgLy8gYWRkIGEgdmVjdG9yL21hdHJpeCB0byBhIHZlY3Rvci9tYXRyaXggb3Igc2NhbGFyXG4gIGFkZDogZnVuY3Rpb24gYWRkKGFyciwgYXJnKSB7XG4gICAgLy8gY2hlY2sgaWYgYXJnIGlzIGEgdmVjdG9yIG9yIHNjYWxhclxuICAgIGlmIChpc1VzYWJsZShhcmcpKSB7XG4gICAgICBpZiAoIWlzVXNhYmxlKGFyZ1swXSkpIGFyZyA9IFsgYXJnIF07XG4gICAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUsIHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArIGFyZ1tyb3ddW2NvbF07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZSArIGFyZzsgfSk7XG4gIH0sXG5cbiAgLy8gc3VidHJhY3QgYSB2ZWN0b3Igb3Igc2NhbGFyIGZyb20gdGhlIHZlY3RvclxuICBzdWJ0cmFjdDogZnVuY3Rpb24gc3VidHJhY3QoYXJyLCBhcmcpIHtcbiAgICAvLyBjaGVjayBpZiBhcmcgaXMgYSB2ZWN0b3Igb3Igc2NhbGFyXG4gICAgaWYgKGlzVXNhYmxlKGFyZykpIHtcbiAgICAgIGlmICghaXNVc2FibGUoYXJnWzBdKSkgYXJnID0gWyBhcmcgXTtcbiAgICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSwgcm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIC0gYXJnW3Jvd11bY29sXSB8fCAwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgLSBhcmc7IH0pO1xuICB9LFxuXG4gIC8vIG1hdHJpeCBkaXZpc2lvblxuICBkaXZpZGU6IGZ1bmN0aW9uIGRpdmlkZShhcnIsIGFyZykge1xuICAgIGlmIChpc1VzYWJsZShhcmcpKSB7XG4gICAgICBpZiAoIWlzVXNhYmxlKGFyZ1swXSkpIGFyZyA9IFsgYXJnIF07XG4gICAgICByZXR1cm4galN0YXQubXVsdGlwbHkoYXJyLCBqU3RhdC5pbnYoYXJnKSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5tYXAoYXJyLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgLyBhcmc7IH0pO1xuICB9LFxuXG4gIC8vIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBtdWx0aXBseTogZnVuY3Rpb24gbXVsdGlwbHkoYXJyLCBhcmcpIHtcbiAgICB2YXIgcm93LCBjb2wsIG5yZXNjb2xzLCBzdW0sIG5yb3csIG5jb2wsIHJlcywgcmVzY29scztcbiAgICAvLyBlZzogYXJyID0gMiBhcmcgPSAzIC0+IDYgZm9yIHJlc1swXVswXSBzdGF0ZW1lbnQgY2xvc3VyZVxuICAgIGlmIChhcnIubGVuZ3RoID09PSB1bmRlZmluZWQgJiYgYXJnLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYXJyICogYXJnO1xuICAgIH1cbiAgICBucm93ID0gYXJyLmxlbmd0aCxcbiAgICBuY29sID0gYXJyWzBdLmxlbmd0aCxcbiAgICByZXMgPSBqU3RhdC56ZXJvcyhucm93LCBucmVzY29scyA9IChpc1VzYWJsZShhcmcpKSA/IGFyZ1swXS5sZW5ndGggOiBuY29sKSxcbiAgICByZXNjb2xzID0gMDtcbiAgICBpZiAoaXNVc2FibGUoYXJnKSkge1xuICAgICAgZm9yICg7IHJlc2NvbHMgPCBucmVzY29sczsgcmVzY29scysrKSB7XG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgbnJvdzsgcm93KyspIHtcbiAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgbmNvbDsgY29sKyspXG4gICAgICAgICAgc3VtICs9IGFycltyb3ddW2NvbF0gKiBhcmdbY29sXVtyZXNjb2xzXTtcbiAgICAgICAgICByZXNbcm93XVtyZXNjb2xzXSA9IHN1bTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIChucm93ID09PSAxICYmIHJlc2NvbHMgPT09IDEpID8gcmVzWzBdWzBdIDogcmVzO1xuICAgIH1cbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlICogYXJnOyB9KTtcbiAgfSxcblxuICAvLyBvdXRlcihbMSwyLDNdLFs0LDUsNl0pXG4gIC8vID09PVxuICAvLyBbWzFdLFsyXSxbM11dIHRpbWVzIFtbNCw1LDZdXVxuICAvLyAtPlxuICAvLyBbWzQsNSw2XSxbOCwxMCwxMl0sWzEyLDE1LDE4XV1cbiAgb3V0ZXI6ZnVuY3Rpb24gb3V0ZXIoQSwgQikge1xuICAgIHJldHVybiBqU3RhdC5tdWx0aXBseShBLm1hcChmdW5jdGlvbih0KXsgcmV0dXJuIFt0XSB9KSwgW0JdKTtcbiAgfSxcblxuXG4gIC8vIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBtYXRyaWNpZXNcbiAgZG90OiBmdW5jdGlvbiBkb3QoYXJyLCBhcmcpIHtcbiAgICBpZiAoIWlzVXNhYmxlKGFyclswXSkpIGFyciA9IFsgYXJyIF07XG4gICAgaWYgKCFpc1VzYWJsZShhcmdbMF0pKSBhcmcgPSBbIGFyZyBdO1xuICAgIC8vIGNvbnZlcnQgY29sdW1uIHRvIHJvdyB2ZWN0b3JcbiAgICB2YXIgbGVmdCA9IChhcnJbMF0ubGVuZ3RoID09PSAxICYmIGFyci5sZW5ndGggIT09IDEpID8galN0YXQudHJhbnNwb3NlKGFycikgOiBhcnIsXG4gICAgcmlnaHQgPSAoYXJnWzBdLmxlbmd0aCA9PT0gMSAmJiBhcmcubGVuZ3RoICE9PSAxKSA/IGpTdGF0LnRyYW5zcG9zZShhcmcpIDogYXJnLFxuICAgIHJlcyA9IFtdLFxuICAgIHJvdyA9IDAsXG4gICAgbnJvdyA9IGxlZnQubGVuZ3RoLFxuICAgIG5jb2wgPSBsZWZ0WzBdLmxlbmd0aCxcbiAgICBzdW0sIGNvbDtcbiAgICBmb3IgKDsgcm93IDwgbnJvdzsgcm93KyspIHtcbiAgICAgIHJlc1tyb3ddID0gW107XG4gICAgICBzdW0gPSAwO1xuICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBuY29sOyBjb2wrKylcbiAgICAgIHN1bSArPSBsZWZ0W3Jvd11bY29sXSAqIHJpZ2h0W3Jvd11bY29sXTtcbiAgICAgIHJlc1tyb3ddID0gc3VtO1xuICAgIH1cbiAgICByZXR1cm4gKHJlcy5sZW5ndGggPT09IDEpID8gcmVzWzBdIDogcmVzO1xuICB9LFxuXG4gIC8vIHJhaXNlIGV2ZXJ5IGVsZW1lbnQgYnkgYSBzY2FsYXJcbiAgcG93OiBmdW5jdGlvbiBwb3coYXJyLCBhcmcpIHtcbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIE1hdGgucG93KHZhbHVlLCBhcmcpOyB9KTtcbiAgfSxcblxuICAvLyBleHBvbmVudGlhdGUgZXZlcnkgZWxlbWVudFxuICBleHA6IGZ1bmN0aW9uIGV4cChhcnIpIHtcbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIE1hdGguZXhwKHZhbHVlKTsgfSk7XG4gIH0sXG5cbiAgLy8gZ2VuZXJhdGUgdGhlIG5hdHVyYWwgbG9nIG9mIGV2ZXJ5IGVsZW1lbnRcbiAgbG9nOiBmdW5jdGlvbiBleHAoYXJyKSB7XG4gICAgcmV0dXJuIGpTdGF0Lm1hcChhcnIsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBNYXRoLmxvZyh2YWx1ZSk7IH0pO1xuICB9LFxuXG4gIC8vIGdlbmVyYXRlIHRoZSBhYnNvbHV0ZSB2YWx1ZXMgb2YgdGhlIHZlY3RvclxuICBhYnM6IGZ1bmN0aW9uIGFicyhhcnIpIHtcbiAgICByZXR1cm4galN0YXQubWFwKGFyciwgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIE1hdGguYWJzKHZhbHVlKTsgfSk7XG4gIH0sXG5cbiAgLy8gY29tcHV0ZXMgdGhlIHAtbm9ybSBvZiB0aGUgdmVjdG9yXG4gIC8vIEluIHRoZSBjYXNlIHRoYXQgYSBtYXRyaXggaXMgcGFzc2VkLCB1c2VzIHRoZSBmaXJzdCByb3cgYXMgdGhlIHZlY3RvclxuICBub3JtOiBmdW5jdGlvbiBub3JtKGFyciwgcCkge1xuICAgIHZhciBubm9ybSA9IDAsXG4gICAgaSA9IDA7XG4gICAgLy8gY2hlY2sgdGhlIHAtdmFsdWUgb2YgdGhlIG5vcm0sIGFuZCBzZXQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgICBpZiAoaXNOYU4ocCkpIHAgPSAyO1xuICAgIC8vIGNoZWNrIGlmIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5LCBhbmQgbWFrZSB2ZWN0b3IgY29ycmVjdGlvblxuICAgIGlmIChpc1VzYWJsZShhcnJbMF0pKSBhcnIgPSBhcnJbMF07XG4gICAgLy8gdmVjdG9yIG5vcm1cbiAgICBmb3IgKDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgbm5vcm0gKz0gTWF0aC5wb3coTWF0aC5hYnMoYXJyW2ldKSwgcCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnBvdyhubm9ybSwgMSAvIHApO1xuICB9LFxuXG4gIC8vIGNvbXB1dGVzIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzIGluIHJhZHNcbiAgLy8gSW4gY2FzZSBhIG1hdHJpeCBpcyBwYXNzZWQsIHRoaXMgdXNlcyB0aGUgZmlyc3Qgcm93IGFzIHRoZSB2ZWN0b3JcbiAgYW5nbGU6IGZ1bmN0aW9uIGFuZ2xlKGFyciwgYXJnKSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhqU3RhdC5kb3QoYXJyLCBhcmcpIC8gKGpTdGF0Lm5vcm0oYXJyKSAqIGpTdGF0Lm5vcm0oYXJnKSkpO1xuICB9LFxuXG4gIC8vIGF1Z21lbnQgb25lIG1hdHJpeCBieSBhbm90aGVyXG4gIC8vIE5vdGU6IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG1hdHJpeCwgbm90IGEgalN0YXQgb2JqZWN0XG4gIGF1ZzogZnVuY3Rpb24gYXVnKGEsIGIpIHtcbiAgICB2YXIgbmV3YXJyID0gW107XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld2Fyci5wdXNoKGFbaV0uc2xpY2UoKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBuZXdhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHB1c2guYXBwbHkobmV3YXJyW2ldLCBiW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld2FycjtcbiAgfSxcblxuICAvLyBUaGUgaW52KCkgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIG1hdHJpeFxuICAvLyBDcmVhdGUgdGhlIGludmVyc2UgYnkgYXVnbWVudGluZyB0aGUgbWF0cml4IGJ5IHRoZSBpZGVudGl0eSBtYXRyaXggb2YgdGhlXG4gIC8vIGFwcHJvcHJpYXRlIHNpemUsIGFuZCB0aGVuIHVzZSBHLUogZWxpbWluYXRpb24gb24gdGhlIGF1Z21lbnRlZCBtYXRyaXguXG4gIGludjogZnVuY3Rpb24gaW52KGEpIHtcbiAgICB2YXIgcm93cyA9IGEubGVuZ3RoO1xuICAgIHZhciBjb2xzID0gYVswXS5sZW5ndGg7XG4gICAgdmFyIGIgPSBqU3RhdC5pZGVudGl0eShyb3dzLCBjb2xzKTtcbiAgICB2YXIgYyA9IGpTdGF0LmdhdXNzX2pvcmRhbihhLCBiKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqO1xuXG4gICAgLy9XZSBuZWVkIHRvIGNvcHkgdGhlIGludmVyc2UgcG9ydGlvbiB0byBhIG5ldyBtYXRyaXggdG8gcmlkIEctSiBhcnRpZmFjdHNcbiAgICBmb3IgKDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gW107XG4gICAgICBmb3IgKGogPSBjb2xzOyBqIDwgY1swXS5sZW5ndGg7IGorKylcbiAgICAgICAgcmVzdWx0W2ldW2ogLSBjb2xzXSA9IGNbaV1bal07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeFxuICBkZXQ6IGZ1bmN0aW9uIGRldChhKSB7XG4gICAgaWYgKGEubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gYVswXVswXSAqIGFbMV1bMV0gLSBhWzBdWzFdICogYVsxXVswXTtcbiAgICB9XG5cbiAgICB2YXIgZGV0ZXJtaW5hbnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gYnVpbGQgYSBzdWIgbWF0cml4IHdpdGhvdXQgY29sdW1uIGBpYFxuICAgICAgdmFyIHN1Ym1hdHJpeCA9IFtdO1xuICAgICAgZm9yICh2YXIgcm93ID0gMTsgcm93IDwgYS5sZW5ndGg7IHJvdysrKSB7XG4gICAgICAgIHN1Ym1hdHJpeFtyb3cgLSAxXSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBhLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICBpZiAoY29sIDwgaSkge1xuICAgICAgICAgICAgc3VibWF0cml4W3JvdyAtIDFdW2NvbF0gPSBhW3Jvd11bY29sXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbCA+IGkpIHtcbiAgICAgICAgICAgIHN1Ym1hdHJpeFtyb3cgLSAxXVtjb2wgLSAxXSA9IGFbcm93XVtjb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhbHRlcm5hdGUgYmV0d2VlbiArIGFuZCAtIGJldHdlZW4gZGV0ZXJtaW5hbnRzXG4gICAgICB2YXIgc2lnbiA9IGkgJSAyID8gLTEgOiAxO1xuICAgICAgZGV0ZXJtaW5hbnQgKz0gZGV0KHN1Ym1hdHJpeCkgKiBhWzBdW2ldICogc2lnbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZGV0ZXJtaW5hbnRcbiAgfSxcblxuICBnYXVzc19lbGltaW5hdGlvbjogZnVuY3Rpb24gZ2F1c3NfZWxpbWluYXRpb24oYSwgYikge1xuICAgIHZhciBpID0gMCxcbiAgICBqID0gMCxcbiAgICBuID0gYS5sZW5ndGgsXG4gICAgbSA9IGFbMF0ubGVuZ3RoLFxuICAgIGZhY3RvciA9IDEsXG4gICAgc3VtID0gMCxcbiAgICB4ID0gW10sXG4gICAgbWF1ZywgcGl2b3QsIHRlbXAsIGs7XG4gICAgYSA9IGpTdGF0LmF1ZyhhLCBiKTtcbiAgICBtYXVnID0gYVswXS5sZW5ndGg7XG4gICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBwaXZvdCA9IGFbaV1baV07XG4gICAgICBqID0gaTtcbiAgICAgIGZvciAoayA9IGkgKyAxOyBrIDwgbTsgaysrKSB7XG4gICAgICAgIGlmIChwaXZvdCA8IE1hdGguYWJzKGFba11baV0pKSB7XG4gICAgICAgICAgcGl2b3QgPSBhW2tdW2ldO1xuICAgICAgICAgIGogPSBrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaiAhPSBpKSB7XG4gICAgICAgIGZvcihrID0gMDsgayA8IG1hdWc7IGsrKykge1xuICAgICAgICAgIHRlbXAgPSBhW2ldW2tdO1xuICAgICAgICAgIGFbaV1ba10gPSBhW2pdW2tdO1xuICAgICAgICAgIGFbal1ba10gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICBmYWN0b3IgPSBhW2pdW2ldIC8gYVtpXVtpXTtcbiAgICAgICAgZm9yKGsgPSBpOyBrIDwgbWF1ZzsgaysrKSB7XG4gICAgICAgICAgYVtqXVtrXSA9IGFbal1ba10gLSBmYWN0b3IgKiBhW2ldW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgc3VtID0gMDtcbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqPD0gbiAtIDE7IGorKykge1xuICAgICAgICBzdW0gPSBzdW0gKyB4W2pdICogYVtpXVtqXTtcbiAgICAgIH1cbiAgICAgIHhbaV0gPShhW2ldW21hdWcgLSAxXSAtIHN1bSkgLyBhW2ldW2ldO1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfSxcblxuICBnYXVzc19qb3JkYW46IGZ1bmN0aW9uIGdhdXNzX2pvcmRhbihhLCBiKSB7XG4gICAgdmFyIG0gPSBqU3RhdC5hdWcoYSwgYik7XG4gICAgdmFyIGggPSBtLmxlbmd0aDtcbiAgICB2YXIgdyA9IG1bMF0ubGVuZ3RoO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgeCwgeSwgeTI7XG4gICAgLy8gZmluZCBtYXggcGl2b3RcbiAgICBmb3IgKHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgICB2YXIgbWF4cm93ID0geTtcbiAgICAgIGZvciAoeTIgPSB5KzE7IHkyIDwgaDsgeTIrKykge1xuICAgICAgICBpZiAoTWF0aC5hYnMobVt5Ml1beV0pID4gTWF0aC5hYnMobVttYXhyb3ddW3ldKSlcbiAgICAgICAgICBtYXhyb3cgPSB5MjtcbiAgICAgIH1cbiAgICAgIHZhciB0bXAgPSBtW3ldO1xuICAgICAgbVt5XSA9IG1bbWF4cm93XTtcbiAgICAgIG1bbWF4cm93XSA9IHRtcFxuICAgICAgZm9yICh5MiA9IHkrMTsgeTIgPCBoOyB5MisrKSB7XG4gICAgICAgIGMgPSBtW3kyXVt5XSAvIG1beV1beV07XG4gICAgICAgIGZvciAoeCA9IHk7IHggPCB3OyB4KyspIHtcbiAgICAgICAgICBtW3kyXVt4XSAtPSBtW3ldW3hdICogYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBiYWNrc3Vic3RpdHV0ZVxuICAgIGZvciAoeSA9IGgtMTsgeSA+PSAwOyB5LS0pIHtcbiAgICAgIGMgPSBtW3ldW3ldO1xuICAgICAgZm9yICh5MiA9IDA7IHkyIDwgeTsgeTIrKykge1xuICAgICAgICBmb3IgKHggPSB3LTE7IHggPiB5LTE7IHgtLSkge1xuICAgICAgICAgIG1beTJdW3hdIC09IG1beV1beF0gKiBtW3kyXVt5XSAvIGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1beV1beV0gLz0gYztcbiAgICAgIGZvciAoeCA9IGg7IHggPCB3OyB4KyspIHtcbiAgICAgICAgbVt5XVt4XSAvPSBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfSxcblxuICAvLyBzb2x2ZSBlcXVhdGlvblxuICAvLyBBeD1iXG4gIC8vIEEgaXMgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAgLy8gQT1bWzEsMiwzXSxbMCw0LDVdLFswLDYsN11dXG4gIC8vIGI9WzEsMiwzXVxuICAvLyB0cmlhVXBTb2x2ZShBLGIpIC8vIC0+IFsyLjY2NiwwLjE2NjYsMS42NjZdXG4gIC8vIGlmIHlvdSB1c2UgbWF0cml4IHN0eWxlXG4gIC8vIEE9W1sxLDIsM10sWzAsNCw1XSxbMCw2LDddXVxuICAvLyBiPVtbMV0sWzJdLFszXV1cbiAgLy8gd2lsbCByZXR1cm4gW1syLjY2Nl0sWzAuMTY2Nl0sWzEuNjY2XV1cbiAgdHJpYVVwU29sdmU6IGZ1bmN0aW9uIHRyaWFVcFNvbHZlKEEsIGIpIHtcbiAgICB2YXIgc2l6ZSA9IEFbMF0ubGVuZ3RoO1xuICAgIHZhciB4ID0galN0YXQuemVyb3MoMSwgc2l6ZSlbMF07XG4gICAgdmFyIHBhcnRzO1xuICAgIHZhciBtYXRyaXhfbW9kZSA9IGZhbHNlO1xuXG4gICAgaWYgKGJbMF0ubGVuZ3RoICE9IHVuZGVmaW5lZCkge1xuICAgICAgYiA9IGIubWFwKGZ1bmN0aW9uKGkpeyByZXR1cm4gaVswXSB9KTtcbiAgICAgIG1hdHJpeF9tb2RlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBqU3RhdC5hcmFuZ2Uoc2l6ZSAtIDEsIC0xLCAtMSkuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBwYXJ0cyA9IGpTdGF0LmFyYW5nZShpICsgMSwgc2l6ZSkubWFwKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgcmV0dXJuIHhbal0gKiBBW2ldW2pdO1xuICAgICAgfSk7XG4gICAgICB4W2ldID0gKGJbaV0gLSBqU3RhdC5zdW0ocGFydHMpKSAvIEFbaV1baV07XG4gICAgfSk7XG5cbiAgICBpZiAobWF0cml4X21vZGUpXG4gICAgICByZXR1cm4geC5tYXAoZnVuY3Rpb24oaSl7IHJldHVybiBbaV0gfSk7XG4gICAgcmV0dXJuIHg7XG4gIH0sXG5cbiAgdHJpYUxvd1NvbHZlOiBmdW5jdGlvbiB0cmlhTG93U29sdmUoQSwgYikge1xuICAgIC8vIGxpa2UgdG8gdHJpYVVwU29sdmUgYnV0IEEgaXMgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAgICB2YXIgc2l6ZSA9IEFbMF0ubGVuZ3RoO1xuICAgIHZhciB4ID0galN0YXQuemVyb3MoMSwgc2l6ZSlbMF07XG4gICAgdmFyIHBhcnRzO1xuXG4gICAgdmFyIG1hdHJpeF9tb2RlPWZhbHNlO1xuICAgIGlmIChiWzBdLmxlbmd0aCAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGIgPSBiLm1hcChmdW5jdGlvbihpKXsgcmV0dXJuIGlbMF0gfSk7XG4gICAgICBtYXRyaXhfbW9kZSA9IHRydWU7XG4gICAgfVxuXG4gICAgalN0YXQuYXJhbmdlKHNpemUpLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgcGFydHMgPSBqU3RhdC5hcmFuZ2UoaSkubWFwKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgcmV0dXJuIEFbaV1bal0gKiB4W2pdO1xuICAgICAgfSk7XG4gICAgICB4W2ldID0gKGJbaV0gLSBqU3RhdC5zdW0ocGFydHMpKSAvIEFbaV1baV07XG4gICAgfSlcblxuICAgIGlmIChtYXRyaXhfbW9kZSlcbiAgICAgIHJldHVybiB4Lm1hcChmdW5jdGlvbihpKXsgcmV0dXJuIFtpXSB9KTtcbiAgICByZXR1cm4geDtcbiAgfSxcblxuXG4gIC8vIEEgLT4gW0wsVV1cbiAgLy8gQT1MVVxuICAvLyBMIGlzIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XG4gIC8vIFUgaXMgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAgbHU6IGZ1bmN0aW9uIGx1KEEpIHtcbiAgICB2YXIgc2l6ZSA9IEEubGVuZ3RoO1xuICAgIC8vdmFyIEw9alN0YXQuZGlhZ29uYWwoalN0YXQub25lcygxLHNpemUpWzBdKTtcbiAgICB2YXIgTCA9IGpTdGF0LmlkZW50aXR5KHNpemUpO1xuICAgIHZhciBSID0galN0YXQuemVyb3MoQS5sZW5ndGgsIEFbMF0ubGVuZ3RoKTtcbiAgICB2YXIgcGFydHM7XG4gICAgalN0YXQuYXJhbmdlKHNpemUpLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgUlswXVt0XSA9IEFbMF1bdF07XG4gICAgfSk7XG4gICAgalN0YXQuYXJhbmdlKDEsIHNpemUpLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgICAgalN0YXQuYXJhbmdlKGwpLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBwYXJ0cyA9IGpTdGF0LmFyYW5nZShpKS5tYXAoZnVuY3Rpb24oamopIHtcbiAgICAgICAgICByZXR1cm4gTFtsXVtqal0gKiBSW2pqXVtpXTtcbiAgICAgICAgfSk7XG4gICAgICAgIExbbF1baV0gPSAoQVtsXVtpXSAtIGpTdGF0LnN1bShwYXJ0cykpIC8gUltpXVtpXTtcbiAgICAgIH0pO1xuICAgICAgalN0YXQuYXJhbmdlKGwsIHNpemUpLmZvckVhY2goZnVuY3Rpb24oaikge1xuICAgICAgICBwYXJ0cyA9IGpTdGF0LmFyYW5nZShsKS5tYXAoZnVuY3Rpb24oamopIHtcbiAgICAgICAgICByZXR1cm4gTFtsXVtqal0gKiBSW2pqXVtqXTtcbiAgICAgICAgfSk7XG4gICAgICAgIFJbbF1bal0gPSBBW3BhcnRzLmxlbmd0aF1bal0gLSBqU3RhdC5zdW0ocGFydHMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtMLCBSXTtcbiAgfSxcblxuICAvLyBBIC0+IFRcbiAgLy8gQT1UVCdcbiAgLy8gVCBpcyBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICBjaG9sZXNreTogZnVuY3Rpb24gY2hvbGVza3koQSkge1xuICAgIHZhciBzaXplID0gQS5sZW5ndGg7XG4gICAgdmFyIFQgPSBqU3RhdC56ZXJvcyhBLmxlbmd0aCwgQVswXS5sZW5ndGgpO1xuICAgIHZhciBwYXJ0cztcbiAgICBqU3RhdC5hcmFuZ2Uoc2l6ZSkuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBwYXJ0cyA9IGpTdGF0LmFyYW5nZShpKS5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coVFtpXVt0XSwyKTtcbiAgICAgIH0pO1xuICAgICAgVFtpXVtpXSA9IE1hdGguc3FydChBW2ldW2ldIC0galN0YXQuc3VtKHBhcnRzKSk7XG4gICAgICBqU3RhdC5hcmFuZ2UoaSArIDEsIHNpemUpLmZvckVhY2goZnVuY3Rpb24oaikge1xuICAgICAgICBwYXJ0cyA9IGpTdGF0LmFyYW5nZShpKS5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgICAgIHJldHVybiBUW2ldW3RdICogVFtqXVt0XTtcbiAgICAgICAgfSk7XG4gICAgICAgIFRbal1baV0gPSAoQVtpXVtqXSAtIGpTdGF0LnN1bShwYXJ0cykpIC8gVFtpXVtpXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBUO1xuICB9LFxuXG5cbiAgZ2F1c3NfamFjb2JpOiBmdW5jdGlvbiBnYXVzc19qYWNvYmkoYSwgYiwgeCwgcikge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIG4gPSBhLmxlbmd0aDtcbiAgICB2YXIgbCA9IFtdO1xuICAgIHZhciB1ID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgeHYsIGMsIGgsIHhrO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsW2ldID0gW107XG4gICAgICB1W2ldID0gW107XG4gICAgICBkW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIGxbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIHVbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgaikge1xuICAgICAgICAgIHVbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gdVtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaCA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihkKSwgalN0YXQuYWRkKGwsIHUpKSwgLTEpO1xuICAgIGMgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoZCksIGIpO1xuICAgIHh2ID0geDtcbiAgICB4ayA9IGpTdGF0LmFkZChqU3RhdC5tdWx0aXBseShoLCB4KSwgYyk7XG4gICAgaSA9IDI7XG4gICAgd2hpbGUgKE1hdGguYWJzKGpTdGF0Lm5vcm0oalN0YXQuc3VidHJhY3QoeGsseHYpKSkgPiByKSB7XG4gICAgICB4diA9IHhrO1xuICAgICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeHYpLCBjKTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHhrO1xuICB9LFxuXG4gIGdhdXNzX3NlaWRlbDogZnVuY3Rpb24gZ2F1c3Nfc2VpZGVsKGEsIGIsIHgsIHIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG4gPSBhLmxlbmd0aDtcbiAgICB2YXIgbCA9IFtdO1xuICAgIHZhciB1ID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgaiwgeHYsIGMsIGgsIHhrO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsW2ldID0gW107XG4gICAgICB1W2ldID0gW107XG4gICAgICBkW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIGxbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIHVbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgaikge1xuICAgICAgICAgIHVbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gdVtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaCA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihqU3RhdC5hZGQoZCwgbCkpLCB1KSwgLTEpO1xuICAgIGMgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoalN0YXQuYWRkKGQsIGwpKSwgYik7XG4gICAgeHYgPSB4O1xuICAgIHhrID0galN0YXQuYWRkKGpTdGF0Lm11bHRpcGx5KGgsIHgpLCBjKTtcbiAgICBpID0gMjtcbiAgICB3aGlsZSAoTWF0aC5hYnMoalN0YXQubm9ybShqU3RhdC5zdWJ0cmFjdCh4aywgeHYpKSkgPiByKSB7XG4gICAgICB4diA9IHhrO1xuICAgICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeHYpLCBjKTtcbiAgICAgIGkgPSBpICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHhrO1xuICB9LFxuXG4gIFNPUjogZnVuY3Rpb24gU09SKGEsIGIsIHgsIHIsIHcpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG4gPSBhLmxlbmd0aDtcbiAgICB2YXIgbCA9IFtdO1xuICAgIHZhciB1ID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgaiwgeHYsIGMsIGgsIHhrO1xuICAgIGZvciAoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsW2ldID0gW107XG4gICAgICB1W2ldID0gW107XG4gICAgICBkW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIGxbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIHVbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgaikge1xuICAgICAgICAgIHVbaV1bal0gPSBhW2ldW2pdO1xuICAgICAgICAgIGxbaV1bal0gPSBkW2ldW2pdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkW2ldW2pdID0gYVtpXVtqXTtcbiAgICAgICAgICBsW2ldW2pdID0gdVtpXVtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaCA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0LmludihqU3RhdC5hZGQoZCwgalN0YXQubXVsdGlwbHkobCwgdykpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgalN0YXQuc3VidHJhY3QoalN0YXQubXVsdGlwbHkoZCwgMSAtIHcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqU3RhdC5tdWx0aXBseSh1LCB3KSkpO1xuICAgIGMgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseShqU3RhdC5pbnYoalN0YXQuYWRkKGQsXG4gICAgICAgIGpTdGF0Lm11bHRpcGx5KGwsIHcpKSksIGIpLCB3KTtcbiAgICB4diA9IHg7XG4gICAgeGsgPSBqU3RhdC5hZGQoalN0YXQubXVsdGlwbHkoaCwgeCksIGMpO1xuICAgIGkgPSAyO1xuICAgIHdoaWxlIChNYXRoLmFicyhqU3RhdC5ub3JtKGpTdGF0LnN1YnRyYWN0KHhrLCB4dikpKSA+IHIpIHtcbiAgICAgIHh2ID0geGs7XG4gICAgICB4ayA9IGpTdGF0LmFkZChqU3RhdC5tdWx0aXBseShoLCB4diksIGMpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4geGs7XG4gIH0sXG5cbiAgaG91c2Vob2xkZXI6IGZ1bmN0aW9uIGhvdXNlaG9sZGVyKGEpIHtcbiAgICB2YXIgbSA9IGEubGVuZ3RoO1xuICAgIHZhciBuID0gYVswXS5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciB3ID0gW107XG4gICAgdmFyIHAgPSBbXTtcbiAgICB2YXIgYWxwaGEsIHIsIGssIGosIGZhY3RvcjtcbiAgICBmb3IgKDsgaSA8IG0gLSAxOyBpKyspIHtcbiAgICAgIGFscGhhID0gMDtcbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgaisrKVxuICAgICAgYWxwaGEgKz0gKGFbal1baV0gKiBhW2pdW2ldKTtcbiAgICAgIGZhY3RvciA9IChhW2kgKyAxXVtpXSA+IDApID8gLTEgOiAxO1xuICAgICAgYWxwaGEgPSBmYWN0b3IgKiBNYXRoLnNxcnQoYWxwaGEpO1xuICAgICAgciA9IE1hdGguc3FydCgoKChhbHBoYSAqIGFscGhhKSAtIGFbaSArIDFdW2ldICogYWxwaGEpIC8gMikpO1xuICAgICAgdyA9IGpTdGF0Lnplcm9zKG0sIDEpO1xuICAgICAgd1tpICsgMV1bMF0gPSAoYVtpICsgMV1baV0gLSBhbHBoYSkgLyAoMiAqIHIpO1xuICAgICAgZm9yIChrID0gaSArIDI7IGsgPCBtOyBrKyspIHdba11bMF0gPSBhW2tdW2ldIC8gKDIgKiByKTtcbiAgICAgIHAgPSBqU3RhdC5zdWJ0cmFjdChqU3RhdC5pZGVudGl0eShtLCBuKSxcbiAgICAgICAgICBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseSh3LCBqU3RhdC50cmFuc3Bvc2UodykpLCAyKSk7XG4gICAgICBhID0galN0YXQubXVsdGlwbHkocCwgalN0YXQubXVsdGlwbHkoYSwgcCkpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfSxcblxuICAvLyBBIC0+IFtRLFJdXG4gIC8vIFEgaXMgb3J0aG9nb25hbCBtYXRyaXhcbiAgLy8gUiBpcyB1cHBlciB0cmlhbmd1bGFyXG4gIFFSOiAoZnVuY3Rpb24oKSB7XG4gICAgLy8geCAtPiBRXG4gICAgLy8gZmluZCBhIG9ydGhvZ29uYWwgbWF0cml4IFEgc3QuXG4gICAgLy8gUXg9eVxuICAgIC8vIHkgaXMgW3x8eHx8LDAsMCwuLi5dXG5cbiAgICAvLyBxdWljayByZWZcbiAgICB2YXIgc3VtICAgPSBqU3RhdC5zdW07XG4gICAgdmFyIHJhbmdlID0galN0YXQuYXJhbmdlO1xuXG4gICAgZnVuY3Rpb24gcXIyKHgpIHtcbiAgICAgIC8vIHF1aWNrIGltcGxldGF0aW9uXG4gICAgICAvLyBodHRwczovL3d3dy5zdGF0Lndpc2MuZWR1L35sYXJnZXQvbWF0aDQ5Ni9xci5odG1sXG5cbiAgICAgIHZhciBuID0geC5sZW5ndGg7XG4gICAgICB2YXIgcCA9IHhbMF0ubGVuZ3RoO1xuXG4gICAgICB2YXIgciA9IGpTdGF0Lnplcm9zKHAsIHApO1xuICAgICAgeCA9IGpTdGF0LmNvcHkoeCk7XG5cbiAgICAgIHZhciBpLGosaztcbiAgICAgIGZvcihqID0gMDsgaiA8IHA7IGorKyl7XG4gICAgICAgIHJbal1bal0gPSBNYXRoLnNxcnQoc3VtKHJhbmdlKG4pLm1hcChmdW5jdGlvbihpKXtcbiAgICAgICAgICByZXR1cm4geFtpXVtqXSAqIHhbaV1bal07XG4gICAgICAgIH0pKSk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IG47IGkrKyl7XG4gICAgICAgICAgeFtpXVtqXSA9IHhbaV1bal0gLyByW2pdW2pdO1xuICAgICAgICB9XG4gICAgICAgIGZvcihrID0gaisxOyBrIDwgcDsgaysrKXtcbiAgICAgICAgICByW2pdW2tdID0gc3VtKHJhbmdlKG4pLm1hcChmdW5jdGlvbihpKXtcbiAgICAgICAgICAgIHJldHVybiB4W2ldW2pdICogeFtpXVtrXTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbjsgaSsrKXtcbiAgICAgICAgICAgIHhbaV1ba10gPSB4W2ldW2tdIC0geFtpXVtqXSpyW2pdW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFt4LCByXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXIyO1xuICB9KCkpLFxuXG4gIGxzdHNxOiAoZnVuY3Rpb24oKSB7XG4gICAgLy8gc29sdmUgbGVhc3Qgc3F1YXJkIHByb2JsZW0gZm9yIEF4PWIgYXMgUVIgZGVjb21wb3NpdGlvbiB3YXkgaWYgYiBpc1xuICAgIC8vIFtbYjFdLFtiMl0sW2IzXV0gZm9ybSB3aWxsIHJldHVybiBbW3gxXSxbeDJdLFt4M11dIGFycmF5IGZvcm0gc29sdXRpb25cbiAgICAvLyBlbHNlIGIgaXMgW2IxLGIyLGIzXSBmb3JtIHdpbGwgcmV0dXJuIFt4MSx4Mix4M10gYXJyYXkgZm9ybSBzb2x1dGlvblxuICAgIGZ1bmN0aW9uIFJfSShBKSB7XG4gICAgICBBID0galN0YXQuY29weShBKTtcbiAgICAgIHZhciBzaXplID0gQS5sZW5ndGg7XG4gICAgICB2YXIgSSA9IGpTdGF0LmlkZW50aXR5KHNpemUpO1xuICAgICAgalN0YXQuYXJhbmdlKHNpemUgLSAxLCAtMSwgLTEpLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBqU3RhdC5zbGljZUFzc2lnbihcbiAgICAgICAgICAgIEksIHsgcm93OiBpIH0sIGpTdGF0LmRpdmlkZShqU3RhdC5zbGljZShJLCB7IHJvdzogaSB9KSwgQVtpXVtpXSkpO1xuICAgICAgICBqU3RhdC5zbGljZUFzc2lnbihcbiAgICAgICAgICAgIEEsIHsgcm93OiBpIH0sIGpTdGF0LmRpdmlkZShqU3RhdC5zbGljZShBLCB7IHJvdzogaSB9KSwgQVtpXVtpXSkpO1xuICAgICAgICBqU3RhdC5hcmFuZ2UoaSkuZm9yRWFjaChmdW5jdGlvbihqKSB7XG4gICAgICAgICAgdmFyIGMgPSBqU3RhdC5tdWx0aXBseShBW2pdW2ldLCAtMSk7XG4gICAgICAgICAgdmFyIEFqID0galN0YXQuc2xpY2UoQSwgeyByb3c6IGogfSk7XG4gICAgICAgICAgdmFyIGNBaSA9IGpTdGF0Lm11bHRpcGx5KGpTdGF0LnNsaWNlKEEsIHsgcm93OiBpIH0pLCBjKTtcbiAgICAgICAgICBqU3RhdC5zbGljZUFzc2lnbihBLCB7IHJvdzogaiB9LCBqU3RhdC5hZGQoQWosIGNBaSkpO1xuICAgICAgICAgIHZhciBJaiA9IGpTdGF0LnNsaWNlKEksIHsgcm93OiBqIH0pO1xuICAgICAgICAgIHZhciBjSWkgPSBqU3RhdC5tdWx0aXBseShqU3RhdC5zbGljZShJLCB7IHJvdzogaSB9KSwgYyk7XG4gICAgICAgICAgalN0YXQuc2xpY2VBc3NpZ24oSSwgeyByb3c6IGogfSwgalN0YXQuYWRkKElqLCBjSWkpKTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIEk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcXJfc29sdmUoQSwgYil7XG4gICAgICB2YXIgYXJyYXlfbW9kZSA9IGZhbHNlO1xuICAgICAgaWYgKGJbMF0ubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gW2MxLGMyLGMzXSBtb2RlXG4gICAgICAgIGIgPSBiLm1hcChmdW5jdGlvbih4KXsgcmV0dXJuIFt4XSB9KTtcbiAgICAgICAgYXJyYXlfbW9kZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgUVIgPSBqU3RhdC5RUihBKTtcbiAgICAgIHZhciBRID0gUVJbMF07XG4gICAgICB2YXIgUiA9IFFSWzFdO1xuICAgICAgdmFyIGF0dHJzID0gQVswXS5sZW5ndGg7XG4gICAgICB2YXIgUTEgPSBqU3RhdC5zbGljZShRLHtjb2w6e2VuZDphdHRyc319KTtcbiAgICAgIHZhciBSMSA9IGpTdGF0LnNsaWNlKFIse3Jvdzp7ZW5kOmF0dHJzfX0pO1xuICAgICAgdmFyIFJJID0gUl9JKFIxKTtcbiAgICAgIHZhciBRMiA9IGpTdGF0LnRyYW5zcG9zZShRMSk7XG5cbiAgICAgIGlmKFEyWzBdLmxlbmd0aCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgICAgUTIgPSBbUTJdOyAvLyBUaGUgY29uZnVzaW5nIGpTdGF0Lm11bHRpZmx5IGltcGxlbWVudGF0aW9uIHRocmVhdCBuYXR1cmUgcHJvY2VzcyBhZ2Fpbi5cbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBqU3RhdC5tdWx0aXBseShqU3RhdC5tdWx0aXBseShSSSwgUTIpLCBiKTtcblxuICAgICAgaWYoeC5sZW5ndGggPT09IHVuZGVmaW5lZCl7XG4gICAgICAgIHggPSBbW3hdXTsgLy8gVGhlIGNvbmZ1c2luZyBqU3RhdC5tdWx0aWZseSBpbXBsZW1lbnRhdGlvbiB0aHJlYXQgbmF0dXJlIHByb2Nlc3MgYWdhaW4uXG4gICAgICB9XG5cblxuICAgICAgaWYgKGFycmF5X21vZGUpXG4gICAgICAgIHJldHVybiB4Lm1hcChmdW5jdGlvbihpKXsgcmV0dXJuIGlbMF0gfSk7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICByZXR1cm4gcXJfc29sdmU7XG4gIH0oKSksXG5cbiAgamFjb2JpOiBmdW5jdGlvbiBqYWNvYmkoYSkge1xuICAgIHZhciBjb25kaXRpb24gPSAxO1xuICAgIHZhciBuID0gYS5sZW5ndGg7XG4gICAgdmFyIGUgPSBqU3RhdC5pZGVudGl0eShuLCBuKTtcbiAgICB2YXIgZXYgPSBbXTtcbiAgICB2YXIgYiwgaSwgaiwgcCwgcSwgbWF4aW0sIHRoZXRhLCBzO1xuICAgIC8vIGNvbmRpdGlvbiA9PT0gMSBvbmx5IGlmIHRvbGVyYW5jZSBpcyBub3QgcmVhY2hlZFxuICAgIHdoaWxlIChjb25kaXRpb24gPT09IDEpIHtcbiAgICAgIG1heGltID0gYVswXVsxXTtcbiAgICAgIHAgPSAwO1xuICAgICAgcSA9IDE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICBpZiAoaSAhPSBqKSB7XG4gICAgICAgICAgICBpZiAobWF4aW0gPCBNYXRoLmFicyhhW2ldW2pdKSkge1xuICAgICAgICAgICAgICBtYXhpbSA9IE1hdGguYWJzKGFbaV1bal0pO1xuICAgICAgICAgICAgICBwID0gaTtcbiAgICAgICAgICAgICAgcSA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYVtwXVtwXSA9PT0gYVtxXVtxXSlcbiAgICAgICAgdGhldGEgPSAoYVtwXVtxXSA+IDApID8gTWF0aC5QSSAvIDQgOiAtTWF0aC5QSSAvIDQ7XG4gICAgICBlbHNlXG4gICAgICAgIHRoZXRhID0gTWF0aC5hdGFuKDIgKiBhW3BdW3FdIC8gKGFbcF1bcF0gLSBhW3FdW3FdKSkgLyAyO1xuICAgICAgcyA9IGpTdGF0LmlkZW50aXR5KG4sIG4pO1xuICAgICAgc1twXVtwXSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHNbcF1bcV0gPSAtTWF0aC5zaW4odGhldGEpO1xuICAgICAgc1txXVtwXSA9IE1hdGguc2luKHRoZXRhKTtcbiAgICAgIHNbcV1bcV0gPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAvLyBlaWdlbiB2ZWN0b3IgbWF0cml4XG4gICAgICBlID0galN0YXQubXVsdGlwbHkoZSwgcyk7XG4gICAgICBiID0galN0YXQubXVsdGlwbHkoalN0YXQubXVsdGlwbHkoalN0YXQuaW52KHMpLCBhKSwgcyk7XG4gICAgICBhID0gYjtcbiAgICAgIGNvbmRpdGlvbiA9IDA7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICBpZiAoaSAhPSBqICYmIE1hdGguYWJzKGFbaV1bal0pID4gMC4wMDEpIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbiA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGV2LnB1c2goYVtpXVtpXSk7XG4gICAgLy9yZXR1cm5zIGJvdGggdGhlIGVpZ2VudmFsdWUgYW5kIGVpZ2VubWF0cml4XG4gICAgcmV0dXJuIFtlLCBldl07XG4gIH0sXG5cbiAgcnVuZ2VrdXR0YTogZnVuY3Rpb24gcnVuZ2VrdXR0YShmLCBoLCBwLCB0X2osIHVfaiwgb3JkZXIpIHtcbiAgICB2YXIgazEsIGsyLCB1X2oxLCBrMywgazQ7XG4gICAgaWYgKG9yZGVyID09PSAyKSB7XG4gICAgICB3aGlsZSAodF9qIDw9IHApIHtcbiAgICAgICAgazEgPSBoICogZih0X2osIHVfaik7XG4gICAgICAgIGsyID0gaCAqIGYodF9qICsgaCwgdV9qICsgazEpO1xuICAgICAgICB1X2oxID0gdV9qICsgKGsxICsgazIpIC8gMjtcbiAgICAgICAgdV9qID0gdV9qMTtcbiAgICAgICAgdF9qID0gdF9qICsgaDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9yZGVyID09PSA0KSB7XG4gICAgICB3aGlsZSAodF9qIDw9IHApIHtcbiAgICAgICAgazEgPSBoICogZih0X2osIHVfaik7XG4gICAgICAgIGsyID0gaCAqIGYodF9qICsgaCAvIDIsIHVfaiArIGsxIC8gMik7XG4gICAgICAgIGszID0gaCAqIGYodF9qICsgaCAvIDIsIHVfaiArIGsyIC8gMik7XG4gICAgICAgIGs0ID0gaCAqIGYodF9qICtoLCB1X2ogKyBrMyk7XG4gICAgICAgIHVfajEgPSB1X2ogKyAoazEgKyAyICogazIgKyAyICogazMgKyBrNCkgLyA2O1xuICAgICAgICB1X2ogPSB1X2oxO1xuICAgICAgICB0X2ogPSB0X2ogKyBoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdV9qO1xuICB9LFxuXG4gIHJvbWJlcmc6IGZ1bmN0aW9uIHJvbWJlcmcoZiwgYSwgYiwgb3JkZXIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGggPSAoYiAtIGEpIC8gMjtcbiAgICB2YXIgeCA9IFtdO1xuICAgIHZhciBoMSA9IFtdO1xuICAgIHZhciBnID0gW107XG4gICAgdmFyIG0sIGExLCBqLCBrLCBJO1xuICAgIHdoaWxlIChpIDwgb3JkZXIgLyAyKSB7XG4gICAgICBJID0gZihhKTtcbiAgICAgIGZvciAoaiA9IGEsIGsgPSAwOyBqIDw9IGI7IGogPSBqICsgaCwgaysrKSB4W2tdID0gajtcbiAgICAgIG0gPSB4Lmxlbmd0aDtcbiAgICAgIGZvciAoaiA9IDE7IGogPCBtIC0gMTsgaisrKSB7XG4gICAgICAgIEkgKz0gKCgoaiAlIDIpICE9PSAwKSA/IDQgOiAyKSAqIGYoeFtqXSk7XG4gICAgICB9XG4gICAgICBJID0gKGggLyAzKSAqIChJICsgZihiKSk7XG4gICAgICBnW2ldID0gSTtcbiAgICAgIGggLz0gMjtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgYTEgPSBnLmxlbmd0aDtcbiAgICBtID0gMTtcbiAgICB3aGlsZSAoYTEgIT09IDEpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBhMSAtIDE7IGorKylcbiAgICAgIGgxW2pdID0gKChNYXRoLnBvdyg0LCBtKSkgKiBnW2ogKyAxXSAtIGdbal0pIC8gKE1hdGgucG93KDQsIG0pIC0gMSk7XG4gICAgICBhMSA9IGgxLmxlbmd0aDtcbiAgICAgIGcgPSBoMTtcbiAgICAgIGgxID0gW107XG4gICAgICBtKys7XG4gICAgfVxuICAgIHJldHVybiBnO1xuICB9LFxuXG4gIHJpY2hhcmRzb246IGZ1bmN0aW9uIHJpY2hhcmRzb24oWCwgZiwgeCwgaCkge1xuICAgIGZ1bmN0aW9uIHBvcyhYLCB4KSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbiA9IFgubGVuZ3RoO1xuICAgICAgdmFyIHA7XG4gICAgICBmb3IgKDsgaSA8IG47IGkrKylcbiAgICAgICAgaWYgKFhbaV0gPT09IHgpIHAgPSBpO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHZhciBoX21pbiA9IE1hdGguYWJzKHggLSBYW3BvcyhYLCB4KSArIDFdKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGcgPSBbXTtcbiAgICB2YXIgaDEgPSBbXTtcbiAgICB2YXIgeTEsIHkyLCBtLCBhLCBqO1xuICAgIHdoaWxlIChoID49IGhfbWluKSB7XG4gICAgICB5MSA9IHBvcyhYLCB4ICsgaCk7XG4gICAgICB5MiA9IHBvcyhYLCB4KTtcbiAgICAgIGdbaV0gPSAoZlt5MV0gLSAyICogZlt5Ml0gKyBmWzIgKiB5MiAtIHkxXSkgLyAoaCAqIGgpO1xuICAgICAgaCAvPSAyO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBhID0gZy5sZW5ndGg7XG4gICAgbSA9IDE7XG4gICAgd2hpbGUgKGEgIT0gMSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGEgLSAxOyBqKyspXG4gICAgICAgIGgxW2pdID0gKChNYXRoLnBvdyg0LCBtKSkgKiBnW2ogKyAxXSAtIGdbal0pIC8gKE1hdGgucG93KDQsIG0pIC0gMSk7XG4gICAgICBhID0gaDEubGVuZ3RoO1xuICAgICAgZyA9IGgxO1xuICAgICAgaDEgPSBbXTtcbiAgICAgIG0rKztcbiAgICB9XG4gICAgcmV0dXJuIGc7XG4gIH0sXG5cbiAgc2ltcHNvbjogZnVuY3Rpb24gc2ltcHNvbihmLCBhLCBiLCBuKSB7XG4gICAgdmFyIGggPSAoYiAtIGEpIC8gbjtcbiAgICB2YXIgSSA9IGYoYSk7XG4gICAgdmFyIHggPSBbXTtcbiAgICB2YXIgaiA9IGE7XG4gICAgdmFyIGsgPSAwO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgbTtcbiAgICBmb3IgKDsgaiA8PSBiOyBqID0gaiArIGgsIGsrKylcbiAgICAgIHhba10gPSBqO1xuICAgIG0gPSB4Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IG0gLSAxOyBpKyspIHtcbiAgICAgIEkgKz0gKChpICUgMiAhPT0gMCkgPyA0IDogMikgKiBmKHhbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gKGggLyAzKSAqIChJICsgZihiKSk7XG4gIH0sXG5cbiAgaGVybWl0ZTogZnVuY3Rpb24gaGVybWl0ZShYLCBGLCBkRiwgdmFsdWUpIHtcbiAgICB2YXIgbiA9IFgubGVuZ3RoO1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGwgPSBbXTtcbiAgICB2YXIgZGwgPSBbXTtcbiAgICB2YXIgQSA9IFtdO1xuICAgIHZhciBCID0gW107XG4gICAgdmFyIGo7XG4gICAgZm9yICg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxbaV0gPSAxO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoaSAhPSBqKSBsW2ldICo9ICh2YWx1ZSAtIFhbal0pIC8gKFhbaV0gLSBYW2pdKTtcbiAgICAgIH1cbiAgICAgIGRsW2ldID0gMDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKGkgIT0gaikgZGxbaV0gKz0gMSAvIChYIFtpXSAtIFhbal0pO1xuICAgICAgfVxuICAgICAgQVtpXSA9ICgxIC0gMiAqICh2YWx1ZSAtIFhbaV0pICogZGxbaV0pICogKGxbaV0gKiBsW2ldKTtcbiAgICAgIEJbaV0gPSAodmFsdWUgLSBYW2ldKSAqIChsW2ldICogbFtpXSk7XG4gICAgICBwICs9IChBW2ldICogRltpXSArIEJbaV0gKiBkRltpXSk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIGxhZ3JhbmdlOiBmdW5jdGlvbiBsYWdyYW5nZShYLCBGLCB2YWx1ZSkge1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGosIGw7XG4gICAgdmFyIG4gPSBYLmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgbCA9IEZbaV07XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIC8vIGNhbGN1bGF0aW5nIHRoZSBsYWdyYW5nZSBwb2x5bm9taWFsIExfaVxuICAgICAgICBpZiAoaSAhPSBqKSBsICo9ICh2YWx1ZSAtIFhbal0pIC8gKFhbaV0gLSBYW2pdKTtcbiAgICAgIH1cbiAgICAgIC8vIGFkZGluZyB0aGUgbGFncmFuZ2UgcG9seW5vbWlhbHMgZm91bmQgYWJvdmVcbiAgICAgIHAgKz0gbDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgY3ViaWNfc3BsaW5lOiBmdW5jdGlvbiBjdWJpY19zcGxpbmUoWCwgRiwgdmFsdWUpIHtcbiAgICB2YXIgbiA9IFgubGVuZ3RoO1xuICAgIHZhciBpID0gMCwgajtcbiAgICB2YXIgQSA9IFtdO1xuICAgIHZhciBCID0gW107XG4gICAgdmFyIGFscGhhID0gW107XG4gICAgdmFyIGMgPSBbXTtcbiAgICB2YXIgaCA9IFtdO1xuICAgIHZhciBiID0gW107XG4gICAgdmFyIGQgPSBbXTtcbiAgICBmb3IgKDsgaSA8IG4gLSAxOyBpKyspXG4gICAgICBoW2ldID0gWFtpICsgMV0gLSBYW2ldO1xuICAgIGFscGhhWzBdID0gMDtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgYWxwaGFbaV0gPSAoMyAvIGhbaV0pICogKEZbaSArIDFdIC0gRltpXSkgLVxuICAgICAgICAgICgzIC8gaFtpLTFdKSAqIChGW2ldIC0gRltpLTFdKTtcbiAgICB9XG4gICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIEFbaV0gPSBbXTtcbiAgICAgIEJbaV0gPSBbXTtcbiAgICAgIEFbaV1baS0xXSA9IGhbaS0xXTtcbiAgICAgIEFbaV1baV0gPSAyICogKGhbaSAtIDFdICsgaFtpXSk7XG4gICAgICBBW2ldW2krMV0gPSBoW2ldO1xuICAgICAgQltpXVswXSA9IGFscGhhW2ldO1xuICAgIH1cbiAgICBjID0galN0YXQubXVsdGlwbHkoalN0YXQuaW52KEEpLCBCKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbiAtIDE7IGorKykge1xuICAgICAgYltqXSA9IChGW2ogKyAxXSAtIEZbal0pIC8gaFtqXSAtIGhbal0gKiAoY1tqICsgMV1bMF0gKyAyICogY1tqXVswXSkgLyAzO1xuICAgICAgZFtqXSA9IChjW2ogKyAxXVswXSAtIGNbal1bMF0pIC8gKDMgKiBoW2pdKTtcbiAgICB9XG4gICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgaWYgKFhbal0gPiB2YWx1ZSkgYnJlYWs7XG4gICAgfVxuICAgIGogLT0gMTtcbiAgICByZXR1cm4gRltqXSArICh2YWx1ZSAtIFhbal0pICogYltqXSArIGpTdGF0LnNxKHZhbHVlLVhbal0pICpcbiAgICAgICAgY1tqXSArICh2YWx1ZSAtIFhbal0pICogalN0YXQuc3EodmFsdWUgLSBYW2pdKSAqIGRbal07XG4gIH0sXG5cbiAgZ2F1c3NfcXVhZHJhdHVyZTogZnVuY3Rpb24gZ2F1c3NfcXVhZHJhdHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dhdXNzX3F1YWRyYXR1cmUgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9LFxuXG4gIFBDQTogZnVuY3Rpb24gUENBKFgpIHtcbiAgICB2YXIgbSA9IFgubGVuZ3RoO1xuICAgIHZhciBuID0gWFswXS5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqLCB0ZW1wMTtcbiAgICB2YXIgdSA9IFtdO1xuICAgIHZhciBEID0gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciB0ZW1wMiA9IFtdO1xuICAgIHZhciBZID0gW107XG4gICAgdmFyIEJ0ID0gW107XG4gICAgdmFyIEIgPSBbXTtcbiAgICB2YXIgQyA9IFtdO1xuICAgIHZhciBWID0gW107XG4gICAgdmFyIFZ0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgdVtpXSA9IGpTdGF0LnN1bShYW2ldKSAvIG47XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIEJbaV0gPSBbXTtcbiAgICAgIGZvcihqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICBCW2ldW2pdID0gWFtqXVtpXSAtIHVbal07XG4gICAgICB9XG4gICAgfVxuICAgIEIgPSBqU3RhdC50cmFuc3Bvc2UoQik7XG4gICAgZm9yIChpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgQ1tpXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICBDW2ldW2pdID0gKGpTdGF0LmRvdChbQltpXV0sIFtCW2pdXSkpIC8gKG4gLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ID0galN0YXQuamFjb2JpKEMpO1xuICAgIFYgPSByZXN1bHRbMF07XG4gICAgRCA9IHJlc3VsdFsxXTtcbiAgICBWdCA9IGpTdGF0LnRyYW5zcG9zZShWKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgRC5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChqID0gaTsgaiA8IEQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYoRFtpXSA8IERbal0pICB7XG4gICAgICAgICAgdGVtcDEgPSBEW2ldO1xuICAgICAgICAgIERbaV0gPSBEW2pdO1xuICAgICAgICAgIERbal0gPSB0ZW1wMTtcbiAgICAgICAgICB0ZW1wMiA9IFZ0W2ldO1xuICAgICAgICAgIFZ0W2ldID0gVnRbal07XG4gICAgICAgICAgVnRbal0gPSB0ZW1wMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBCdCA9IGpTdGF0LnRyYW5zcG9zZShCKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICBZW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgQnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgWVtpXVtqXSA9IGpTdGF0LmRvdChbVnRbaV1dLCBbQnRbal1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtYLCBELCBWdCwgWV07XG4gIH1cbn0pO1xuXG4vLyBleHRlbmQgalN0YXQuZm4gd2l0aCBtZXRob2RzIHRoYXQgcmVxdWlyZSBvbmUgYXJndW1lbnRcbihmdW5jdGlvbihmdW5jcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgaSsrKSAoZnVuY3Rpb24ocGFzc2Z1bmMpIHtcbiAgICBqU3RhdC5mbltwYXNzZnVuY10gPSBmdW5jdGlvbihhcmcsIGZ1bmMpIHtcbiAgICAgIHZhciB0bXB0aGlzID0gdGhpcztcbiAgICAgIC8vIGNoZWNrIGZvciBjYWxsYmFja1xuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jLmNhbGwodG1wdGhpcywgalN0YXQuZm5bcGFzc2Z1bmNdLmNhbGwodG1wdGhpcywgYXJnKSk7XG4gICAgICAgIH0sIDE1KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGpTdGF0W3Bhc3NmdW5jXSh0aGlzLCBhcmcpID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIGpTdGF0W3Bhc3NmdW5jXSh0aGlzLCBhcmcpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4galN0YXQoalN0YXRbcGFzc2Z1bmNdKHRoaXMsIGFyZykpO1xuICAgIH07XG4gIH0oZnVuY3NbaV0pKTtcbn0oJ2FkZCBkaXZpZGUgbXVsdGlwbHkgc3VidHJhY3QgZG90IHBvdyBleHAgbG9nIGFicyBub3JtIGFuZ2xlJy5zcGxpdCgnICcpKSk7XG5cbn0oalN0YXQsIE1hdGgpKTtcbihmdW5jdGlvbihqU3RhdCwgTWF0aCkge1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBpc051bWJlciA9IGpTdGF0LnV0aWxzLmlzTnVtYmVyO1xudmFyIGlzQXJyYXkgPSBqU3RhdC51dGlscy5pc0FycmF5O1xuXG4vLyBmbGFnPT10cnVlIGRlbm90ZXMgdXNlIG9mIHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb25cbi8vIFogU3RhdGlzdGljc1xualN0YXQuZXh0ZW5kKHtcbiAgLy8gMiBkaWZmZXJlbnQgcGFyYW1ldGVyIGxpc3RzOlxuICAvLyAodmFsdWUsIG1lYW4sIHNkKVxuICAvLyAodmFsdWUsIGFycmF5LCBmbGFnKVxuICB6c2NvcmU6IGZ1bmN0aW9uIHpzY29yZSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAoaXNOdW1iZXIoYXJnc1sxXSkpIHtcbiAgICAgIHJldHVybiAoYXJnc1swXSAtIGFyZ3NbMV0pIC8gYXJnc1syXTtcbiAgICB9XG4gICAgcmV0dXJuIChhcmdzWzBdIC0galN0YXQubWVhbihhcmdzWzFdKSkgLyBqU3RhdC5zdGRldihhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfSxcblxuICAvLyAzIGRpZmZlcmVudCBwYXJhbXRlciBsaXN0czpcbiAgLy8gKHZhbHVlLCBtZWFuLCBzZCwgc2lkZXMpXG4gIC8vICh6c2NvcmUsIHNpZGVzKVxuICAvLyAodmFsdWUsIGFycmF5LCBzaWRlcywgZmxhZylcbiAgenRlc3Q6IGZ1bmN0aW9uIHp0ZXN0KCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciB6O1xuICAgIGlmIChpc0FycmF5KGFyZ3NbMV0pKSB7XG4gICAgICAvLyAodmFsdWUsIGFycmF5LCBzaWRlcywgZmxhZylcbiAgICAgIHogPSBqU3RhdC56c2NvcmUoYXJnc1swXSxhcmdzWzFdLGFyZ3NbM10pO1xuICAgICAgcmV0dXJuIChhcmdzWzJdID09PSAxKSA/XG4gICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwgMCwgMSkpIDpcbiAgICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLU1hdGguYWJzKHopLCAwLCAxKSoyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMikge1xuICAgICAgICAvLyAodmFsdWUsIG1lYW4sIHNkLCBzaWRlcylcbiAgICAgICAgeiA9IGpTdGF0LnpzY29yZShhcmdzWzBdLGFyZ3NbMV0sYXJnc1syXSk7XG4gICAgICAgIHJldHVybiAoYXJnc1szXSA9PT0gMSkgP1xuICAgICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwwLDEpKSA6XG4gICAgICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLU1hdGguYWJzKHopLDAsMSkqIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gKHpzY29yZSwgc2lkZXMpXG4gICAgICAgIHogPSBhcmdzWzBdO1xuICAgICAgICByZXR1cm4gKGFyZ3NbMV0gPT09IDEpID9cbiAgICAgICAgICAoalN0YXQubm9ybWFsLmNkZigtTWF0aC5hYnMoeiksMCwxKSkgOlxuICAgICAgICAgIChqU3RhdC5ub3JtYWwuY2RmKC1NYXRoLmFicyh6KSwwLDEpKjIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbmpTdGF0LmV4dGVuZChqU3RhdC5mbiwge1xuICB6c2NvcmU6IGZ1bmN0aW9uIHpzY29yZSh2YWx1ZSwgZmxhZykge1xuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1lYW4oKSkgLyB0aGlzLnN0ZGV2KGZsYWcpO1xuICB9LFxuXG4gIHp0ZXN0OiBmdW5jdGlvbiB6dGVzdCh2YWx1ZSwgc2lkZXMsIGZsYWcpIHtcbiAgICB2YXIgenNjb3JlID0gTWF0aC5hYnModGhpcy56c2NvcmUodmFsdWUsIGZsYWcpKTtcbiAgICByZXR1cm4gKHNpZGVzID09PSAxKSA/XG4gICAgICAoalN0YXQubm9ybWFsLmNkZigtenNjb3JlLCAwLCAxKSkgOlxuICAgICAgKGpTdGF0Lm5vcm1hbC5jZGYoLXpzY29yZSwgMCwgMSkgKiAyKTtcbiAgfVxufSk7XG5cbi8vIFQgU3RhdGlzdGljc1xualN0YXQuZXh0ZW5kKHtcbiAgLy8gMiBwYXJhbWV0ZXIgbGlzdHNcbiAgLy8gKHZhbHVlLCBtZWFuLCBzZCwgbilcbiAgLy8gKHZhbHVlLCBhcnJheSlcbiAgdHNjb3JlOiBmdW5jdGlvbiB0c2NvcmUoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIChhcmdzLmxlbmd0aCA9PT0gNCkgP1xuICAgICAgKChhcmdzWzBdIC0gYXJnc1sxXSkgLyAoYXJnc1syXSAvIE1hdGguc3FydChhcmdzWzNdKSkpIDpcbiAgICAgICgoYXJnc1swXSAtIGpTdGF0Lm1lYW4oYXJnc1sxXSkpIC9cbiAgICAgICAoalN0YXQuc3RkZXYoYXJnc1sxXSwgdHJ1ZSkgLyBNYXRoLnNxcnQoYXJnc1sxXS5sZW5ndGgpKSk7XG4gIH0sXG5cbiAgLy8gMyBkaWZmZXJlbnQgcGFyYW10ZXIgbGlzdHM6XG4gIC8vICh2YWx1ZSwgbWVhbiwgc2QsIG4sIHNpZGVzKVxuICAvLyAodHNjb3JlLCBuLCBzaWRlcylcbiAgLy8gKHZhbHVlLCBhcnJheSwgc2lkZXMpXG4gIHR0ZXN0OiBmdW5jdGlvbiB0dGVzdCgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgdHNjb3JlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgdHNjb3JlID0gTWF0aC5hYnMoalN0YXQudHNjb3JlKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pKTtcbiAgICAgIHJldHVybiAoYXJnc1s0XSA9PT0gMSkgP1xuICAgICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC10c2NvcmUsIGFyZ3NbM10tMSkpIDpcbiAgICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzNdLTEpKjIpO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIoYXJnc1sxXSkpIHtcbiAgICAgIHRzY29yZSA9IE1hdGguYWJzKGFyZ3NbMF0pXG4gICAgICByZXR1cm4gKGFyZ3NbMl0gPT0gMSkgP1xuICAgICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC10c2NvcmUsIGFyZ3NbMV0tMSkpIDpcbiAgICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzFdLTEpICogMik7XG4gICAgfVxuICAgIHRzY29yZSA9IE1hdGguYWJzKGpTdGF0LnRzY29yZShhcmdzWzBdLCBhcmdzWzFdKSlcbiAgICByZXR1cm4gKGFyZ3NbMl0gPT0gMSkgP1xuICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzFdLmxlbmd0aC0xKSkgOlxuICAgICAgKGpTdGF0LnN0dWRlbnR0LmNkZigtdHNjb3JlLCBhcmdzWzFdLmxlbmd0aC0xKSAqIDIpO1xuICB9XG59KTtcblxualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIHRzY29yZTogZnVuY3Rpb24gdHNjb3JlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWVhbigpKSAvICh0aGlzLnN0ZGV2KHRydWUpIC8gTWF0aC5zcXJ0KHRoaXMuY29scygpKSk7XG4gIH0sXG5cbiAgdHRlc3Q6IGZ1bmN0aW9uIHR0ZXN0KHZhbHVlLCBzaWRlcykge1xuICAgIHJldHVybiAoc2lkZXMgPT09IDEpID9cbiAgICAgICgxIC0galN0YXQuc3R1ZGVudHQuY2RmKE1hdGguYWJzKHRoaXMudHNjb3JlKHZhbHVlKSksIHRoaXMuY29scygpLTEpKSA6XG4gICAgICAoalN0YXQuc3R1ZGVudHQuY2RmKC1NYXRoLmFicyh0aGlzLnRzY29yZSh2YWx1ZSkpLCB0aGlzLmNvbHMoKS0xKSoyKTtcbiAgfVxufSk7XG5cbi8vIEYgU3RhdGlzdGljc1xualN0YXQuZXh0ZW5kKHtcbiAgLy8gUGFyYW10ZXIgbGlzdCBpcyBhcyBmb2xsb3dzOlxuICAvLyAoYXJyYXkxLCBhcnJheTIsIGFycmF5MywgLi4uKVxuICAvLyBvciBpdCBpcyBhbiBhcnJheSBvZiBhcnJheXNcbiAgLy8gYXJyYXkgb2YgYXJyYXlzIGNvbnZlcnNpb25cbiAgYW5vdmFmc2NvcmU6IGZ1bmN0aW9uIGFub3ZhZnNjb3JlKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGV4cFZhciwgc2FtcGxlLCBzYW1wTWVhbiwgc2FtcFNhbXBNZWFuLCB0bXBhcmdzLCB1bmV4cFZhciwgaSwgajtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRtcGFyZ3MgPSBuZXcgQXJyYXkoYXJnc1swXS5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3NbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG1wYXJnc1tpXSA9IGFyZ3NbMF1baV07XG4gICAgICB9XG4gICAgICBhcmdzID0gdG1wYXJncztcbiAgICB9XG4gICAgLy8gQnVpbGRzIHNhbXBsZSBhcnJheVxuICAgIHNhbXBsZSA9IG5ldyBBcnJheSgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGUuY29uY2F0KGFyZ3NbaV0pO1xuICAgIH1cbiAgICBzYW1wTWVhbiA9IGpTdGF0Lm1lYW4oc2FtcGxlKTtcbiAgICAvLyBDb21wdXRlcyB0aGUgZXhwbGFpbmVkIHZhcmlhbmNlXG4gICAgZXhwVmFyID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwVmFyID0gZXhwVmFyICsgYXJnc1tpXS5sZW5ndGggKiBNYXRoLnBvdyhqU3RhdC5tZWFuKGFyZ3NbaV0pIC0gc2FtcE1lYW4sIDIpO1xuICAgIH1cbiAgICBleHBWYXIgLz0gKGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgLy8gQ29tcHV0ZXMgdW5leHBsYWluZWQgdmFyaWFuY2VcbiAgICB1bmV4cFZhciA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNhbXBTYW1wTWVhbiA9IGpTdGF0Lm1lYW4oYXJnc1tpXSk7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgYXJnc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICB1bmV4cFZhciArPSBNYXRoLnBvdyhhcmdzW2ldW2pdIC0gc2FtcFNhbXBNZWFuLCAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5leHBWYXIgLz0gKHNhbXBsZS5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgcmV0dXJuIGV4cFZhciAvIHVuZXhwVmFyO1xuICB9LFxuXG4gIC8vIDIgZGlmZmVyZW50IHBhcmFtdGVyIHNldHVwc1xuICAvLyAoYXJyYXkxLCBhcnJheTIsIGFycmF5MywgLi4uKVxuICAvLyAoYW5vdmFmc2NvcmUsIGRmMSwgZGYyKVxuICBhbm92YWZ0ZXN0OiBmdW5jdGlvbiBhbm92YWZ0ZXN0KCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGRmMSwgZGYyLCBuLCBpO1xuICAgIGlmIChpc051bWJlcihhcmdzWzBdKSkge1xuICAgICAgcmV0dXJuIDEgLSBqU3RhdC5jZW50cmFsRi5jZGYoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHZhciBhbm92YWZzY29yZSA9IGpTdGF0LmFub3ZhZnNjb3JlKGFyZ3MpO1xuICAgIGRmMSA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICBuID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgbiA9IG4gKyBhcmdzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgZGYyID0gbiAtIGRmMSAtIDE7XG4gICAgcmV0dXJuIDEgLSBqU3RhdC5jZW50cmFsRi5jZGYoYW5vdmFmc2NvcmUsIGRmMSwgZGYyKTtcbiAgfSxcblxuICBmdGVzdDogZnVuY3Rpb24gZnRlc3QoZnNjb3JlLCBkZjEsIGRmMikge1xuICAgIHJldHVybiAxIC0galN0YXQuY2VudHJhbEYuY2RmKGZzY29yZSwgZGYxLCBkZjIpO1xuICB9XG59KTtcblxualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIGFub3ZhZnNjb3JlOiBmdW5jdGlvbiBhbm92YWZzY29yZSgpIHtcbiAgICByZXR1cm4galN0YXQuYW5vdmFmc2NvcmUodGhpcy50b0FycmF5KCkpO1xuICB9LFxuXG4gIGFub3ZhZnRlczogZnVuY3Rpb24gYW5vdmFmdGVzKCkge1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgbiA9IG4gKyB0aGlzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGpTdGF0LmZ0ZXN0KHRoaXMuYW5vdmFmc2NvcmUoKSwgdGhpcy5sZW5ndGggLSAxLCBuIC0gdGhpcy5sZW5ndGgpO1xuICB9XG59KTtcblxuLy8gVHVrZXkncyByYW5nZSB0ZXN0XG5qU3RhdC5leHRlbmQoe1xuICAvLyAyIHBhcmFtZXRlciBsaXN0c1xuICAvLyAobWVhbjEsIG1lYW4yLCBuMSwgbjIsIHNkKVxuICAvLyAoYXJyYXkxLCBhcnJheTIsIHNkKVxuICBxc2NvcmU6IGZ1bmN0aW9uIHFzY29yZSgpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgbWVhbjEsIG1lYW4yLCBuMSwgbjIsIHNkO1xuICAgIGlmIChpc051bWJlcihhcmdzWzBdKSkge1xuICAgICAgICBtZWFuMSA9IGFyZ3NbMF07XG4gICAgICAgIG1lYW4yID0gYXJnc1sxXTtcbiAgICAgICAgbjEgPSBhcmdzWzJdO1xuICAgICAgICBuMiA9IGFyZ3NbM107XG4gICAgICAgIHNkID0gYXJnc1s0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtZWFuMSA9IGpTdGF0Lm1lYW4oYXJnc1swXSk7XG4gICAgICAgIG1lYW4yID0galN0YXQubWVhbihhcmdzWzFdKTtcbiAgICAgICAgbjEgPSBhcmdzWzBdLmxlbmd0aDtcbiAgICAgICAgbjIgPSBhcmdzWzFdLmxlbmd0aDtcbiAgICAgICAgc2QgPSBhcmdzWzJdO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5hYnMobWVhbjEgLSBtZWFuMikgLyAoc2QgKiBNYXRoLnNxcnQoKDEgLyBuMSArIDEgLyBuMikgLyAyKSk7XG4gIH0sXG5cbiAgLy8gMyBkaWZmZXJlbnQgcGFyYW1ldGVyIGxpc3RzOlxuICAvLyAocXNjb3JlLCBuLCBrKVxuICAvLyAobWVhbjEsIG1lYW4yLCBuMSwgbjIsIHNkLCBuLCBrKVxuICAvLyAoYXJyYXkxLCBhcnJheTIsIHNkLCBuLCBrKVxuICBxdGVzdDogZnVuY3Rpb24gcXRlc3QoKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgcXNjb3JlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcXNjb3JlID0gYXJnc1swXTtcbiAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDcpIHtcbiAgICAgIHFzY29yZSA9IGpTdGF0LnFzY29yZShhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxc2NvcmUgPSBqU3RhdC5xc2NvcmUoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICBhcmdzID0gYXJncy5zbGljZSgzKTtcbiAgICB9XG5cbiAgICB2YXIgbiA9IGFyZ3NbMF07XG4gICAgdmFyIGsgPSBhcmdzWzFdO1xuXG4gICAgcmV0dXJuIDEgLSBqU3RhdC50dWtleS5jZGYocXNjb3JlLCBrLCBuIC0gayk7XG4gIH0sXG5cbiAgdHVrZXloc2Q6IGZ1bmN0aW9uIHR1a2V5aHNkKGFycmF5cykge1xuICAgIHZhciBzZCA9IGpTdGF0LnBvb2xlZHN0ZGV2KGFycmF5cyk7XG4gICAgdmFyIG1lYW5zID0gYXJyYXlzLm1hcChmdW5jdGlvbiAoYXJyKSB7cmV0dXJuIGpTdGF0Lm1lYW4oYXJyKTt9KTtcbiAgICB2YXIgbiA9IGFycmF5cy5yZWR1Y2UoZnVuY3Rpb24gKG4sIGFycikge3JldHVybiBuICsgYXJyLmxlbmd0aDt9LCAwKTtcblxuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgYXJyYXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGpTdGF0LnF0ZXN0KG1lYW5zW2ldLCBtZWFuc1tqXSwgYXJyYXlzW2ldLmxlbmd0aCwgYXJyYXlzW2pdLmxlbmd0aCwgc2QsIG4sIGFycmF5cy5sZW5ndGgpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFtbaSwgal0sIHBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59KTtcblxuLy8gRXJyb3IgQm91bmRzXG5qU3RhdC5leHRlbmQoe1xuICAvLyAyIGRpZmZlcmVudCBwYXJhbWV0ZXIgc2V0dXBzXG4gIC8vICh2YWx1ZSwgYWxwaGEsIHNkLCBuKVxuICAvLyAodmFsdWUsIGFscGhhLCBhcnJheSlcbiAgbm9ybWFsY2k6IGZ1bmN0aW9uIG5vcm1hbGNpKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGFucyA9IG5ldyBBcnJheSgyKSxcbiAgICBjaGFuZ2U7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICBjaGFuZ2UgPSBNYXRoLmFicyhqU3RhdC5ub3JtYWwuaW52KGFyZ3NbMV0gLyAyLCAwLCAxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzJdIC8gTWF0aC5zcXJ0KGFyZ3NbM10pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlID0gTWF0aC5hYnMoalN0YXQubm9ybWFsLmludihhcmdzWzFdIC8gMiwgMCwgMSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgalN0YXQuc3RkZXYoYXJnc1syXSkgLyBNYXRoLnNxcnQoYXJnc1syXS5sZW5ndGgpKTtcbiAgICB9XG4gICAgYW5zWzBdID0gYXJnc1swXSAtIGNoYW5nZTtcbiAgICBhbnNbMV0gPSBhcmdzWzBdICsgY2hhbmdlO1xuICAgIHJldHVybiBhbnM7XG4gIH0sXG5cbiAgLy8gMiBkaWZmZXJlbnQgcGFyYW1ldGVyIHNldHVwc1xuICAvLyAodmFsdWUsIGFscGhhLCBzZCwgbilcbiAgLy8gKHZhbHVlLCBhbHBoYSwgYXJyYXkpXG4gIHRjaTogZnVuY3Rpb24gdGNpKCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIGFucyA9IG5ldyBBcnJheSgyKSxcbiAgICBjaGFuZ2U7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICBjaGFuZ2UgPSBNYXRoLmFicyhqU3RhdC5zdHVkZW50dC5pbnYoYXJnc1sxXSAvIDIsIGFyZ3NbM10gLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzWzJdIC8gTWF0aC5zcXJ0KGFyZ3NbM10pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlID0gTWF0aC5hYnMoalN0YXQuc3R1ZGVudHQuaW52KGFyZ3NbMV0gLyAyLCBhcmdzWzJdLmxlbmd0aCAtIDEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpTdGF0LnN0ZGV2KGFyZ3NbMl0sIHRydWUpIC8gTWF0aC5zcXJ0KGFyZ3NbMl0ubGVuZ3RoKSk7XG4gICAgfVxuICAgIGFuc1swXSA9IGFyZ3NbMF0gLSBjaGFuZ2U7XG4gICAgYW5zWzFdID0gYXJnc1swXSArIGNoYW5nZTtcbiAgICByZXR1cm4gYW5zO1xuICB9LFxuXG4gIHNpZ25pZmljYW50OiBmdW5jdGlvbiBzaWduaWZpY2FudChwdmFsdWUsIGFscGhhKSB7XG4gICAgcmV0dXJuIHB2YWx1ZSA8IGFscGhhO1xuICB9XG59KTtcblxualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIG5vcm1hbGNpOiBmdW5jdGlvbiBub3JtYWxjaSh2YWx1ZSwgYWxwaGEpIHtcbiAgICByZXR1cm4galN0YXQubm9ybWFsY2kodmFsdWUsIGFscGhhLCB0aGlzLnRvQXJyYXkoKSk7XG4gIH0sXG5cbiAgdGNpOiBmdW5jdGlvbiB0Y2kodmFsdWUsIGFscGhhKSB7XG4gICAgcmV0dXJuIGpTdGF0LnRjaSh2YWx1ZSwgYWxwaGEsIHRoaXMudG9BcnJheSgpKTtcbiAgfVxufSk7XG5cbi8vIGludGVybmFsIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgdGhlIHotc2NvcmUgZm9yIGEgZGlmZmVyZW5jZSBvZiBwcm9wb3J0aW9ucyB0ZXN0XG5mdW5jdGlvbiBkaWZmZXJlbmNlT2ZQcm9wb3J0aW9ucyhwMSwgbjEsIHAyLCBuMikge1xuICBpZiAocDEgPiAxIHx8IHAyID4gMSB8fCBwMSA8PSAwIHx8IHAyIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9wb3J0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxXCIpXG4gIH1cbiAgdmFyIHBvb2xlZCA9IChwMSAqIG4xICsgcDIgKiBuMikgLyAobjEgKyBuMik7XG4gIHZhciBzZSA9IE1hdGguc3FydChwb29sZWQgKiAoMSAtIHBvb2xlZCkgKiAoKDEvbjEpICsgKDEvbjIpKSk7XG4gIHJldHVybiAocDEgLSBwMikgLyBzZTtcbn1cblxuLy8gRGlmZmVyZW5jZSBvZiBQcm9wb3J0aW9uc1xualN0YXQuZXh0ZW5kKGpTdGF0LmZuLCB7XG4gIG9uZVNpZGVkRGlmZmVyZW5jZU9mUHJvcG9ydGlvbnM6IGZ1bmN0aW9uIG9uZVNpZGVkRGlmZmVyZW5jZU9mUHJvcG9ydGlvbnMocDEsIG4xLCBwMiwgbjIpIHtcbiAgICB2YXIgeiA9IGRpZmZlcmVuY2VPZlByb3BvcnRpb25zKHAxLCBuMSwgcDIsIG4yKTtcbiAgICByZXR1cm4galN0YXQuenRlc3QoeiwgMSk7XG4gIH0sXG5cbiAgdHdvU2lkZWREaWZmZXJlbmNlT2ZQcm9wb3J0aW9uczogZnVuY3Rpb24gdHdvU2lkZWREaWZmZXJlbmNlT2ZQcm9wb3J0aW9ucyhwMSwgbjEsIHAyLCBuMikge1xuICAgIHZhciB6ID0gZGlmZmVyZW5jZU9mUHJvcG9ydGlvbnMocDEsIG4xLCBwMiwgbjIpO1xuICAgIHJldHVybiBqU3RhdC56dGVzdCh6LCAyKTtcbiAgfVxufSk7XG5cbn0oalN0YXQsIE1hdGgpKTtcbmpTdGF0Lm1vZGVscyA9IChmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBzdWJfcmVncmVzcyhleG9nKSB7XG4gICAgdmFyIHZhcl9jb3VudCA9IGV4b2dbMF0ubGVuZ3RoO1xuICAgIHZhciBtb2RlbExpc3QgPSBqU3RhdC5hcmFuZ2UodmFyX2NvdW50KS5tYXAoZnVuY3Rpb24oZW5kb2dfaW5kZXgpIHtcbiAgICAgIHZhciBleG9nX2luZGV4ID1cbiAgICAgICAgICBqU3RhdC5hcmFuZ2UodmFyX2NvdW50KS5maWx0ZXIoZnVuY3Rpb24oaSl7cmV0dXJuIGkhPT1lbmRvZ19pbmRleH0pO1xuICAgICAgcmV0dXJuIG9scyhqU3RhdC5jb2woZXhvZywgZW5kb2dfaW5kZXgpLm1hcChmdW5jdGlvbih4KXsgcmV0dXJuIHhbMF0gfSksXG4gICAgICAgICAgICAgICAgIGpTdGF0LmNvbChleG9nLCBleG9nX2luZGV4KSlcbiAgICB9KTtcbiAgICByZXR1cm4gbW9kZWxMaXN0O1xuICB9XG5cbiAgLy8gZG8gT0xTIG1vZGVsIHJlZ3Jlc3NcbiAgLy8gZXhvZyBoYXZlIGluY2x1ZGUgY29uc3QgY29sdW1ucyAsaXQgd2lsbCBub3QgZ2VuZXJhdGUgaXQgLkluIGZhY3QsIGV4b2cgaXNcbiAgLy8gXCJkZXNpZ24gbWF0cml4XCIgbG9vayBhdFxuICAvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rlc2lnbl9tYXRyaXhcbiAgZnVuY3Rpb24gb2xzKGVuZG9nLCBleG9nKSB7XG4gICAgdmFyIG5vYnMgPSBlbmRvZy5sZW5ndGg7XG4gICAgdmFyIGRmX21vZGVsID0gZXhvZ1swXS5sZW5ndGggLSAxO1xuICAgIHZhciBkZl9yZXNpZCA9IG5vYnMtZGZfbW9kZWwgLSAxO1xuICAgIHZhciBjb2VmID0galN0YXQubHN0c3EoZXhvZywgZW5kb2cpO1xuICAgIHZhciBwcmVkaWN0ID1cbiAgICAgICAgalN0YXQubXVsdGlwbHkoZXhvZywgY29lZi5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gW3hdIH0pKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbihwKSB7IHJldHVybiBwWzBdIH0pO1xuICAgIHZhciByZXNpZCA9IGpTdGF0LnN1YnRyYWN0KGVuZG9nLCBwcmVkaWN0KTtcbiAgICB2YXIgeWJhciA9IGpTdGF0Lm1lYW4oZW5kb2cpO1xuICAgIC8vIGNvbnN0YW50IGNhdXNlIHByb2JsZW1cbiAgICAvLyB2YXIgU1NUID0galN0YXQuc3VtKGVuZG9nLm1hcChmdW5jdGlvbih5KSB7XG4gICAgLy8gICByZXR1cm4gTWF0aC5wb3coeS15YmFyLDIpO1xuICAgIC8vIH0pKTtcbiAgICB2YXIgU1NFID0galN0YXQuc3VtKHByZWRpY3QubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyhmIC0geWJhciwgMik7XG4gICAgfSkpO1xuICAgIHZhciBTU1IgPSBqU3RhdC5zdW0oZW5kb2cubWFwKGZ1bmN0aW9uKHksIGkpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyh5IC0gcHJlZGljdFtpXSwgMik7XG4gICAgfSkpO1xuICAgIHZhciBTU1QgPSBTU0UgKyBTU1I7XG4gICAgdmFyIFIyID0gKFNTRSAvIFNTVCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXhvZzpleG9nLFxuICAgICAgICBlbmRvZzplbmRvZyxcbiAgICAgICAgbm9iczpub2JzLFxuICAgICAgICBkZl9tb2RlbDpkZl9tb2RlbCxcbiAgICAgICAgZGZfcmVzaWQ6ZGZfcmVzaWQsXG4gICAgICAgIGNvZWY6Y29lZixcbiAgICAgICAgcHJlZGljdDpwcmVkaWN0LFxuICAgICAgICByZXNpZDpyZXNpZCxcbiAgICAgICAgeWJhcjp5YmFyLFxuICAgICAgICBTU1Q6U1NULFxuICAgICAgICBTU0U6U1NFLFxuICAgICAgICBTU1I6U1NSLFxuICAgICAgICBSMjpSMlxuICAgIH07XG4gIH1cblxuICAvLyBIMDogYl9JPTBcbiAgLy8gSDE6IGJfSSE9MFxuICBmdW5jdGlvbiB0X3Rlc3QobW9kZWwpIHtcbiAgICB2YXIgc3ViTW9kZWxMaXN0ID0gc3ViX3JlZ3Jlc3MobW9kZWwuZXhvZyk7XG4gICAgLy92YXIgc2lnbWFIYXQ9alN0YXQuc3RkZXYobW9kZWwucmVzaWQpO1xuICAgIHZhciBzaWdtYUhhdCA9IE1hdGguc3FydChtb2RlbC5TU1IgLyAobW9kZWwuZGZfcmVzaWQpKTtcbiAgICB2YXIgc2VCZXRhSGF0ID0gc3ViTW9kZWxMaXN0Lm1hcChmdW5jdGlvbihtb2QpIHtcbiAgICAgIHZhciBTU1QgPSBtb2QuU1NUO1xuICAgICAgdmFyIFIyID0gbW9kLlIyO1xuICAgICAgcmV0dXJuIHNpZ21hSGF0IC8gTWF0aC5zcXJ0KFNTVCAqICgxIC0gUjIpKTtcbiAgICB9KTtcbiAgICB2YXIgdFN0YXRpc3RpYyA9IG1vZGVsLmNvZWYubWFwKGZ1bmN0aW9uKGNvZWYsIGkpIHtcbiAgICAgIHJldHVybiAoY29lZiAtIDApIC8gc2VCZXRhSGF0W2ldO1xuICAgIH0pO1xuICAgIHZhciBwVmFsdWUgPSB0U3RhdGlzdGljLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgbGVmdHBwZiA9IGpTdGF0LnN0dWRlbnR0LmNkZih0LCBtb2RlbC5kZl9yZXNpZCk7XG4gICAgICByZXR1cm4gKGxlZnRwcGYgPiAwLjUgPyAxIC0gbGVmdHBwZiA6IGxlZnRwcGYpICogMjtcbiAgICB9KTtcbiAgICB2YXIgYyA9IGpTdGF0LnN0dWRlbnR0LmludigwLjk3NSwgbW9kZWwuZGZfcmVzaWQpO1xuICAgIHZhciBpbnRlcnZhbDk1ID0gbW9kZWwuY29lZi5tYXAoZnVuY3Rpb24oY29lZiwgaSkge1xuICAgICAgdmFyIGQgPSBjICogc2VCZXRhSGF0W2ldO1xuICAgICAgcmV0dXJuIFtjb2VmIC0gZCwgY29lZiArIGRdO1xuICAgIH0pXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2U6IHNlQmV0YUhhdCxcbiAgICAgICAgdDogdFN0YXRpc3RpYyxcbiAgICAgICAgcDogcFZhbHVlLFxuICAgICAgICBzaWdtYUhhdDogc2lnbWFIYXQsXG4gICAgICAgIGludGVydmFsOTU6IGludGVydmFsOTVcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gRl90ZXN0KG1vZGVsKSB7XG4gICAgdmFyIEZfc3RhdGlzdGljID1cbiAgICAgICAgKG1vZGVsLlIyIC8gbW9kZWwuZGZfbW9kZWwpIC8gKCgxIC0gbW9kZWwuUjIpIC8gbW9kZWwuZGZfcmVzaWQpO1xuICAgIHZhciBmY2RmID0gZnVuY3Rpb24oeCwgbjEsIG4yKSB7XG4gICAgICByZXR1cm4galN0YXQuYmV0YS5jZGYoeCAvIChuMiAvIG4xICsgeCksIG4xIC8gMiwgbjIgLyAyKVxuICAgIH1cbiAgICB2YXIgcHZhbHVlID0gMSAtIGZjZGYoRl9zdGF0aXN0aWMsIG1vZGVsLmRmX21vZGVsLCBtb2RlbC5kZl9yZXNpZCk7XG4gICAgcmV0dXJuIHsgRl9zdGF0aXN0aWM6IEZfc3RhdGlzdGljLCBwdmFsdWU6IHB2YWx1ZSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gb2xzX3dyYXAoZW5kb2csIGV4b2cpIHtcbiAgICB2YXIgbW9kZWwgPSBvbHMoZW5kb2csZXhvZyk7XG4gICAgdmFyIHR0ZXN0ID0gdF90ZXN0KG1vZGVsKTtcbiAgICB2YXIgZnRlc3QgPSBGX3Rlc3QobW9kZWwpO1xuICAgIC8vIFByb3ZpZGUgdGhlIFdoZXJyeSAvIEV6ZWtpZWwgLyBNY05lbWFyIC8gQ29oZW4gQWRqdXN0ZWQgUl4yXG4gICAgLy8gV2hpY2ggbWF0Y2hlcyB0aGUgJ2FkanVzdGVkIFJeMicgcHJvdmlkZWQgYnkgUidzIGxtIHBhY2thZ2VcbiAgICB2YXIgYWRqdXN0X1IyID1cbiAgICAgICAgMSAtICgxIC0gbW9kZWwuUjIpICogKChtb2RlbC5ub2JzIC0gMSkgLyAobW9kZWwuZGZfcmVzaWQpKTtcbiAgICBtb2RlbC50ID0gdHRlc3Q7XG4gICAgbW9kZWwuZiA9IGZ0ZXN0O1xuICAgIG1vZGVsLmFkanVzdF9SMiA9IGFkanVzdF9SMjtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICByZXR1cm4geyBvbHM6IG9sc193cmFwIH07XG59KSgpO1xuLy9UbyByZWdyZXNzLCBzaW1wbHkgYnVpbGQgWCBtYXRyaXhcbi8vKGFwcGVuZCBjb2x1bW4gb2YgMSdzKSB1c2luZ1xuLy9idWlsZHhtYXRyaXggYW5kIGJ1aWxkIHRoZSBZXG4vL21hdHJpeCB1c2luZyBidWlsZHltYXRyaXhcbi8vKHNpbXBseSB0aGUgdHJhbnNwb3NlKVxuLy9hbmQgcnVuIHJlZ3Jlc3MuXG5cblxuXG4vL1JlZ3Jlc3Npb25zXG5cbmpTdGF0LmV4dGVuZCh7XG4gIGJ1aWxkeG1hdHJpeDogZnVuY3Rpb24gYnVpbGR4bWF0cml4KCl7XG4gICAgLy9QYXJhbWV0ZXJzIHdpbGwgYmUgcGFzc2VkIGluIGFzIHN1Y2hcbiAgICAvLyhhcnJheTEsYXJyYXkyLGFycmF5MywuLi4pXG4gICAgLy9hcyAoeDEseDIseDMsLi4uKVxuICAgIC8vbmVlZHMgdG8gYmUgKDEseDEseDIseDMsLi4uKVxuICAgIHZhciBtYXRyaXhSb3dzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvcih2YXIgaT0wO2k8YXJndW1lbnRzLmxlbmd0aDtpKyspe1xuICAgICAgdmFyIGFycmF5ID0gWzFdO1xuICAgICAgbWF0cml4Um93c1tpXT0gYXJyYXkuY29uY2F0KGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdChtYXRyaXhSb3dzKTtcblxuICB9LFxuXG4gIGJ1aWxkZHhtYXRyaXg6IGZ1bmN0aW9uIGJ1aWxkZHhtYXRyaXgoKSB7XG4gICAgLy9QYXJhbXRlcnMgd2lsbCBiZSBwYXNzZWQgaW4gYXMgc3VjaFxuICAgIC8vKFthcnJheTEsYXJyYXkyLC4uLl1cbiAgICB2YXIgbWF0cml4Um93cyA9IG5ldyBBcnJheShhcmd1bWVudHNbMF0ubGVuZ3RoKTtcbiAgICBmb3IodmFyIGk9MDtpPGFyZ3VtZW50c1swXS5sZW5ndGg7aSsrKXtcbiAgICAgIHZhciBhcnJheSA9IFsxXVxuICAgICAgbWF0cml4Um93c1tpXT0gYXJyYXkuY29uY2F0KGFyZ3VtZW50c1swXVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBqU3RhdChtYXRyaXhSb3dzKTtcblxuICB9LFxuXG4gIGJ1aWxkanhtYXRyaXg6IGZ1bmN0aW9uIGJ1aWxkanhtYXRyaXgoak1hdCkge1xuICAgIC8vQnVpbGRzIGZyb20galN0YXQgTWF0cml4XG4gICAgdmFyIHBhc3MgPSBuZXcgQXJyYXkoak1hdC5sZW5ndGgpXG4gICAgZm9yKHZhciBpPTA7aTxqTWF0Lmxlbmd0aDtpKyspe1xuICAgICAgcGFzc1tpXSA9IGpNYXRbaV07XG4gICAgfVxuICAgIHJldHVybiBqU3RhdC5idWlsZGR4bWF0cml4KHBhc3MpO1xuXG4gIH0sXG5cbiAgYnVpbGR5bWF0cml4OiBmdW5jdGlvbiBidWlsZHltYXRyaXgoYXJyYXkpe1xuICAgIHJldHVybiBqU3RhdChhcnJheSkudHJhbnNwb3NlKCk7XG4gIH0sXG5cbiAgYnVpbGRqeW1hdHJpeDogZnVuY3Rpb24gYnVpbGRqeW1hdHJpeChqTWF0KXtcbiAgICByZXR1cm4gak1hdC50cmFuc3Bvc2UoKTtcbiAgfSxcblxuICBtYXRyaXhtdWx0OiBmdW5jdGlvbiBtYXRyaXhtdWx0KEEsQil7XG4gICAgdmFyIGksIGosIGssIHJlc3VsdCwgc3VtO1xuICAgIGlmIChBLmNvbHMoKSA9PSBCLnJvd3MoKSkge1xuICAgICAgaWYoQi5yb3dzKCk+MSl7XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQS5yb3dzKCk7IGkrKykge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBCLmNvbHMoKTsgaisrKSB7XG4gICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IEEuY29scygpOyBrKyspIHtcbiAgICAgICAgICAgICAgc3VtICs9IEEudG9BcnJheSgpW2ldW2tdICogQi50b0FycmF5KClba11bal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbaV1bal0gPSBzdW07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqU3RhdChyZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgQS5yb3dzKCk7IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSBbXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IEIuY29scygpOyBqKyspIHtcbiAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBBLmNvbHMoKTsgaysrKSB7XG4gICAgICAgICAgICBzdW0gKz0gQS50b0FycmF5KClbaV1ba10gKiBCLnRvQXJyYXkoKVtqXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0W2ldW2pdID0gc3VtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4galN0YXQocmVzdWx0KTtcbiAgICB9XG4gIH0sXG5cbiAgLy9yZWdyZXNzIGFuZCByZWdyZXNzdCB0byBiZSBmaXhlZFxuXG4gIHJlZ3Jlc3M6IGZ1bmN0aW9uIHJlZ3Jlc3Moak1hdFgsak1hdFkpe1xuICAgIC8vcHJpbnQoXCJyZWdyZXNzaW4hXCIpO1xuICAgIC8vcHJpbnQoak1hdFgudG9BcnJheSgpKTtcbiAgICB2YXIgaW5uZXJpbnYgPSBqU3RhdC54dHJhbnNweGludihqTWF0WCk7XG4gICAgLy9wcmludChpbm5lcmludik7XG4gICAgdmFyIHh0cmFuc3AgPSBqTWF0WC50cmFuc3Bvc2UoKTtcbiAgICB2YXIgbmV4dCA9IGpTdGF0Lm1hdHJpeG11bHQoalN0YXQoaW5uZXJpbnYpLHh0cmFuc3ApO1xuICAgIHJldHVybiBqU3RhdC5tYXRyaXhtdWx0KG5leHQsak1hdFkpO1xuXG4gIH0sXG5cbiAgcmVncmVzc3Q6IGZ1bmN0aW9uIHJlZ3Jlc3N0KGpNYXRYLGpNYXRZLHNpZGVzKXtcbiAgICB2YXIgYmV0YSA9IGpTdGF0LnJlZ3Jlc3Moak1hdFgsak1hdFkpO1xuXG4gICAgdmFyIGNvbXBpbGUgPSB7fTtcbiAgICBjb21waWxlLmFub3ZhID0ge307XG4gICAgdmFyIGpNYXRZQmFyID0galN0YXQuak1hdFlCYXIoak1hdFgsIGJldGEpO1xuICAgIGNvbXBpbGUueUJhciA9IGpNYXRZQmFyO1xuICAgIHZhciB5QXZlcmFnZSA9IGpNYXRZLm1lYW4oKTtcbiAgICBjb21waWxlLmFub3ZhLnJlc2lkdWFscyA9IGpTdGF0LnJlc2lkdWFscyhqTWF0WSwgak1hdFlCYXIpO1xuXG4gICAgY29tcGlsZS5hbm92YS5zc3IgPSBqU3RhdC5zc3Ioak1hdFlCYXIsIHlBdmVyYWdlKTtcbiAgICBjb21waWxlLmFub3ZhLm1zciA9IGNvbXBpbGUuYW5vdmEuc3NyIC8gKGpNYXRYWzBdLmxlbmd0aCAtIDEpO1xuXG4gICAgY29tcGlsZS5hbm92YS5zc2UgPSBqU3RhdC5zc2Uoak1hdFksIGpNYXRZQmFyKTtcbiAgICBjb21waWxlLmFub3ZhLm1zZSA9XG4gICAgICAgIGNvbXBpbGUuYW5vdmEuc3NlIC8gKGpNYXRZLmxlbmd0aCAtIChqTWF0WFswXS5sZW5ndGggLSAxKSAtIDEpO1xuXG4gICAgY29tcGlsZS5hbm92YS5zc3QgPSBqU3RhdC5zc3Qoak1hdFksIHlBdmVyYWdlKTtcbiAgICBjb21waWxlLmFub3ZhLm1zdCA9IGNvbXBpbGUuYW5vdmEuc3N0IC8gKGpNYXRZLmxlbmd0aCAtIDEpO1xuXG4gICAgY29tcGlsZS5hbm92YS5yMiA9IDEgLSAoY29tcGlsZS5hbm92YS5zc2UgLyBjb21waWxlLmFub3ZhLnNzdCk7XG4gICAgaWYgKGNvbXBpbGUuYW5vdmEucjIgPCAwKSBjb21waWxlLmFub3ZhLnIyID0gMDtcblxuICAgIGNvbXBpbGUuYW5vdmEuZnJhdGlvID0gY29tcGlsZS5hbm92YS5tc3IgLyBjb21waWxlLmFub3ZhLm1zZTtcbiAgICBjb21waWxlLmFub3ZhLnB2YWx1ZSA9XG4gICAgICAgIGpTdGF0LmFub3ZhZnRlc3QoY29tcGlsZS5hbm92YS5mcmF0aW8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgak1hdFhbMF0ubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBqTWF0WS5sZW5ndGggLSAoak1hdFhbMF0ubGVuZ3RoIC0gMSkgLSAxKTtcblxuICAgIGNvbXBpbGUuYW5vdmEucm1zZSA9IE1hdGguc3FydChjb21waWxlLmFub3ZhLm1zZSk7XG5cbiAgICBjb21waWxlLmFub3ZhLnIyYWRqID0gMSAtIChjb21waWxlLmFub3ZhLm1zZSAvIGNvbXBpbGUuYW5vdmEubXN0KTtcbiAgICBpZiAoY29tcGlsZS5hbm92YS5yMmFkaiA8IDApIGNvbXBpbGUuYW5vdmEucjJhZGogPSAwO1xuXG4gICAgY29tcGlsZS5zdGF0cyA9IG5ldyBBcnJheShqTWF0WFswXS5sZW5ndGgpO1xuICAgIHZhciBjb3ZhciA9IGpTdGF0Lnh0cmFuc3B4aW52KGpNYXRYKTtcbiAgICB2YXIgc2RzLCB0cywgcHM7XG5cbiAgICBmb3IodmFyIGk9MDsgaTxiZXRhLmxlbmd0aDtpKyspe1xuICAgICAgc2RzPU1hdGguc3FydChjb21waWxlLmFub3ZhLm1zZSAqIE1hdGguYWJzKGNvdmFyW2ldW2ldKSk7XG4gICAgICB0cz0gTWF0aC5hYnMoYmV0YVtpXSAvIHNkcyk7XG4gICAgICBwcz0galN0YXQudHRlc3QodHMsIGpNYXRZLmxlbmd0aCAtIGpNYXRYWzBdLmxlbmd0aCAtIDEsIHNpZGVzKTtcblxuICAgICAgY29tcGlsZS5zdGF0c1tpXT1bYmV0YVtpXSwgc2RzLCB0cywgcHNdO1xuICAgIH1cblxuICAgIGNvbXBpbGUucmVncmVzcyA9IGJldGE7XG4gICAgcmV0dXJuIGNvbXBpbGU7XG4gIH0sXG5cbiAgeHRyYW5zcHg6IGZ1bmN0aW9uIHh0cmFuc3B4KGpNYXRYKXtcbiAgICByZXR1cm4galN0YXQubWF0cml4bXVsdChqTWF0WC50cmFuc3Bvc2UoKSxqTWF0WCk7XG4gIH0sXG5cblxuICB4dHJhbnNweGludjogZnVuY3Rpb24geHRyYW5zcHhpbnYoak1hdFgpe1xuICAgIHZhciBpbm5lciA9IGpTdGF0Lm1hdHJpeG11bHQoak1hdFgudHJhbnNwb3NlKCksak1hdFgpO1xuICAgIHZhciBpbm5lcmludiA9IGpTdGF0Lmludihpbm5lcik7XG4gICAgcmV0dXJuIGlubmVyaW52O1xuICB9LFxuXG4gIGpNYXRZQmFyOiBmdW5jdGlvbiBqTWF0WUJhcihqTWF0WCwgYmV0YSkge1xuICAgIHZhciB5QmFyID0galN0YXQubWF0cml4bXVsdChqTWF0WCwgYmV0YSk7XG4gICAgcmV0dXJuIG5ldyBqU3RhdCh5QmFyKTtcbiAgfSxcblxuICByZXNpZHVhbHM6IGZ1bmN0aW9uIHJlc2lkdWFscyhqTWF0WSwgak1hdFlCYXIpIHtcbiAgICByZXR1cm4galN0YXQubWF0cml4c3VidHJhY3Qoak1hdFksIGpNYXRZQmFyKTtcbiAgfSxcblxuICBzc3I6IGZ1bmN0aW9uIHNzcihqTWF0WUJhciwgeUF2ZXJhZ2UpIHtcbiAgICB2YXIgc3NyID0gMDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgak1hdFlCYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNzciArPSBNYXRoLnBvdyhqTWF0WUJhcltpXSAtIHlBdmVyYWdlLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNzcjtcbiAgfSxcblxuICBzc2U6IGZ1bmN0aW9uIHNzZShqTWF0WSwgak1hdFlCYXIpIHtcbiAgICB2YXIgc3NlID0gMDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgak1hdFkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNzZSArPSBNYXRoLnBvdyhqTWF0WVtpXSAtIGpNYXRZQmFyW2ldLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNzZTtcbiAgfSxcblxuICBzc3Q6IGZ1bmN0aW9uIHNzdChqTWF0WSwgeUF2ZXJhZ2UpIHtcbiAgICB2YXIgc3N0ID0gMDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgak1hdFkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNzdCArPSBNYXRoLnBvdyhqTWF0WVtpXSAtIHlBdmVyYWdlLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNzdDtcbiAgfSxcblxuICBtYXRyaXhzdWJ0cmFjdDogZnVuY3Rpb24gbWF0cml4c3VidHJhY3QoQSxCKXtcbiAgICB2YXIgYW5zID0gbmV3IEFycmF5KEEubGVuZ3RoKTtcbiAgICBmb3IodmFyIGk9MDtpPEEubGVuZ3RoO2krKyl7XG4gICAgICBhbnNbaV0gPSBuZXcgQXJyYXkoQVtpXS5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBqPTA7ajxBW2ldLmxlbmd0aDtqKyspe1xuICAgICAgICBhbnNbaV1bal09QVtpXVtqXS1CW2ldW2pdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4galN0YXQoYW5zKTtcbiAgfVxufSk7XG4gIC8vIE1ha2UgaXQgY29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIHZlcnNpb24uXG4gIGpTdGF0LmpTdGF0ID0galN0YXQ7XG5cbiAgcmV0dXJuIGpTdGF0O1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///162\n")},379:module=>{"use strict";eval('\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = "".concat(id, " ").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLDZCQUE2QjtBQUNsRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW94bmV0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzJkYmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcblxuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG5cbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///379\n')},569:module=>{"use strict";eval('\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === "undefined") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error("Couldn\'t find a style target. This probably means that the value for the \'insert\' parameter is invalid.");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Rpb3huZXQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzP2IyMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuXG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///569\n')},216:module=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement("style");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlveG5ldC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcz9kZTZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///216\n')},565:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute("nonce", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTY1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSxjQUFjLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTs7QUFFakY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW94bmV0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzP2RkY2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///565\n')},795:module=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = "";\n\n  if (obj.supports) {\n    css += "@supports (".concat(obj.supports, ") {");\n  }\n\n  if (obj.media) {\n    css += "@media ".concat(obj.media, " {");\n  }\n\n  var needLayer = typeof obj.layer !== "undefined";\n\n  if (needLayer) {\n    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += "}";\n  }\n\n  if (obj.media) {\n    css += "}";\n  }\n\n  if (obj.supports) {\n    css += "}";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== "undefined") {\n    css += "\\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTs7QUFFQTtBQUNBLGlGQUFpRjtBQUNqRjs7QUFFQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RCxJQUFJOztBQUVKOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW94bmV0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanM/ZTQ3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuXG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cblxuICBjc3MgKz0gb2JqLmNzcztcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///795\n')},589:module=>{"use strict";eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTg5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW94bmV0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanM/MWRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///589\n")},87:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Point": () => (/* binding */ Point),\n/* harmony export */   "Rectangle": () => (/* binding */ Rectangle)\n/* harmony export */ });\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y\n    }\n}\n\nclass Rectangle {\n    constructor(x, y, width, height) {\n        this.x = x\n        this.y = y\n        this.width = width\n        this.height = height\n    }\n\n    get x2() {\n        return this.x + this.width\n    }\n\n    get y2() {\n        return this.y + this.height\n    }\n\n    removeMargin(margin) {\n        return new Rectangle(this.x + margin, this.y + margin, this.width - margin * 2, this.height - margin * 2)\n    }\n\n    leftFraction(fraction) {\n        return new Rectangle(this.x, this.y, this.width * fraction, this.height)\n    }\n\n    hFraction(f1, f2) {\n        return new Rectangle(this.x + this.width * f1, this.y, this.width * (f2 - f1), this.height)\n    }\n\n    vFraction(f1, f2) {\n        return new Rectangle(this.x, this.y + this.height * f1, this.width, this.height * (f2 - f1))\n    }\n\n    center() {\n        return new Point(this.x + this.width / 2, this.y + this.height / 2)\n    }\n\n    vCenter(height) {\n        return new Rectangle(this.x, this.y + (this.height - height) / 2, this.width, height)\n    }\n\n    top(height){\n        return new Rectangle(this.x, this.y, this.width, height)\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Rpb3huZXQvLi9zcmMvZ2VvbS5qcz83MjFhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAgY2xhc3MgUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlY3RhbmdsZSB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnggPSB4XG4gICAgICAgIHRoaXMueSA9IHlcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgfVxuXG4gICAgZ2V0IHgyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aFxuICAgIH1cblxuICAgIGdldCB5MigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0XG4gICAgfVxuXG4gICAgcmVtb3ZlTWFyZ2luKG1hcmdpbikge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggKyBtYXJnaW4sIHRoaXMueSArIG1hcmdpbiwgdGhpcy53aWR0aCAtIG1hcmdpbiAqIDIsIHRoaXMuaGVpZ2h0IC0gbWFyZ2luICogMilcbiAgICB9XG5cbiAgICBsZWZ0RnJhY3Rpb24oZnJhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGggKiBmcmFjdGlvbiwgdGhpcy5oZWlnaHQpXG4gICAgfVxuXG4gICAgaEZyYWN0aW9uKGYxLCBmMikge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggKyB0aGlzLndpZHRoICogZjEsIHRoaXMueSwgdGhpcy53aWR0aCAqIChmMiAtIGYxKSwgdGhpcy5oZWlnaHQpXG4gICAgfVxuXG4gICAgdkZyYWN0aW9uKGYxLCBmMikge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSArIHRoaXMuaGVpZ2h0ICogZjEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0ICogKGYyIC0gZjEpKVxuICAgIH1cblxuICAgIGNlbnRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGlzLndpZHRoIC8gMiwgdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyKVxuICAgIH1cblxuICAgIHZDZW50ZXIoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55ICsgKHRoaXMuaGVpZ2h0IC0gaGVpZ2h0KSAvIDIsIHRoaXMud2lkdGgsIGhlaWdodClcbiAgICB9XG5cbiAgICB0b3AoaGVpZ2h0KXtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIGhlaWdodClcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///87\n')},473:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\nvar injectStylesIntoStyleTag = __webpack_require__(379);\nvar injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js\nvar styleDomAPI = __webpack_require__(795);\nvar styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js\nvar insertBySelector = __webpack_require__(569);\nvar insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\nvar setAttributesWithoutAttributes = __webpack_require__(565);\nvar setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js\nvar insertStyleElement = __webpack_require__(216);\nvar insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js\nvar styleTagTransform = __webpack_require__(589);\nvar styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);\n// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./src/index.css\nvar cjs_js_src = __webpack_require__(424);\n;// CONCATENATED MODULE: ./src/index.css\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (styleTagTransform_default());\noptions.setAttributes = (setAttributesWithoutAttributes_default());\n\n      options.insert = insertBySelector_default().bind(null, "head");\n    \noptions.domAPI = (styleDomAPI_default());\noptions.insertStyleElement = (insertStyleElement_default());\n\nvar update = injectStylesIntoStyleTag_default()(cjs_js_src/* default */.Z, options);\n\n\n\n\n       /* harmony default export */ const src = (cjs_js_src/* default */.Z && cjs_js_src/* default.locals */.Z.locals ? cjs_js_src/* default.locals */.Z.locals : undefined);\n\n;// CONCATENATED MODULE: ./src/random.js\nlet jStat = __webpack_require__(162);\n\nclass Distr {\n    constructor() {\n    }\n\n    sample() {\n        throw "abstract"\n    }\n}\n\nclass GammaDistr extends Distr {\n    constructor(mean, cv, shape, scale) {\n        super()\n        this.mean = mean\n        this.cv = cv\n        this.shape = shape\n        this.scale = scale\n    }\n\n    static fromRateCV(rate, cv) {\n        let shape = 1 / (cv * cv);\n        let scale = 1 / (rate * shape)\n        return new GammaDistr(1 / rate, cv, shape, scale)\n    }\n\n    static fromMeanCV(mean, cv) {\n        let shape = 1 / (cv * cv)\n        let scale = mean / shape\n        return new GammaDistr(mean, cv, shape, scale)\n    }\n\n    sample() {\n        if (this.cv < 1e-50) {\n            return this.mean\n        }\n        return jStat.gamma.sample(this.shape, this.scale)\n    }\n}\n\n;// CONCATENATED MODULE: ./src/heap.js\n// forked from updatable-priority-queue on npm\n\nclass PriorityQueue {\n    constructor(comparator) {\n        this.heap = [];\n        this.comparator = comparator\n    }\n\n    _compare(a, b) {\n        return (this.comparator)(a.key, b.key)\n    }\n\n    _bubbleUp(idx) {\n        let element = this.heap[idx];\n        let parentIdx;\n        let parent;\n        while (idx > 0) {\n            // Compute the parent element\'s index, and fetch it.\n            parentIdx = Math.floor((idx + 1) / 2) - 1;\n            parent = this.heap[parentIdx];\n            // If the parent has a lesser score, things are in order and we\n            // are done.\n            if (this._compare(element, parent) > 0) {\n                break;\n            }\n\n            // Otherwise, swap the parent with the current element and\n            // continue.\n            this.heap[parentIdx] = element;\n            this.heap[idx] = parent;\n            idx = parentIdx;\n        }\n    }\n\n    _sinkDown(idx) {\n        let length = this.heap.length;\n        let element = this.heap[idx];\n        let swapIdx;\n\n        while (true) {\n            let rChildIdx = (idx + 1) * 2;\n            let lChildIdx = rChildIdx - 1;\n            swapIdx = -1;\n\n            // if the first child exists\n            if (lChildIdx < length) {\n                let lChild = this.heap[lChildIdx];\n                // and is lower than the element, they must be swapped\n                if (this._compare(lChild, element) < 0) {\n                    swapIdx = lChildIdx;\n                }\n\n                // unless there is another lesser child, which will be the one swapped\n                if (rChildIdx < length) {\n                    const rChild = this.heap[rChildIdx];\n                    if ((swapIdx === -1 || this._compare(rChild, lChild) < 0) && this._compare(rChild, element) < 0) {\n                        swapIdx = rChildIdx;\n                    }\n                }\n            }\n\n            // if no swap occurs, the element found its right place\n            if (swapIdx === -1) {\n                break;\n            }\n\n            // otherwise, swap and continue on next tree level\n            this.heap[idx] = this.heap[swapIdx];\n            this.heap[swapIdx] = element;\n            idx = swapIdx;\n        }\n    }\n\n    _findElementIndex(item) {\n        // TODO: optimize\n        for (let i = 0, l = this.heap.length; i < l; i++) {\n            if (this.heap[i].item === item) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    get count() {\n        return this.heap.length;\n    }\n\n    insert(item, key) {\n        this.heap.push({item, key});\n        this._bubbleUp(this.heap.length - 1);\n    }\n\n    pop() {\n        if (this.heap.length === 0) {\n            return null;\n        }\n        const element = this.heap[0];\n        const end = this.heap.pop();\n        // replace the first element by the last,\n        // and let it sink to its right place\n        if (this.heap.length > 0) {\n            this.heap[0] = end;\n            this._sinkDown(0);\n        }\n        return element;\n    }\n\n    peek() {\n        if (this.heap.length === 0) {\n            return null;\n        }\n        return this.heap[0];\n    }\n\n    updateKey(item, newKey) {\n        const idx = this._findElementIndex(item);\n        if (idx === -1) {\n            return;\n        }\n        const oldKey = this.heap[idx].key;\n        this.heap[idx].key = newKey;\n        if ((this.comparator)(newKey, oldKey) < 0) {\n            this._bubbleUp(idx);\n        } else {\n            this._sinkDown(idx);\n        }\n    }\n};\n\n/* harmony default export */ const heap = (PriorityQueue);\n\n// EXTERNAL MODULE: ./node_modules/enumify/dist/src/index.js\nvar dist_src = __webpack_require__(607);\n;// CONCATENATED MODULE: ./src/base.js\n\n\n\nconst {Point} = __webpack_require__(87);\nconst kTioxColors = [\'rgb(28, 62, 203)\',\n    \'rgb(80, 212, 146)\', \'rgb(151, 78, 224)\',\n    \'rgb(234, 27, 234)\', \'rgb(164, 132, 252)\', \'rgb(29, 157, 127)\',\n    \'rgb(74, 26, 204)\', \'rgb(6, 190, 234)\',\n    \'rgb(206, 24, 115)\', \'rgb(0, 0, 0)\']\nlet enumify = __webpack_require__(607);\n\nclass Priority extends enumify.Enumify {\n    static CANCEL = new Priority()\n    static CORE = new Priority()\n    static TRANSIT = new Priority()\n    static DEFAULT = new Priority()\n    static _ = this.closeEnum();\n\n    compareTo(other) {\n        return this.enumOrdinal - other.enumOrdinal\n    }\n\n}\n\nclass PaintLayer extends dist_src.Enumify {\n    static MACHINE = new PaintLayer();\n    static NODE = new PaintLayer();\n    static EDGE = new PaintLayer();\n    static ITEM = new PaintLayer();\n\n    static NO_PAINT = new PaintLayer();\n    static _ = this.closeEnum();\n}\n\n\nclass TimeKey {\n    constructor(time, priority) {\n        this.time = time\n        this.priority = priority\n    }\n\n    compareTo(other) {\n        if (this.time === other.time) {\n            return this.priority.compareTo(other.priority)\n        }\n        return this.time - other.time\n    }\n}\n\nclass Simulation {\n    constructor() {\n        this.queue = new heap((a, b) => a.compareTo(b))\n        this.actors = new Set()\n        this.time = 0\n    }\n\n    elapse(time) {\n        while (true) {\n            let next = this.queue.peek();\n            if (next && next.item.getWake() < time) {\n                next = next.item\n                let elapse = next.getWake()\n                if (elapse < this.time) {\n                    elapse = this.time\n                }\n                this.time = elapse\n                next.setWake(Number.POSITIVE_INFINITY)\n                next.elapse(elapse, true)\n            } else {\n                break;\n            }\n        }\n        for (let actor of this.actors) {\n            console.assert(actor.getWake() >= time)\n        }\n        for (let actor of this.actors) {\n            actor.elapse(time, false)\n        }\n        this.time = time\n    }\n}\n\nclass Actor {\n    constructor(sim) {\n        console.assert(sim instanceof Simulation, sim)\n        this.sim = sim\n        this._priority = Priority.DEFAULT\n        this._wake = Number.POSITIVE_INFINITY\n        sim.queue.insert(this, new TimeKey(this._wake, this._priority))\n        sim.actors.add(this)\n        this.onProduce = null\n        this.onConsume = null\n    }\n\n    peekProduce() {\n        throw ("Abstract peekProduce " + this.constructor.name)\n    }\n\n    produce(item) {\n        throw ("Abstract produce " + this.constructor.name)\n    }\n\n    peekConsume(item) {\n        throw ("Abstract peekConsume " + this.constructor.name)\n    }\n\n    consume(item) {\n        throw ("Abstract consume " + this.constructor.name)\n    }\n\n    elapse(time, wake) {\n    }\n\n    elapseItem(time, item, wake) {\n    }\n\n    setWake(time = Number.NEGATIVE_INFINITY, priority = Priority.DEFAULT) {\n        console.assert(!isNaN(time))\n        this._wake = time\n        this._priority = priority\n        this.sim.queue.updateKey(this, new TimeKey(this._wake, this._priority))\n    }\n\n    getWake() {\n        return this._wake\n    }\n\n    getPriority() {\n        return this._priority\n    }\n\n    cancel() {\n        this.sim.queue.updateKey(this, new TimeKey(Number.NEGATIVE_INFINITY, Priority.CANCEL))\n        let popped = this.sim.queue.pop()\n        console.assert(popped && popped.item === this);\n        this.sim.actors.delete(this)\n    }\n\n    paint(ctx) {\n        throw ("Abstract paint " + this.constructor.name)\n    }\n\n    reorder() {\n        return null\n    }\n}\n\nclass Item extends Actor {\n    constructor(sim) {\n        super(sim);\n        this.color = kTioxColors[Math.floor(Math.random() * kTioxColors.length)]\n        this.layer = PaintLayer.ITEM\n    }\n\n    elapse(time, wake) {\n        if (this.owner) {\n            this.owner.elapseItem(time, this, wake)\n        }\n    }\n\n    paint(ctx) {\n        ctx.beginPath()\n        let size = 10;\n        ctx.fillStyle = this.color\n        ctx.shadowColor = "black"\n        ctx.shadowBlur = 10;\n        ctx.rect(this.x - size / 2, this.y - size / 2, size, size)\n        ctx.fill()\n    }\n}\n\nclass Driver extends Actor {\n    constructor(sim, from, to) {\n        super(sim)\n        this.from = from\n        this.to = to\n        this.from.onProduce = () => {\n            console.assert(this instanceof Driver)\n            this.setWake()\n        }\n        this.to.onConsume = () => {\n            this.setWake()\n        }\n        this.layer = PaintLayer.NO_PAINT\n    }\n\n    elapse(time, wake) {\n        if (wake) {\n            let item = this.from.peekProduce()\n            if (item && this.to.peekConsume(item)) {\n                this.from.produce(item)\n                this.to.consume(item)\n                this.setWake()\n            }\n        }\n    }\n\n}\n;// CONCATENATED MODULE: ./src/balancer.js\n\n\nclass ConsumerBalancer extends Actor {\n    constructor(sim, outputs) {\n        super(sim)\n        this.outputs = outputs\n        this.peekedOutput = null\n        for (let output of outputs) {\n            output.onConsume = () => {\n                this.onConsume()\n            }\n        }\n        this.layer = PaintLayer.NO_PAINT\n    }\n\n    peekConsume(item) {\n        for (let output of this.outputs) {\n            if (output.peekConsume(item)) {\n                this.peekedOutput = output\n                return true\n            }\n        }\n    }\n\n    consume(item) {\n        if (!this.peekedOutput) {\n            console.assert(this.peekConsume(item))\n        }\n        this.peekedOutput.consume(item)\n        this.peekedOutput = null\n    }\n\n}\n;// CONCATENATED MODULE: ./src/simulation.js\n\n\n\n\nconst {Point: simulation_Point, Rectangle} = __webpack_require__(87);\n\n\nclass Exit extends Actor {\n    constructor(sim) {\n        super(sim)\n        this.layer = PaintLayer.NODE\n    }\n\n    paint(ctx) {\n        ctx.beginPath()\n        ctx.fillStyle = "rgb(230,150,150)"\n        ctx.rect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height)\n        ctx.fill()\n    }\n\n    peekConsume(item) {\n        return true\n    }\n\n    consume(item) {\n        item.cancel()\n    }\n\n    layout(bounds) {\n        this.bounds = bounds\n    }\n\n    inPos() {\n        return new simulation_Point(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.bounds.height / 2)\n    }\n\n}\n\nclass Arrival extends Actor {\n    constructor(sim, delay) {\n        super(sim);\n        this.setWake()\n        this.delay = delay\n        this.output = null\n        this.layer=PaintLayer.NODE\n    }\n\n    elapse(time, wake) {\n        if (wake) {\n            this.setWake(time + this.delay.sample())\n            this.output.consume(new Item(this.sim))\n        }\n    }\n\n    paint(ctx) {\n        ctx.beginPath()\n        ctx.fillStyle = "rgb(150,230,150)"\n        ctx.rect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height)\n        ctx.fill()\n    }\n\n    layout(bounds) {\n        this.bounds = bounds\n        this.output.layout(bounds.center())\n    }\n\n    outPos() {\n        return new simulation_Point(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.bounds.height / 2)\n    }\n}\n\nclass Transit extends Actor {\n    constructor(sim, delay) {\n        super(sim)\n        this.delay = delay\n        this.output = null\n        this.p1 = null\n        this.p2 = null\n        this.priority = Priority.TRANSIT\n        this.layer = PaintLayer.EDGE\n    }\n\n    elapseItem(time, item, wake) {\n        if (wake) {\n            item.owner = null\n            this.output.consume(item)\n        } else {\n            let f = (this.sim.time - item.start) / (item.getWake() - item.start)\n            item.x = this.p1.x * (1 - f) + this.p2.x * f\n            item.y = this.p1.y * (1 - f) + this.p2.y * f\n        }\n    }\n\n    layout(p1, p2) {\n        this.p1 = p1\n        this.p2 = p2\n    }\n\n    peekConsume(item) {\n        return true\n    }\n\n    consume(item) {\n        item.owner = this\n        item.start = this.sim.time\n        item.setWake(this.sim.time + this.delay.sample(), Priority.TRANSIT)\n    }\n\n    paint(ctx) {\n        ctx.beginPath()\n        let from = this.p1\n        let to = this.p2\n        let dx = to.x - from.x\n        let dy = to.y - from.y\n        let f = 5.0 / Math.sqrt(dx * dx + dy * dy)\n        dx *= f\n        dy *= f\n        ctx.moveTo(from.x + dx, from.y + dy)\n        ctx.lineTo(to.x - dx, to.y - dy)\n        ctx.stroke()\n    }\n}\n\nclass Machine extends Actor {\n    constructor(sim, queue, cores) {\n        super(sim)\n        this.cores = cores\n        this.queue = queue\n        for (let core of cores) {\n            core.machine = this\n        }\n        queue.machine = this\n        new Driver(sim, queue, new ConsumerBalancer(sim, cores))\n        this.layer = PaintLayer.MACHINE\n        console.assert(this.layer)\n    }\n\n    paint(ctx) {\n        ctx.beginPath()\n        ctx.rect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height)\n        ctx.stroke();\n    }\n\n    layout(bounds) {\n        this.bounds = bounds\n        this.queue.layout(bounds.hFraction(0, 0.25).removeMargin(kMargin).top(20))\n        for (let i = 0; i < this.cores.length; i++) {\n            this.cores[i].layout(\n                bounds.hFraction(0.25, 1.0)\n                    .vFraction(i / this.cores.length, (i + 1) / this.cores.length)\n                    .removeMargin(3))\n\n        }\n    }\n\n    inPos() {\n        return new simulation_Point(this.bounds.x, this.bounds.y)\n    }\n\n    outPos() {\n        return new simulation_Point(this.bounds.x + this.bounds.width, this.bounds.y)\n    }\n}\n\nclass Core extends Actor {\n    constructor(sim, delay) {\n        super(sim)\n        this.current = null\n        this.delay = delay\n        this.output = null\n        this.priority = Priority.CORE\n        this.layer = PaintLayer.NODE\n    }\n\n    peekConsume(item) {\n        return this.current === null\n    }\n\n    consume(item) {\n        item.owner = this\n        console.assert(this.current === null)\n        this.current = item\n        item.start = this.sim.time\n        item.setWake(this.delay.sample() + this.sim.time, Priority.CORE)\n    }\n\n    elapseItem(time, item, wake) {\n        if (wake) {\n            item.owner = null;\n            this.output.consume(this.current);\n            this.current = null;\n            (this.onConsume)()\n        } else {\n            let f = (this.sim.time - item.start) / (item.getWake() - item.start)\n            item.x = this.bounds.x + this.bounds.width * f\n            item.y = this.bounds.y + this.bounds.height / 2\n        }\n    }\n\n    layout(bounds) {\n        this.bounds = bounds\n    }\n\n    paint(ctx) {\n        ctx.beginPath()\n        ctx.rect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height)\n        if (this.current) {\n            ctx.fillStyle = "rgb(255,150,150)"\n        } else {\n            ctx.fillStyle = "rgb(150,255,150)"\n        }\n        ctx.fill()\n        ctx.stroke()\n    }\n}\n\nclass Queue extends Actor {\n    constructor(sim) {\n        super(sim)\n        this.queue = []\n        this.layer = PaintLayer.NODE\n    }\n\n    peekConsume(item) {\n        return true\n    }\n\n    consume(item) {\n        item.owner = this\n        this.queue.push(item);\n        (this.onProduce)()\n    }\n\n    peekProduce() {\n        if (this.queue.length === 0) {\n            return null\n        } else {\n            return this.queue[0]\n        }\n    }\n\n    produce(item) {\n        console.assert(this.peekProduce() === item)\n        this.queue.shift()\n        item.owner = null\n    }\n\n    elapse(time, wake) {\n        let maxSep = this.bounds.width / this.queue.length;\n        let sep = Math.min(15, maxSep)\n        for (let i = 0; i < this.queue.length; i++) {\n            this.queue[i].x = this.bounds.x2 - sep * i - this.bounds.height / 2;\n            this.queue[i].y = this.bounds.y + this.bounds.height / 2;\n        }\n    }\n\n    layout(bounds) {\n        this.bounds = bounds\n    }\n\n\n    paint(ctx) {\n        ctx.beginPath()\n        ctx.moveTo(this.bounds.x, this.bounds.y)\n        ctx.lineTo(this.bounds.x2, this.bounds.y)\n        ctx.lineTo(this.bounds.x2, this.bounds.y2)\n        ctx.lineTo(this.bounds.x, this.bounds.y2)\n        ctx.stroke()\n    }\n    reorder() {\n        return this.queue.slice().reverse()\n    }\n}\n\nlet kStageWidth = 500\nlet kStageHeight = 400\nlet kMargin = 10\n\nfunction makeSimulation() {\n    let arrivalDistr = GammaDistr.fromRateCV(10.0, 1.0)\n    let requestDistr = GammaDistr.fromMeanCV(1.0, 1.0)\n    let coreDistr = GammaDistr.fromRateCV(0.1, 1.0)\n    let responseDistr = GammaDistr.fromMeanCV(1.0, 1.0)\n\n    let sim = new Simulation()\n    let arrival = new Arrival(sim, arrivalDistr)\n    let request = new Transit(sim, requestDistr)\n    let queue = new Queue(sim)\n    let cores = []\n    for (let i = 0; i < 10; i++) {\n        cores.push(new Core(sim, coreDistr))\n    }\n    let machine = new Machine(sim, queue, cores)\n    let response = new Transit(sim, responseDistr)\n    let exit = new Exit(sim)\n    arrival.output = request\n    request.output = queue\n    for (let core of cores) {\n        core.output = response\n    }\n    response.output = exit\n\n    let bounds = new Rectangle(0, 0, kStageWidth, kStageHeight)\n    bounds = bounds.removeMargin(kMargin)\n    machine.layout(bounds.vFraction(0.2, 0.7).hFraction(0.1, 0.9))\n    arrival.layout(bounds.hFraction(0.3, 0.4).vFraction(0.0, 0.1))\n    exit.layout(bounds.hFraction(0.6, 0.7).vFraction(0.0, 0.1))\n    request.layout(arrival.outPos(), machine.inPos())\n    response.layout(machine.outPos(), exit.inPos())\n    return sim\n}\n;// CONCATENATED MODULE: ./src/assets/images/play.svg\n/* harmony default export */ const play = ("data:image/svg+xml;base64,PCEtLSBVcGxvYWRlZCB0bzogU1ZHIFJlcG8sIHd3dy5zdmdyZXBvLmNvbSwgVHJhbnNmb3JtZWQgYnk6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPgo8c3ZnIHdpZHRoPSI4MDBweCIgaGVpZ2h0PSI4MDBweCIgdmlld0JveD0iLTEgMCAxNCAxNCIgaWQ9Im1ldGVvci1pY29uLWtpdF9fc29saWQtcGxheS1zIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMCAxLjAwMTU0VjEzLjAwMTVDMCAxMy43Nzg4IDAuODQ3OTcgMTQuMjU5IDEuNTE0NSAxMy44NTlMMTEuNTE0NSA3Ljg1OUMxMi4xNjE4IDcuNDcwNiAxMi4xNjE4IDYuNTMyNSAxMS41MTQ1IDYuMTQ0MUwxLjUxNDUgMC4xNDQwNUMwLjg0Nzk3IC0wLjI1NTg2IDAgMC4yMjQyNSAwIDEuMDAxNTR6IiBmaWxsPSIjNzU4Q0EzIi8+PC9zdmc+");\n;// CONCATENATED MODULE: ./src/assets/images/pause.svg\n/* harmony default export */ const pause = ("data:image/svg+xml;base64,PCEtLSBVcGxvYWRlZCB0bzogU1ZHIFJlcG8sIHd3dy5zdmdyZXBvLmNvbSwgVHJhbnNmb3JtZWQgYnk6IFNWRyBSZXBvIE1peGVyIFRvb2xzIC0tPgo8c3ZnIHdpZHRoPSI4MDBweCIgaGVpZ2h0PSI4MDBweCIgdmlld0JveD0iLTMgMCAyMiAyMiIgaWQ9Im1ldGVvci1pY29uLWtpdF9fc29saWQtcGF1c2UiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0yIDBINUM2LjEwNDYgMCA3IDAuODk1NDMgNyAyVjIwQzcgMjEuMTA0NiA2LjEwNDYgMjIgNSAyMkgyQzAuODk1NDMgMjIgMCAyMS4xMDQ2IDAgMjBWMkMwIDAuODk1NDMgMC44OTU0MyAwIDIgMHpNMTEgMEgxNEMxNS4xMDQ2IDAgMTYgMC44OTU0MyAxNiAyVjIwQzE2IDIxLjEwNDYgMTUuMTA0NiAyMiAxNCAyMkgxMUM5Ljg5NTQgMjIgOSAyMS4xMDQ2IDkgMjBWMkM5IDAuODk1NDMgOS44OTU0IDAgMTEgMHoiIGZpbGw9IiM3NThDQTMiLz48L3N2Zz4=");\n;// CONCATENATED MODULE: ./src/toggle.js\n\n\n\nclass ToggleButton {\n    constructor() {\n        this.button = document.createElement("button");\n        this.button.className = "toggle-button"\n        this.pause = document.createElement("img");\n        this.pause.src = pause;\n        this.button.appendChild(this.pause)\n        this.play = document.createElement("img");\n        this.play.src = play;\n        this.button.appendChild(this.play)\n        this.state = false\n        this.button.addEventListener("click", (e) => this.toggle())\n    }\n\n    toggle() {\n        this.state = !this.state\n    }\n\n    set state(state) {\n        this._state = state;\n        if (state) {\n            this.pause.className = "toggle-button-on"\n            this.play.className = "toggle-button-off"\n        } else {\n            this.pause.className = "toggle-button-off"\n            this.play.className = "toggle-button-on"\n        }\n    }\n\n    get state() {\n        return this._state\n    }\n}\n\n\n;// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\n\n\n\nlet src_jStat = __webpack_require__(162);\n\n\nclass Animation {\n    constructor(canvas) {\n        this.canvas = canvas\n        this.devicePixelRatio = window.devicePixelRatio || 1;\n        this.sim = makeSimulation()\n    }\n\n    revalidate() {\n        let rect = this.canvas.getBoundingClientRect();\n        this.canvas.width = rect.width * this.devicePixelRatio;\n        this.canvas.height = rect.height * this.devicePixelRatio;\n        this.ctx = this.canvas.getContext("2d");\n        let hRatio = this.canvas.width / kStageWidth;\n        let vRatio = this.canvas.height / kStageHeight;\n        if (hRatio < vRatio) {\n            this.ctx.translate(0, this.canvas.height / 2)\n            this.ctx.scale(hRatio, hRatio);\n            this.ctx.translate(0, -kStageHeight / 2)\n        } else {\n            this.ctx.translate(this.canvas.width / 2, 0)\n            this.ctx.scale(vRatio, vRatio);\n            this.ctx.translate(-kStageWidth / 2, 0)\n        }\n        this.ctx.beginPath()\n        this.ctx.rect(0, 0, kStageWidth, kStageHeight)\n        this.ctx.clip()\n    }\n\n    repaint() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.beginPath()\n        this.ctx.moveTo(5, 5);\n        this.ctx.rect(5, 5, kStageWidth - 10, kStageHeight - 10)\n        this.ctx.stroke();\n        let byLayer = PaintLayer.enumValues.map(_ => new Set())\n        let remaining = new Set(this.sim.actors)\n        for (let actor of this.sim.actors) {\n            let reorder = actor.reorder();\n            if (reorder) {\n                for (let ordered of reorder) {\n                    if (remaining.has(ordered)) {\n                        remaining.delete(ordered)\n                        byLayer[ordered.layer.enumOrdinal].add(ordered)\n                    }\n                }\n            }\n        }\n        for (let unordered of remaining) {\n            console.assert(unordered.layer, unordered.constructor.name)\n            byLayer[unordered.layer.enumOrdinal].add(unordered)\n        }\n        byLayer[PaintLayer.NO_PAINT.enumOrdinal] = new Set()\n        for (let layer of byLayer) {\n            for (let actor of layer) {\n                this.ctx.save()\n                actor.paint(this.ctx)\n                this.ctx.restore()\n            }\n        }\n    }\n\n    elapse(time) {\n        this.sim.elapse(time)\n    }\n}\n\n\nlet anim = new Animation(document.getElementById("rootCanvas"))\nanim.revalidate();\nanim.repaint();\n\nlet time = 0\nlet fps = 32\nwindow.setInterval(() => {\n    if (src_play.state) {\n        anim.elapse(time);\n        time += 1.0 / fps\n        anim.repaint();\n    }\n}, 1000 / fps);\n\nlet src_play = new ToggleButton()\nlet rhs = document.getElementById("rhs")\nrhs.appendChild(src_play.button)\n\nwindow.addEventListener(\'resize\', function () {\n    anim.revalidate();\n    anim.repaint();\n}, false);\n\ndocument.addEventListener("keydown", (e) => {\n    if (e.code === "Space") {\n        src_play.toggle()\n        e.stopPropagation()\n        e.preventDefault()\n    }\n},false)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RyxtQkFBTyxDQUFDLEdBQU87OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRCwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVyxFQUFFLFlBQVk7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXLE9BQU8sWUFBWTtBQUMxRDtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFFBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsSUFBSSxRQUFJLE9BQU8sWUFBWTtBQUMzQjtBQUNBLGdCQUFnQixRQUFJOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxRQUFRLFFBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGlveG5ldC8uL3NyYy9pbmRleC5jc3M/Y2ZlNCIsIndlYnBhY2s6Ly90aW94bmV0Ly4vc3JjL3JhbmRvbS5qcz9hYzBiIiwid2VicGFjazovL3Rpb3huZXQvLi9zcmMvaGVhcC5qcz8zOGQ3Iiwid2VicGFjazovL3Rpb3huZXQvLi9zcmMvYmFzZS5qcz80YWUzIiwid2VicGFjazovL3Rpb3huZXQvLi9zcmMvYmFsYW5jZXIuanM/NTJiNyIsIndlYnBhY2s6Ly90aW94bmV0Ly4vc3JjL3NpbXVsYXRpb24uanM/YzkzZCIsIndlYnBhY2s6Ly90aW94bmV0Ly4vc3JjL2Fzc2V0cy9pbWFnZXMvcGxheS5zdmc/MTY3OCIsIndlYnBhY2s6Ly90aW94bmV0Ly4vc3JjL2Fzc2V0cy9pbWFnZXMvcGF1c2Uuc3ZnP2UzZjAiLCJ3ZWJwYWNrOi8vdGlveG5ldC8uL3NyYy90b2dnbGUuanM/MmQ1OCIsIndlYnBhY2s6Ly90aW94bmV0Ly4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4LmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaW5kZXguY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwibGV0IGpTdGF0ID0gcmVxdWlyZSgnanN0YXQnKTtcblxuZXhwb3J0IGNsYXNzIERpc3RyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG5cbiAgICBzYW1wbGUoKSB7XG4gICAgICAgIHRocm93IFwiYWJzdHJhY3RcIlxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEdhbW1hRGlzdHIgZXh0ZW5kcyBEaXN0ciB7XG4gICAgY29uc3RydWN0b3IobWVhbiwgY3YsIHNoYXBlLCBzY2FsZSkge1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMubWVhbiA9IG1lYW5cbiAgICAgICAgdGhpcy5jdiA9IGN2XG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZVxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGVcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVJhdGVDVihyYXRlLCBjdikge1xuICAgICAgICBsZXQgc2hhcGUgPSAxIC8gKGN2ICogY3YpO1xuICAgICAgICBsZXQgc2NhbGUgPSAxIC8gKHJhdGUgKiBzaGFwZSlcbiAgICAgICAgcmV0dXJuIG5ldyBHYW1tYURpc3RyKDEgLyByYXRlLCBjdiwgc2hhcGUsIHNjYWxlKVxuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tTWVhbkNWKG1lYW4sIGN2KSB7XG4gICAgICAgIGxldCBzaGFwZSA9IDEgLyAoY3YgKiBjdilcbiAgICAgICAgbGV0IHNjYWxlID0gbWVhbiAvIHNoYXBlXG4gICAgICAgIHJldHVybiBuZXcgR2FtbWFEaXN0cihtZWFuLCBjdiwgc2hhcGUsIHNjYWxlKVxuICAgIH1cblxuICAgIHNhbXBsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3YgPCAxZS01MCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVhblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqU3RhdC5nYW1tYS5zYW1wbGUodGhpcy5zaGFwZSwgdGhpcy5zY2FsZSlcbiAgICB9XG59XG4iLCIvLyBmb3JrZWQgZnJvbSB1cGRhdGFibGUtcHJpb3JpdHktcXVldWUgb24gbnBtXG5cbmNsYXNzIFByaW9yaXR5UXVldWUge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdGhpcy5oZWFwID0gW107XG4gICAgICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3JcbiAgICB9XG5cbiAgICBfY29tcGFyZShhLCBiKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jb21wYXJhdG9yKShhLmtleSwgYi5rZXkpXG4gICAgfVxuXG4gICAgX2J1YmJsZVVwKGlkeCkge1xuICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMuaGVhcFtpZHhdO1xuICAgICAgICBsZXQgcGFyZW50SWR4O1xuICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICB3aGlsZSAoaWR4ID4gMCkge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxuICAgICAgICAgICAgcGFyZW50SWR4ID0gTWF0aC5mbG9vcigoaWR4ICsgMSkgLyAyKSAtIDE7XG4gICAgICAgICAgICBwYXJlbnQgPSB0aGlzLmhlYXBbcGFyZW50SWR4XTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJlbnQgaGFzIGEgbGVzc2VyIHNjb3JlLCB0aGluZ3MgYXJlIGluIG9yZGVyIGFuZCB3ZVxuICAgICAgICAgICAgLy8gYXJlIGRvbmUuXG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGFyZShlbGVtZW50LCBwYXJlbnQpID4gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHN3YXAgdGhlIHBhcmVudCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kXG4gICAgICAgICAgICAvLyBjb250aW51ZS5cbiAgICAgICAgICAgIHRoaXMuaGVhcFtwYXJlbnRJZHhdID0gZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuaGVhcFtpZHhdID0gcGFyZW50O1xuICAgICAgICAgICAgaWR4ID0gcGFyZW50SWR4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NpbmtEb3duKGlkeCkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5oZWFwLmxlbmd0aDtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLmhlYXBbaWR4XTtcbiAgICAgICAgbGV0IHN3YXBJZHg7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGxldCByQ2hpbGRJZHggPSAoaWR4ICsgMSkgKiAyO1xuICAgICAgICAgICAgbGV0IGxDaGlsZElkeCA9IHJDaGlsZElkeCAtIDE7XG4gICAgICAgICAgICBzd2FwSWR4ID0gLTE7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBmaXJzdCBjaGlsZCBleGlzdHNcbiAgICAgICAgICAgIGlmIChsQ2hpbGRJZHggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbENoaWxkID0gdGhpcy5oZWFwW2xDaGlsZElkeF07XG4gICAgICAgICAgICAgICAgLy8gYW5kIGlzIGxvd2VyIHRoYW4gdGhlIGVsZW1lbnQsIHRoZXkgbXVzdCBiZSBzd2FwcGVkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbXBhcmUobENoaWxkLCBlbGVtZW50KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3dhcElkeCA9IGxDaGlsZElkeDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB1bmxlc3MgdGhlcmUgaXMgYW5vdGhlciBsZXNzZXIgY2hpbGQsIHdoaWNoIHdpbGwgYmUgdGhlIG9uZSBzd2FwcGVkXG4gICAgICAgICAgICAgICAgaWYgKHJDaGlsZElkeCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByQ2hpbGQgPSB0aGlzLmhlYXBbckNoaWxkSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzd2FwSWR4ID09PSAtMSB8fCB0aGlzLl9jb21wYXJlKHJDaGlsZCwgbENoaWxkKSA8IDApICYmIHRoaXMuX2NvbXBhcmUockNoaWxkLCBlbGVtZW50KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YXBJZHggPSByQ2hpbGRJZHg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIG5vIHN3YXAgb2NjdXJzLCB0aGUgZWxlbWVudCBmb3VuZCBpdHMgcmlnaHQgcGxhY2VcbiAgICAgICAgICAgIGlmIChzd2FwSWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHN3YXAgYW5kIGNvbnRpbnVlIG9uIG5leHQgdHJlZSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5oZWFwW2lkeF0gPSB0aGlzLmhlYXBbc3dhcElkeF07XG4gICAgICAgICAgICB0aGlzLmhlYXBbc3dhcElkeF0gPSBlbGVtZW50O1xuICAgICAgICAgICAgaWR4ID0gc3dhcElkeDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9maW5kRWxlbWVudEluZGV4KGl0ZW0pIHtcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemVcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmhlYXAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWFwW2ldLml0ZW0gPT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgZ2V0IGNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFwLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpbnNlcnQoaXRlbSwga2V5KSB7XG4gICAgICAgIHRoaXMuaGVhcC5wdXNoKHtpdGVtLCBrZXl9KTtcbiAgICAgICAgdGhpcy5fYnViYmxlVXAodGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIHBvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmhlYXBbMF07XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuaGVhcC5wb3AoKTtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgZmlyc3QgZWxlbWVudCBieSB0aGUgbGFzdCxcbiAgICAgICAgLy8gYW5kIGxldCBpdCBzaW5rIHRvIGl0cyByaWdodCBwbGFjZVxuICAgICAgICBpZiAodGhpcy5oZWFwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGVhcFswXSA9IGVuZDtcbiAgICAgICAgICAgIHRoaXMuX3NpbmtEb3duKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oZWFwWzBdO1xuICAgIH1cblxuICAgIHVwZGF0ZUtleShpdGVtLCBuZXdLZXkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fZmluZEVsZW1lbnRJbmRleChpdGVtKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRLZXkgPSB0aGlzLmhlYXBbaWR4XS5rZXk7XG4gICAgICAgIHRoaXMuaGVhcFtpZHhdLmtleSA9IG5ld0tleTtcbiAgICAgICAgaWYgKCh0aGlzLmNvbXBhcmF0b3IpKG5ld0tleSwgb2xkS2V5KSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2J1YmJsZVVwKGlkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zaW5rRG93bihpZHgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgUHJpb3JpdHlRdWV1ZTtcbiIsImltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gXCIuL2hlYXAuanNcIlxuaW1wb3J0IHtFbnVtaWZ5fSBmcm9tIFwiZW51bWlmeVwiO1xuXG5jb25zdCB7UG9pbnR9ID0gcmVxdWlyZShcIi4vZ2VvbVwiKTtcbmV4cG9ydCBjb25zdCBrVGlveENvbG9ycyA9IFsncmdiKDI4LCA2MiwgMjAzKScsXG4gICAgJ3JnYig4MCwgMjEyLCAxNDYpJywgJ3JnYigxNTEsIDc4LCAyMjQpJyxcbiAgICAncmdiKDIzNCwgMjcsIDIzNCknLCAncmdiKDE2NCwgMTMyLCAyNTIpJywgJ3JnYigyOSwgMTU3LCAxMjcpJyxcbiAgICAncmdiKDc0LCAyNiwgMjA0KScsICdyZ2IoNiwgMTkwLCAyMzQpJyxcbiAgICAncmdiKDIwNiwgMjQsIDExNSknLCAncmdiKDAsIDAsIDApJ11cbmxldCBlbnVtaWZ5ID0gcmVxdWlyZSgnZW51bWlmeScpO1xuXG5leHBvcnQgY2xhc3MgUHJpb3JpdHkgZXh0ZW5kcyBlbnVtaWZ5LkVudW1pZnkge1xuICAgIHN0YXRpYyBDQU5DRUwgPSBuZXcgUHJpb3JpdHkoKVxuICAgIHN0YXRpYyBDT1JFID0gbmV3IFByaW9yaXR5KClcbiAgICBzdGF0aWMgVFJBTlNJVCA9IG5ldyBQcmlvcml0eSgpXG4gICAgc3RhdGljIERFRkFVTFQgPSBuZXcgUHJpb3JpdHkoKVxuICAgIHN0YXRpYyBfID0gdGhpcy5jbG9zZUVudW0oKTtcblxuICAgIGNvbXBhcmVUbyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnVtT3JkaW5hbCAtIG90aGVyLmVudW1PcmRpbmFsXG4gICAgfVxuXG59XG5cbmV4cG9ydCBjbGFzcyBQYWludExheWVyIGV4dGVuZHMgRW51bWlmeSB7XG4gICAgc3RhdGljIE1BQ0hJTkUgPSBuZXcgUGFpbnRMYXllcigpO1xuICAgIHN0YXRpYyBOT0RFID0gbmV3IFBhaW50TGF5ZXIoKTtcbiAgICBzdGF0aWMgRURHRSA9IG5ldyBQYWludExheWVyKCk7XG4gICAgc3RhdGljIElURU0gPSBuZXcgUGFpbnRMYXllcigpO1xuXG4gICAgc3RhdGljIE5PX1BBSU5UID0gbmV3IFBhaW50TGF5ZXIoKTtcbiAgICBzdGF0aWMgXyA9IHRoaXMuY2xvc2VFbnVtKCk7XG59XG5cblxuY2xhc3MgVGltZUtleSB7XG4gICAgY29uc3RydWN0b3IodGltZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgdGhpcy50aW1lID0gdGltZVxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHlcbiAgICB9XG5cbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZSA9PT0gb3RoZXIudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHkuY29tcGFyZVRvKG90aGVyLnByaW9yaXR5KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWUgLSBvdGhlci50aW1lXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2ltdWxhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgoYSwgYikgPT4gYS5jb21wYXJlVG8oYikpXG4gICAgICAgIHRoaXMuYWN0b3JzID0gbmV3IFNldCgpXG4gICAgICAgIHRoaXMudGltZSA9IDBcbiAgICB9XG5cbiAgICBlbGFwc2UodGltZSkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnF1ZXVlLnBlZWsoKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQuaXRlbS5nZXRXYWtlKCkgPCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5leHQuaXRlbVxuICAgICAgICAgICAgICAgIGxldCBlbGFwc2UgPSBuZXh0LmdldFdha2UoKVxuICAgICAgICAgICAgICAgIGlmIChlbGFwc2UgPCB0aGlzLnRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxhcHNlID0gdGhpcy50aW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudGltZSA9IGVsYXBzZVxuICAgICAgICAgICAgICAgIG5leHQuc2V0V2FrZShOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgICAgICAgbmV4dC5lbGFwc2UoZWxhcHNlLCB0cnVlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBhY3RvciBvZiB0aGlzLmFjdG9ycykge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoYWN0b3IuZ2V0V2FrZSgpID49IHRpbWUpXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYWN0b3Igb2YgdGhpcy5hY3RvcnMpIHtcbiAgICAgICAgICAgIGFjdG9yLmVsYXBzZSh0aW1lLCBmYWxzZSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHNpbSkge1xuICAgICAgICBjb25zb2xlLmFzc2VydChzaW0gaW5zdGFuY2VvZiBTaW11bGF0aW9uLCBzaW0pXG4gICAgICAgIHRoaXMuc2ltID0gc2ltXG4gICAgICAgIHRoaXMuX3ByaW9yaXR5ID0gUHJpb3JpdHkuREVGQVVMVFxuICAgICAgICB0aGlzLl93YWtlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICAgIHNpbS5xdWV1ZS5pbnNlcnQodGhpcywgbmV3IFRpbWVLZXkodGhpcy5fd2FrZSwgdGhpcy5fcHJpb3JpdHkpKVxuICAgICAgICBzaW0uYWN0b3JzLmFkZCh0aGlzKVxuICAgICAgICB0aGlzLm9uUHJvZHVjZSA9IG51bGxcbiAgICAgICAgdGhpcy5vbkNvbnN1bWUgPSBudWxsXG4gICAgfVxuXG4gICAgcGVla1Byb2R1Y2UoKSB7XG4gICAgICAgIHRocm93IChcIkFic3RyYWN0IHBlZWtQcm9kdWNlIFwiICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgIH1cblxuICAgIHByb2R1Y2UoaXRlbSkge1xuICAgICAgICB0aHJvdyAoXCJBYnN0cmFjdCBwcm9kdWNlIFwiICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgIH1cblxuICAgIHBlZWtDb25zdW1lKGl0ZW0pIHtcbiAgICAgICAgdGhyb3cgKFwiQWJzdHJhY3QgcGVla0NvbnN1bWUgXCIgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUpXG4gICAgfVxuXG4gICAgY29uc3VtZShpdGVtKSB7XG4gICAgICAgIHRocm93IChcIkFic3RyYWN0IGNvbnN1bWUgXCIgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUpXG4gICAgfVxuXG4gICAgZWxhcHNlKHRpbWUsIHdha2UpIHtcbiAgICB9XG5cbiAgICBlbGFwc2VJdGVtKHRpbWUsIGl0ZW0sIHdha2UpIHtcbiAgICB9XG5cbiAgICBzZXRXYWtlKHRpbWUgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIHByaW9yaXR5ID0gUHJpb3JpdHkuREVGQVVMVCkge1xuICAgICAgICBjb25zb2xlLmFzc2VydCghaXNOYU4odGltZSkpXG4gICAgICAgIHRoaXMuX3dha2UgPSB0aW1lXG4gICAgICAgIHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHlcbiAgICAgICAgdGhpcy5zaW0ucXVldWUudXBkYXRlS2V5KHRoaXMsIG5ldyBUaW1lS2V5KHRoaXMuX3dha2UsIHRoaXMuX3ByaW9yaXR5KSlcbiAgICB9XG5cbiAgICBnZXRXYWtlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2FrZVxuICAgIH1cblxuICAgIGdldFByaW9yaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpb3JpdHlcbiAgICB9XG5cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuc2ltLnF1ZXVlLnVwZGF0ZUtleSh0aGlzLCBuZXcgVGltZUtleShOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIFByaW9yaXR5LkNBTkNFTCkpXG4gICAgICAgIGxldCBwb3BwZWQgPSB0aGlzLnNpbS5xdWV1ZS5wb3AoKVxuICAgICAgICBjb25zb2xlLmFzc2VydChwb3BwZWQgJiYgcG9wcGVkLml0ZW0gPT09IHRoaXMpO1xuICAgICAgICB0aGlzLnNpbS5hY3RvcnMuZGVsZXRlKHRoaXMpXG4gICAgfVxuXG4gICAgcGFpbnQoY3R4KSB7XG4gICAgICAgIHRocm93IChcIkFic3RyYWN0IHBhaW50IFwiICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgIH1cblxuICAgIHJlb3JkZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgSXRlbSBleHRlbmRzIEFjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaW0pIHtcbiAgICAgICAgc3VwZXIoc2ltKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGtUaW94Q29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGtUaW94Q29sb3JzLmxlbmd0aCldXG4gICAgICAgIHRoaXMubGF5ZXIgPSBQYWludExheWVyLklURU1cbiAgICB9XG5cbiAgICBlbGFwc2UodGltZSwgd2FrZSkge1xuICAgICAgICBpZiAodGhpcy5vd25lcikge1xuICAgICAgICAgICAgdGhpcy5vd25lci5lbGFwc2VJdGVtKHRpbWUsIHRoaXMsIHdha2UpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYWludChjdHgpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIGxldCBzaXplID0gMTA7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yXG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwiYmxhY2tcIlxuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDEwO1xuICAgICAgICBjdHgucmVjdCh0aGlzLnggLSBzaXplIC8gMiwgdGhpcy55IC0gc2l6ZSAvIDIsIHNpemUsIHNpemUpXG4gICAgICAgIGN0eC5maWxsKClcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEcml2ZXIgZXh0ZW5kcyBBY3RvciB7XG4gICAgY29uc3RydWN0b3Ioc2ltLCBmcm9tLCB0bykge1xuICAgICAgICBzdXBlcihzaW0pXG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb21cbiAgICAgICAgdGhpcy50byA9IHRvXG4gICAgICAgIHRoaXMuZnJvbS5vblByb2R1Y2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgRHJpdmVyKVxuICAgICAgICAgICAgdGhpcy5zZXRXYWtlKClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvLm9uQ29uc3VtZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0V2FrZSgpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXllciA9IFBhaW50TGF5ZXIuTk9fUEFJTlRcbiAgICB9XG5cbiAgICBlbGFwc2UodGltZSwgd2FrZSkge1xuICAgICAgICBpZiAod2FrZSkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLmZyb20ucGVla1Byb2R1Y2UoKVxuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgdGhpcy50by5wZWVrQ29uc3VtZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbS5wcm9kdWNlKGl0ZW0pXG4gICAgICAgICAgICAgICAgdGhpcy50by5jb25zdW1lKGl0ZW0pXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRXYWtlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufSIsImltcG9ydCB7QWN0b3IsIFBhaW50TGF5ZXJ9IGZyb20gXCIuL2Jhc2UuanNcIjtcblxuZXhwb3J0IGNsYXNzIENvbnN1bWVyQmFsYW5jZXIgZXh0ZW5kcyBBY3RvciB7XG4gICAgY29uc3RydWN0b3Ioc2ltLCBvdXRwdXRzKSB7XG4gICAgICAgIHN1cGVyKHNpbSlcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0c1xuICAgICAgICB0aGlzLnBlZWtlZE91dHB1dCA9IG51bGxcbiAgICAgICAgZm9yIChsZXQgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgICAgICAgIG91dHB1dC5vbkNvbnN1bWUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbnN1bWUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5ZXIgPSBQYWludExheWVyLk5PX1BBSU5UXG4gICAgfVxuXG4gICAgcGVla0NvbnN1bWUoaXRlbSkge1xuICAgICAgICBmb3IgKGxldCBvdXRwdXQgb2YgdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0LnBlZWtDb25zdW1lKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrZWRPdXRwdXQgPSBvdXRwdXRcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3VtZShpdGVtKSB7XG4gICAgICAgIGlmICghdGhpcy5wZWVrZWRPdXRwdXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRoaXMucGVla0NvbnN1bWUoaXRlbSkpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZWVrZWRPdXRwdXQuY29uc3VtZShpdGVtKVxuICAgICAgICB0aGlzLnBlZWtlZE91dHB1dCA9IG51bGxcbiAgICB9XG5cbn0iLCJpbXBvcnQge0FjdG9yLCBTaW11bGF0aW9uLCBJdGVtLCBEcml2ZXIsIFByaW9yaXR5LCBQYWludExheWVyfSBmcm9tIFwiLi9iYXNlLmpzXCJcbmltcG9ydCB7R2FtbWFEaXN0cn0gZnJvbSBcIi4vcmFuZG9tLmpzXCI7XG5pbXBvcnQge0NvbnN1bWVyQmFsYW5jZXJ9IGZyb20gXCIuL2JhbGFuY2VyLmpzXCI7XG5cbmNvbnN0IHtQb2ludCwgUmVjdGFuZ2xlfSA9IHJlcXVpcmUoXCIuL2dlb21cIik7XG5cblxuY2xhc3MgRXhpdCBleHRlbmRzIEFjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaW0pIHtcbiAgICAgICAgc3VwZXIoc2ltKVxuICAgICAgICB0aGlzLmxheWVyID0gUGFpbnRMYXllci5OT0RFXG4gICAgfVxuXG4gICAgcGFpbnQoY3R4KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2IoMjMwLDE1MCwxNTApXCJcbiAgICAgICAgY3R4LnJlY3QodGhpcy5ib3VuZHMueCwgdGhpcy5ib3VuZHMueSwgdGhpcy5ib3VuZHMud2lkdGgsIHRoaXMuYm91bmRzLmhlaWdodClcbiAgICAgICAgY3R4LmZpbGwoKVxuICAgIH1cblxuICAgIHBlZWtDb25zdW1lKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdW1lKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5jYW5jZWwoKVxuICAgIH1cblxuICAgIGxheW91dChib3VuZHMpIHtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSBib3VuZHNcbiAgICB9XG5cbiAgICBpblBvcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmJvdW5kcy54ICsgdGhpcy5ib3VuZHMud2lkdGggLyAyLCB0aGlzLmJvdW5kcy55ICsgdGhpcy5ib3VuZHMuaGVpZ2h0IC8gMilcbiAgICB9XG5cbn1cblxuY2xhc3MgQXJyaXZhbCBleHRlbmRzIEFjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaW0sIGRlbGF5KSB7XG4gICAgICAgIHN1cGVyKHNpbSk7XG4gICAgICAgIHRoaXMuc2V0V2FrZSgpXG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheVxuICAgICAgICB0aGlzLm91dHB1dCA9IG51bGxcbiAgICAgICAgdGhpcy5sYXllcj1QYWludExheWVyLk5PREVcbiAgICB9XG5cbiAgICBlbGFwc2UodGltZSwgd2FrZSkge1xuICAgICAgICBpZiAod2FrZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRXYWtlKHRpbWUgKyB0aGlzLmRlbGF5LnNhbXBsZSgpKVxuICAgICAgICAgICAgdGhpcy5vdXRwdXQuY29uc3VtZShuZXcgSXRlbSh0aGlzLnNpbSkpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYWludChjdHgpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYigxNTAsMjMwLDE1MClcIlxuICAgICAgICBjdHgucmVjdCh0aGlzLmJvdW5kcy54LCB0aGlzLmJvdW5kcy55LCB0aGlzLmJvdW5kcy53aWR0aCwgdGhpcy5ib3VuZHMuaGVpZ2h0KVxuICAgICAgICBjdHguZmlsbCgpXG4gICAgfVxuXG4gICAgbGF5b3V0KGJvdW5kcykge1xuICAgICAgICB0aGlzLmJvdW5kcyA9IGJvdW5kc1xuICAgICAgICB0aGlzLm91dHB1dC5sYXlvdXQoYm91bmRzLmNlbnRlcigpKVxuICAgIH1cblxuICAgIG91dFBvcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmJvdW5kcy54ICsgdGhpcy5ib3VuZHMud2lkdGggLyAyLCB0aGlzLmJvdW5kcy55ICsgdGhpcy5ib3VuZHMuaGVpZ2h0IC8gMilcbiAgICB9XG59XG5cbmNsYXNzIFRyYW5zaXQgZXh0ZW5kcyBBY3RvciB7XG4gICAgY29uc3RydWN0b3Ioc2ltLCBkZWxheSkge1xuICAgICAgICBzdXBlcihzaW0pXG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheVxuICAgICAgICB0aGlzLm91dHB1dCA9IG51bGxcbiAgICAgICAgdGhpcy5wMSA9IG51bGxcbiAgICAgICAgdGhpcy5wMiA9IG51bGxcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IFByaW9yaXR5LlRSQU5TSVRcbiAgICAgICAgdGhpcy5sYXllciA9IFBhaW50TGF5ZXIuRURHRVxuICAgIH1cblxuICAgIGVsYXBzZUl0ZW0odGltZSwgaXRlbSwgd2FrZSkge1xuICAgICAgICBpZiAod2FrZSkge1xuICAgICAgICAgICAgaXRlbS5vd25lciA9IG51bGxcbiAgICAgICAgICAgIHRoaXMub3V0cHV0LmNvbnN1bWUoaXRlbSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmID0gKHRoaXMuc2ltLnRpbWUgLSBpdGVtLnN0YXJ0KSAvIChpdGVtLmdldFdha2UoKSAtIGl0ZW0uc3RhcnQpXG4gICAgICAgICAgICBpdGVtLnggPSB0aGlzLnAxLnggKiAoMSAtIGYpICsgdGhpcy5wMi54ICogZlxuICAgICAgICAgICAgaXRlbS55ID0gdGhpcy5wMS55ICogKDEgLSBmKSArIHRoaXMucDIueSAqIGZcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxheW91dChwMSwgcDIpIHtcbiAgICAgICAgdGhpcy5wMSA9IHAxXG4gICAgICAgIHRoaXMucDIgPSBwMlxuICAgIH1cblxuICAgIHBlZWtDb25zdW1lKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdW1lKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5vd25lciA9IHRoaXNcbiAgICAgICAgaXRlbS5zdGFydCA9IHRoaXMuc2ltLnRpbWVcbiAgICAgICAgaXRlbS5zZXRXYWtlKHRoaXMuc2ltLnRpbWUgKyB0aGlzLmRlbGF5LnNhbXBsZSgpLCBQcmlvcml0eS5UUkFOU0lUKVxuICAgIH1cblxuICAgIHBhaW50KGN0eCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnAxXG4gICAgICAgIGxldCB0byA9IHRoaXMucDJcbiAgICAgICAgbGV0IGR4ID0gdG8ueCAtIGZyb20ueFxuICAgICAgICBsZXQgZHkgPSB0by55IC0gZnJvbS55XG4gICAgICAgIGxldCBmID0gNS4wIC8gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KVxuICAgICAgICBkeCAqPSBmXG4gICAgICAgIGR5ICo9IGZcbiAgICAgICAgY3R4Lm1vdmVUbyhmcm9tLnggKyBkeCwgZnJvbS55ICsgZHkpXG4gICAgICAgIGN0eC5saW5lVG8odG8ueCAtIGR4LCB0by55IC0gZHkpXG4gICAgICAgIGN0eC5zdHJva2UoKVxuICAgIH1cbn1cblxuY2xhc3MgTWFjaGluZSBleHRlbmRzIEFjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaW0sIHF1ZXVlLCBjb3Jlcykge1xuICAgICAgICBzdXBlcihzaW0pXG4gICAgICAgIHRoaXMuY29yZXMgPSBjb3Jlc1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWVcbiAgICAgICAgZm9yIChsZXQgY29yZSBvZiBjb3Jlcykge1xuICAgICAgICAgICAgY29yZS5tYWNoaW5lID0gdGhpc1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLm1hY2hpbmUgPSB0aGlzXG4gICAgICAgIG5ldyBEcml2ZXIoc2ltLCBxdWV1ZSwgbmV3IENvbnN1bWVyQmFsYW5jZXIoc2ltLCBjb3JlcykpXG4gICAgICAgIHRoaXMubGF5ZXIgPSBQYWludExheWVyLk1BQ0hJTkVcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5sYXllcilcbiAgICB9XG5cbiAgICBwYWludChjdHgpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIGN0eC5yZWN0KHRoaXMuYm91bmRzLngsIHRoaXMuYm91bmRzLnksIHRoaXMuYm91bmRzLndpZHRoLCB0aGlzLmJvdW5kcy5oZWlnaHQpXG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBsYXlvdXQoYm91bmRzKSB7XG4gICAgICAgIHRoaXMuYm91bmRzID0gYm91bmRzXG4gICAgICAgIHRoaXMucXVldWUubGF5b3V0KGJvdW5kcy5oRnJhY3Rpb24oMCwgMC4yNSkucmVtb3ZlTWFyZ2luKGtNYXJnaW4pLnRvcCgyMCkpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3Jlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jb3Jlc1tpXS5sYXlvdXQoXG4gICAgICAgICAgICAgICAgYm91bmRzLmhGcmFjdGlvbigwLjI1LCAxLjApXG4gICAgICAgICAgICAgICAgICAgIC52RnJhY3Rpb24oaSAvIHRoaXMuY29yZXMubGVuZ3RoLCAoaSArIDEpIC8gdGhpcy5jb3Jlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVNYXJnaW4oMykpXG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluUG9zKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuYm91bmRzLngsIHRoaXMuYm91bmRzLnkpXG4gICAgfVxuXG4gICAgb3V0UG9zKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuYm91bmRzLnggKyB0aGlzLmJvdW5kcy53aWR0aCwgdGhpcy5ib3VuZHMueSlcbiAgICB9XG59XG5cbmNsYXNzIENvcmUgZXh0ZW5kcyBBY3RvciB7XG4gICAgY29uc3RydWN0b3Ioc2ltLCBkZWxheSkge1xuICAgICAgICBzdXBlcihzaW0pXG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGxcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5XG4gICAgICAgIHRoaXMub3V0cHV0ID0gbnVsbFxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gUHJpb3JpdHkuQ09SRVxuICAgICAgICB0aGlzLmxheWVyID0gUGFpbnRMYXllci5OT0RFXG4gICAgfVxuXG4gICAgcGVla0NvbnN1bWUoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09PSBudWxsXG4gICAgfVxuXG4gICAgY29uc3VtZShpdGVtKSB7XG4gICAgICAgIGl0ZW0ub3duZXIgPSB0aGlzXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRoaXMuY3VycmVudCA9PT0gbnVsbClcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gaXRlbVxuICAgICAgICBpdGVtLnN0YXJ0ID0gdGhpcy5zaW0udGltZVxuICAgICAgICBpdGVtLnNldFdha2UodGhpcy5kZWxheS5zYW1wbGUoKSArIHRoaXMuc2ltLnRpbWUsIFByaW9yaXR5LkNPUkUpXG4gICAgfVxuXG4gICAgZWxhcHNlSXRlbSh0aW1lLCBpdGVtLCB3YWtlKSB7XG4gICAgICAgIGlmICh3YWtlKSB7XG4gICAgICAgICAgICBpdGVtLm93bmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0LmNvbnN1bWUodGhpcy5jdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAodGhpcy5vbkNvbnN1bWUpKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmID0gKHRoaXMuc2ltLnRpbWUgLSBpdGVtLnN0YXJ0KSAvIChpdGVtLmdldFdha2UoKSAtIGl0ZW0uc3RhcnQpXG4gICAgICAgICAgICBpdGVtLnggPSB0aGlzLmJvdW5kcy54ICsgdGhpcy5ib3VuZHMud2lkdGggKiBmXG4gICAgICAgICAgICBpdGVtLnkgPSB0aGlzLmJvdW5kcy55ICsgdGhpcy5ib3VuZHMuaGVpZ2h0IC8gMlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGF5b3V0KGJvdW5kcykge1xuICAgICAgICB0aGlzLmJvdW5kcyA9IGJvdW5kc1xuICAgIH1cblxuICAgIHBhaW50KGN0eCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgY3R4LnJlY3QodGhpcy5ib3VuZHMueCwgdGhpcy5ib3VuZHMueSwgdGhpcy5ib3VuZHMud2lkdGgsIHRoaXMuYm91bmRzLmhlaWdodClcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudCkge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiKDI1NSwxNTAsMTUwKVwiXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2IoMTUwLDI1NSwxNTApXCJcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbCgpXG4gICAgICAgIGN0eC5zdHJva2UoKVxuICAgIH1cbn1cblxuY2xhc3MgUXVldWUgZXh0ZW5kcyBBY3RvciB7XG4gICAgY29uc3RydWN0b3Ioc2ltKSB7XG4gICAgICAgIHN1cGVyKHNpbSlcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdXG4gICAgICAgIHRoaXMubGF5ZXIgPSBQYWludExheWVyLk5PREVcbiAgICB9XG5cbiAgICBwZWVrQ29uc3VtZShpdGVtKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3VtZShpdGVtKSB7XG4gICAgICAgIGl0ZW0ub3duZXIgPSB0aGlzXG4gICAgICAgIHRoaXMucXVldWUucHVzaChpdGVtKTtcbiAgICAgICAgKHRoaXMub25Qcm9kdWNlKSgpXG4gICAgfVxuXG4gICAgcGVla1Byb2R1Y2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlWzBdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9kdWNlKGl0ZW0pIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5wZWVrUHJvZHVjZSgpID09PSBpdGVtKVxuICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KClcbiAgICAgICAgaXRlbS5vd25lciA9IG51bGxcbiAgICB9XG5cbiAgICBlbGFwc2UodGltZSwgd2FrZSkge1xuICAgICAgICBsZXQgbWF4U2VwID0gdGhpcy5ib3VuZHMud2lkdGggLyB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgICAgICAgbGV0IHNlcCA9IE1hdGgubWluKDE1LCBtYXhTZXApXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZVtpXS54ID0gdGhpcy5ib3VuZHMueDIgLSBzZXAgKiBpIC0gdGhpcy5ib3VuZHMuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIHRoaXMucXVldWVbaV0ueSA9IHRoaXMuYm91bmRzLnkgKyB0aGlzLmJvdW5kcy5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGF5b3V0KGJvdW5kcykge1xuICAgICAgICB0aGlzLmJvdW5kcyA9IGJvdW5kc1xuICAgIH1cblxuXG4gICAgcGFpbnQoY3R4KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICBjdHgubW92ZVRvKHRoaXMuYm91bmRzLngsIHRoaXMuYm91bmRzLnkpXG4gICAgICAgIGN0eC5saW5lVG8odGhpcy5ib3VuZHMueDIsIHRoaXMuYm91bmRzLnkpXG4gICAgICAgIGN0eC5saW5lVG8odGhpcy5ib3VuZHMueDIsIHRoaXMuYm91bmRzLnkyKVxuICAgICAgICBjdHgubGluZVRvKHRoaXMuYm91bmRzLngsIHRoaXMuYm91bmRzLnkyKVxuICAgICAgICBjdHguc3Ryb2tlKClcbiAgICB9XG4gICAgcmVvcmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuc2xpY2UoKS5yZXZlcnNlKClcbiAgICB9XG59XG5cbmV4cG9ydCBsZXQga1N0YWdlV2lkdGggPSA1MDBcbmV4cG9ydCBsZXQga1N0YWdlSGVpZ2h0ID0gNDAwXG5leHBvcnQgbGV0IGtNYXJnaW4gPSAxMFxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVNpbXVsYXRpb24oKSB7XG4gICAgbGV0IGFycml2YWxEaXN0ciA9IEdhbW1hRGlzdHIuZnJvbVJhdGVDVigxMC4wLCAxLjApXG4gICAgbGV0IHJlcXVlc3REaXN0ciA9IEdhbW1hRGlzdHIuZnJvbU1lYW5DVigxLjAsIDEuMClcbiAgICBsZXQgY29yZURpc3RyID0gR2FtbWFEaXN0ci5mcm9tUmF0ZUNWKDAuMSwgMS4wKVxuICAgIGxldCByZXNwb25zZURpc3RyID0gR2FtbWFEaXN0ci5mcm9tTWVhbkNWKDEuMCwgMS4wKVxuXG4gICAgbGV0IHNpbSA9IG5ldyBTaW11bGF0aW9uKClcbiAgICBsZXQgYXJyaXZhbCA9IG5ldyBBcnJpdmFsKHNpbSwgYXJyaXZhbERpc3RyKVxuICAgIGxldCByZXF1ZXN0ID0gbmV3IFRyYW5zaXQoc2ltLCByZXF1ZXN0RGlzdHIpXG4gICAgbGV0IHF1ZXVlID0gbmV3IFF1ZXVlKHNpbSlcbiAgICBsZXQgY29yZXMgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb3Jlcy5wdXNoKG5ldyBDb3JlKHNpbSwgY29yZURpc3RyKSlcbiAgICB9XG4gICAgbGV0IG1hY2hpbmUgPSBuZXcgTWFjaGluZShzaW0sIHF1ZXVlLCBjb3JlcylcbiAgICBsZXQgcmVzcG9uc2UgPSBuZXcgVHJhbnNpdChzaW0sIHJlc3BvbnNlRGlzdHIpXG4gICAgbGV0IGV4aXQgPSBuZXcgRXhpdChzaW0pXG4gICAgYXJyaXZhbC5vdXRwdXQgPSByZXF1ZXN0XG4gICAgcmVxdWVzdC5vdXRwdXQgPSBxdWV1ZVxuICAgIGZvciAobGV0IGNvcmUgb2YgY29yZXMpIHtcbiAgICAgICAgY29yZS5vdXRwdXQgPSByZXNwb25zZVxuICAgIH1cbiAgICByZXNwb25zZS5vdXRwdXQgPSBleGl0XG5cbiAgICBsZXQgYm91bmRzID0gbmV3IFJlY3RhbmdsZSgwLCAwLCBrU3RhZ2VXaWR0aCwga1N0YWdlSGVpZ2h0KVxuICAgIGJvdW5kcyA9IGJvdW5kcy5yZW1vdmVNYXJnaW4oa01hcmdpbilcbiAgICBtYWNoaW5lLmxheW91dChib3VuZHMudkZyYWN0aW9uKDAuMiwgMC43KS5oRnJhY3Rpb24oMC4xLCAwLjkpKVxuICAgIGFycml2YWwubGF5b3V0KGJvdW5kcy5oRnJhY3Rpb24oMC4zLCAwLjQpLnZGcmFjdGlvbigwLjAsIDAuMSkpXG4gICAgZXhpdC5sYXlvdXQoYm91bmRzLmhGcmFjdGlvbigwLjYsIDAuNykudkZyYWN0aW9uKDAuMCwgMC4xKSlcbiAgICByZXF1ZXN0LmxheW91dChhcnJpdmFsLm91dFBvcygpLCBtYWNoaW5lLmluUG9zKCkpXG4gICAgcmVzcG9uc2UubGF5b3V0KG1hY2hpbmUub3V0UG9zKCksIGV4aXQuaW5Qb3MoKSlcbiAgICByZXR1cm4gc2ltXG59IiwiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBDRXRMU0JWY0d4dllXUmxaQ0IwYnpvZ1UxWkhJRkpsY0c4c0lIZDNkeTV6ZG1keVpYQnZMbU52YlN3Z1ZISmhibk5tYjNKdFpXUWdZbms2SUZOV1J5QlNaWEJ2SUUxcGVHVnlJRlJ2YjJ4eklDMHRQZ284YzNabklIZHBaSFJvUFNJNE1EQndlQ0lnYUdWcFoyaDBQU0k0TURCd2VDSWdkbWxsZDBKdmVEMGlMVEVnTUNBeE5DQXhOQ0lnYVdROUltMWxkR1Z2Y2kxcFkyOXVMV3RwZEY5ZmMyOXNhV1F0Y0d4aGVTMXpJaUJtYVd4c1BTSnViMjVsSWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpUGp4d1lYUm9JR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NQ0F4TGpBd01UVTBWakV6TGpBd01UVkRNQ0F4TXk0M056ZzRJREF1T0RRM09UY2dNVFF1TWpVNUlERXVOVEUwTlNBeE15NDROVGxNTVRFdU5URTBOU0EzTGpnMU9VTXhNaTR4TmpFNElEY3VORGN3TmlBeE1pNHhOakU0SURZdU5UTXlOU0F4TVM0MU1UUTFJRFl1TVRRME1Vd3hMalV4TkRVZ01DNHhORFF3TlVNd0xqZzBOemszSUMwd0xqSTFOVGcySURBZ01DNHlNalF5TlNBd0lERXVNREF4TlRSNklpQm1hV3hzUFNJak56VTRRMEV6SWk4K1BDOXpkbWMrXCIiLCJleHBvcnQgZGVmYXVsdCBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUENFdExTQlZjR3h2WVdSbFpDQjBiem9nVTFaSElGSmxjRzhzSUhkM2R5NXpkbWR5WlhCdkxtTnZiU3dnVkhKaGJuTm1iM0p0WldRZ1luazZJRk5XUnlCU1pYQnZJRTFwZUdWeUlGUnZiMnh6SUMwdFBnbzhjM1puSUhkcFpIUm9QU0k0TURCd2VDSWdhR1ZwWjJoMFBTSTRNREJ3ZUNJZ2RtbGxkMEp2ZUQwaUxUTWdNQ0F5TWlBeU1pSWdhV1E5SW0xbGRHVnZjaTFwWTI5dUxXdHBkRjlmYzI5c2FXUXRjR0YxYzJVaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWsweUlEQklOVU0yTGpFd05EWWdNQ0EzSURBdU9EazFORE1nTnlBeVZqSXdRemNnTWpFdU1UQTBOaUEyTGpFd05EWWdNaklnTlNBeU1rZ3lRekF1T0RrMU5ETWdNaklnTUNBeU1TNHhNRFEySURBZ01qQldNa013SURBdU9EazFORE1nTUM0NE9UVTBNeUF3SURJZ01IcE5NVEVnTUVneE5FTXhOUzR4TURRMklEQWdNVFlnTUM0NE9UVTBNeUF4TmlBeVZqSXdRekUySURJeExqRXdORFlnTVRVdU1UQTBOaUF5TWlBeE5DQXlNa2d4TVVNNUxqZzVOVFFnTWpJZ09TQXlNUzR4TURRMklEa2dNakJXTWtNNUlEQXVPRGsxTkRNZ09TNDRPVFUwSURBZ01URWdNSG9pSUdacGJHdzlJaU0zTlRoRFFUTWlMejQ4TDNOMlp6ND1cIiIsImltcG9ydCBwbGF5SW1hZ2UgZnJvbSBcIi4vYXNzZXRzL2ltYWdlcy9wbGF5LnN2Z1wiO1xuaW1wb3J0IHBhdXNlSW1hZ2UgZnJvbSBcIi4vYXNzZXRzL2ltYWdlcy9wYXVzZS5zdmdcIjtcblxuZXhwb3J0IGNsYXNzIFRvZ2dsZUJ1dHRvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgICAgdGhpcy5idXR0b24uY2xhc3NOYW1lID0gXCJ0b2dnbGUtYnV0dG9uXCJcbiAgICAgICAgdGhpcy5wYXVzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIHRoaXMucGF1c2Uuc3JjID0gcGF1c2VJbWFnZTtcbiAgICAgICAgdGhpcy5idXR0b24uYXBwZW5kQ2hpbGQodGhpcy5wYXVzZSlcbiAgICAgICAgdGhpcy5wbGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgdGhpcy5wbGF5LnNyYyA9IHBsYXlJbWFnZTtcbiAgICAgICAgdGhpcy5idXR0b24uYXBwZW5kQ2hpbGQodGhpcy5wbGF5KVxuICAgICAgICB0aGlzLnN0YXRlID0gZmFsc2VcbiAgICAgICAgdGhpcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB0aGlzLnRvZ2dsZSgpKVxuICAgIH1cblxuICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICF0aGlzLnN0YXRlXG4gICAgfVxuXG4gICAgc2V0IHN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZS5jbGFzc05hbWUgPSBcInRvZ2dsZS1idXR0b24tb25cIlxuICAgICAgICAgICAgdGhpcy5wbGF5LmNsYXNzTmFtZSA9IFwidG9nZ2xlLWJ1dHRvbi1vZmZcIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXVzZS5jbGFzc05hbWUgPSBcInRvZ2dsZS1idXR0b24tb2ZmXCJcbiAgICAgICAgICAgIHRoaXMucGxheS5jbGFzc05hbWUgPSBcInRvZ2dsZS1idXR0b24tb25cIlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVcbiAgICB9XG59XG5cbiIsImltcG9ydCBcIi4vaW5kZXguY3NzXCJcbmltcG9ydCBwbGF5SW1hZ2UgZnJvbSBcIi4vYXNzZXRzL2ltYWdlcy9wbGF5LnN2Z1wiO1xuaW1wb3J0IHtHYW1tYURpc3R9IGZyb20gXCIuL3JhbmRvbS5qc1wiXG5pbXBvcnQge1BvaW50LCBSZWN0YW5nbGV9IGZyb20gXCIuL2dlb20uanNcIlxuaW1wb3J0IHttYWtlU2ltdWxhdGlvbiwga1N0YWdlV2lkdGgsIGtTdGFnZUhlaWdodH0gZnJvbSBcIi4vc2ltdWxhdGlvbi5qc1wiXG5pbXBvcnQge0FjdG9yLCBJdGVtLCBQYWludExheWVyLCBTaW11bGF0aW9ufSBmcm9tIFwiLi9iYXNlLmpzXCJcbmltcG9ydCB7VG9nZ2xlQnV0dG9ufSBmcm9tIFwiLi90b2dnbGUuanNcIlxuXG5sZXQgalN0YXQgPSByZXF1aXJlKCdqc3RhdCcpO1xuXG5cbmNsYXNzIEFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzXG4gICAgICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIHRoaXMuc2ltID0gbWFrZVNpbXVsYXRpb24oKVxuICAgIH1cblxuICAgIHJldmFsaWRhdGUoKSB7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gcmVjdC53aWR0aCAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBsZXQgaFJhdGlvID0gdGhpcy5jYW52YXMud2lkdGggLyBrU3RhZ2VXaWR0aDtcbiAgICAgICAgbGV0IHZSYXRpbyA9IHRoaXMuY2FudmFzLmhlaWdodCAvIGtTdGFnZUhlaWdodDtcbiAgICAgICAgaWYgKGhSYXRpbyA8IHZSYXRpbykge1xuICAgICAgICAgICAgdGhpcy5jdHgudHJhbnNsYXRlKDAsIHRoaXMuY2FudmFzLmhlaWdodCAvIDIpXG4gICAgICAgICAgICB0aGlzLmN0eC5zY2FsZShoUmF0aW8sIGhSYXRpbyk7XG4gICAgICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoMCwgLWtTdGFnZUhlaWdodCAvIDIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUodGhpcy5jYW52YXMud2lkdGggLyAyLCAwKVxuICAgICAgICAgICAgdGhpcy5jdHguc2NhbGUodlJhdGlvLCB2UmF0aW8pO1xuICAgICAgICAgICAgdGhpcy5jdHgudHJhbnNsYXRlKC1rU3RhZ2VXaWR0aCAvIDIsIDApXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKClcbiAgICAgICAgdGhpcy5jdHgucmVjdCgwLCAwLCBrU3RhZ2VXaWR0aCwga1N0YWdlSGVpZ2h0KVxuICAgICAgICB0aGlzLmN0eC5jbGlwKClcbiAgICB9XG5cbiAgICByZXBhaW50KCkge1xuICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyg1LCA1KTtcbiAgICAgICAgdGhpcy5jdHgucmVjdCg1LCA1LCBrU3RhZ2VXaWR0aCAtIDEwLCBrU3RhZ2VIZWlnaHQgLSAxMClcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gICAgICAgIGxldCBieUxheWVyID0gUGFpbnRMYXllci5lbnVtVmFsdWVzLm1hcChfID0+IG5ldyBTZXQoKSlcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IG5ldyBTZXQodGhpcy5zaW0uYWN0b3JzKVxuICAgICAgICBmb3IgKGxldCBhY3RvciBvZiB0aGlzLnNpbS5hY3RvcnMpIHtcbiAgICAgICAgICAgIGxldCByZW9yZGVyID0gYWN0b3IucmVvcmRlcigpO1xuICAgICAgICAgICAgaWYgKHJlb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcmRlcmVkIG9mIHJlb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZy5oYXMob3JkZXJlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZy5kZWxldGUob3JkZXJlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5TGF5ZXJbb3JkZXJlZC5sYXllci5lbnVtT3JkaW5hbF0uYWRkKG9yZGVyZWQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdW5vcmRlcmVkIG9mIHJlbWFpbmluZykge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodW5vcmRlcmVkLmxheWVyLCB1bm9yZGVyZWQuY29uc3RydWN0b3IubmFtZSlcbiAgICAgICAgICAgIGJ5TGF5ZXJbdW5vcmRlcmVkLmxheWVyLmVudW1PcmRpbmFsXS5hZGQodW5vcmRlcmVkKVxuICAgICAgICB9XG4gICAgICAgIGJ5TGF5ZXJbUGFpbnRMYXllci5OT19QQUlOVC5lbnVtT3JkaW5hbF0gPSBuZXcgU2V0KClcbiAgICAgICAgZm9yIChsZXQgbGF5ZXIgb2YgYnlMYXllcikge1xuICAgICAgICAgICAgZm9yIChsZXQgYWN0b3Igb2YgbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zYXZlKClcbiAgICAgICAgICAgICAgICBhY3Rvci5wYWludCh0aGlzLmN0eClcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVsYXBzZSh0aW1lKSB7XG4gICAgICAgIHRoaXMuc2ltLmVsYXBzZSh0aW1lKVxuICAgIH1cbn1cblxuXG5sZXQgYW5pbSA9IG5ldyBBbmltYXRpb24oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyb290Q2FudmFzXCIpKVxuYW5pbS5yZXZhbGlkYXRlKCk7XG5hbmltLnJlcGFpbnQoKTtcblxubGV0IHRpbWUgPSAwXG5sZXQgZnBzID0gMzJcbndpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgaWYgKHBsYXkuc3RhdGUpIHtcbiAgICAgICAgYW5pbS5lbGFwc2UodGltZSk7XG4gICAgICAgIHRpbWUgKz0gMS4wIC8gZnBzXG4gICAgICAgIGFuaW0ucmVwYWludCgpO1xuICAgIH1cbn0sIDEwMDAgLyBmcHMpO1xuXG5sZXQgcGxheSA9IG5ldyBUb2dnbGVCdXR0b24oKVxubGV0IHJocyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmhzXCIpXG5yaHMuYXBwZW5kQ2hpbGQocGxheS5idXR0b24pXG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgYW5pbS5yZXZhbGlkYXRlKCk7XG4gICAgYW5pbS5yZXBhaW50KCk7XG59LCBmYWxzZSk7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgaWYgKGUuY29kZSA9PT0gXCJTcGFjZVwiKSB7XG4gICAgICAgIHBsYXkudG9nZ2xlKClcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICB9XG59LGZhbHNlKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///473\n')}},g=>{g(g.s=473)}]);